{
  "chunks": [
    {
      "id": "sdk-0",
      "title": "SDK Integration Options and Approaches",
      "category": "SDK",
      "content": "Orderly Network offers multiple integration paths to suit different development needs, ranging from pre-built UI components to low-level API access. Choosing the right approach depends on your desired level of customization and time-to-market.\n\n### 1. Components SDK (React Components)\nThis is the fastest way to launch a DEX. It provides pre-built, themed React components that handle the full trading experience, including the order book, trading forms, and portfolio views.\n\n- **Best for:** Builders who want to ship quickly with minimal UI development.\n- **Customization:** Primarily via theming (colors, fonts) and configuration props.\n- **Reference:** [js-sdk-demo repository](https://github.com/OrderlyNetwork/js-sdk-demo) and the hosted SDK demo.\n\n### 2. Hooks SDK (React Hooks)\nThis approach offers more flexibility than the Components SDK. You build your own custom UI components while using Orderly's React hooks to handle data fetching, authentication, and order management.\n\n- **Best for:** Teams requiring a custom UI/UX who are comfortable with React.\n- **Customization:** Full control over the UI layer; logic handled by hooks.\n- **Reference:** [example-dex repository](https://github.com/OrderlyNetwork/example-dex).\n\n### 3. Core SDK\nThe Core SDK (`@orderly.network/core`) is a minimal wrapper around the REST API and EIP-712 signing logic. It is framework-agnostic and can be used with vanilla JavaScript, Vue, Angular, or mobile frameworks.\n\n- **Best for:** Integrations that do not use React or require very specific architectural control.\n- **Note:** Documentation for the Core SDK is currently limited; developers may need to reference the source code or types.\n\n### 4. Direct REST API Integration\nFor maximum control, you can integrate directly with Orderly's REST APIs and Websockets without using any SDK. This requires you to manually implement account registration, EIP-712 signing, and order management.\n\n- **Best for:** Non-standard environments or teams who want to implement every layer themselves.\n- **Reference:** \"Build on Omnichain\" documentation includes examples in Python, TypeScript, and Java.\n\n### Choosing an Approach\n| Approach | Time to Market | Customization | Complexity |\n| :--- | :--- | :--- | :--- |\n| Components SDK | Fastest | Low (Theming) | Low |\n| Hooks SDK | Medium | High | Medium |\n| Core SDK | Slow | Very High | High |\n| Direct API | Slowest | Total | Very High |",
      "keywords": [
        "integration",
        "components sdk",
        "hooks sdk",
        "core sdk",
        "rest api",
        "react",
        "architecture"
      ]
    },
    {
      "id": "sdk-1",
      "title": "Order Management with the Hooks SDK",
      "category": "SDK",
      "content": "The Hooks SDK provides a robust set of tools for managing the lifecycle of orders, from creation to execution and cancellation. This guide covers the essential hooks and patterns for order management.\n\n### Creating Orders\nUse the `useOrderEntry` hook to handle order creation, validation, and submission. This hook manages the internal state of the order form.\n\n```tsx\nimport { useOrderEntry } from \"@orderly.network/hooks\";\n\nfunction OrderForm() {\n  const { helper, onSubmit, setValue, formattedOrder } = useOrderEntry();\n\n  const handleChange = (key: string, value: any) => {\n    // It is critical to call setValue to update the hook's internal state\n    setValue(key, value);\n  };\n\n  const handleSubmit = () => {\n    // Validate the current state before submitting\n    const validation = helper.validate();\n    if (validation) {\n      console.error(\"Validation Error:\", validation);\n      return;\n    }\n    onSubmit();\n  };\n\n  return (\n    <div>\n      {/* Inputs must bind to setValue */}\n      <input onChange={(e) => handleChange(\"symbol\", e.target.value)} />\n      <button onClick={handleSubmit}>Place Order</button>\n    </div>\n  );\n}\n```\n\n**Important:** Always bind your input `onChange` events to `setValue` or `setValues`. If you do not, the hook will validate and submit the initial/stale values.\n\n### Reduce-Only and Closing Positions\nTo close a position or create a reduce-only order, set `reduce_only: true` in the order payload.\n\n```javascript\n// Example: Market Close\nconst marketClosePayload = {\n  symbol: \"PERP_NEAR_USDC\",\n  order_type: \"MARKET\",\n  side: \"SELL\", // Opposite of current position\n  reduce_only: true,\n  order_quantity: \"7.4\"\n};\n```\n\n### Managing Algo Orders (TP/SL, Stop Market)\n- **TP/SL:** Use the dedicated `useTpSl` hook (available in newer versions) or filter `INCOMPLETE` orders manually.\n- **Stop Market/Stop Limit:** Use the specific hook returned for these orders. To cancel them, use the `cancelAlgoOrder` function provided by that hook, not the standard `cancelOrder`.\n\n### Monitoring Orders\nUse `useOrderStream` to subscribe to real-time order updates. This hook automatically handles pagination and refreshes.\n\n```tsx\nconst { data: orders } = useOrderStream();\n```\n\nTo react to specific events (filled, cancelled, rejected) in real-time, subscribe to the private WebSocket `executionreport` topic using `useWS()`.\n\n```tsx\nimport { useWS } from \"@orderly.network/hooks\";\n\nconst { onMessage } = useWS();\n\nuseEffect(() => {\n  const unsubscribe = onMessage((message) => {\n    if (message.topic === \"executionreport\") {\n      console.log(\"Order Status Update:\", message.data);\n    }\n  });\n  return unsubscribe;\n}, [onMessage]);\n```",
      "keywords": [
        "useOrderEntry",
        "reduce-only",
        "algo orders",
        "tp/sl",
        "websocket",
        "order lifecycle",
        "validation"
      ]
    },
    {
      "id": "sdk-2",
      "title": "Configuring the Components SDK",
      "category": "SDK",
      "content": "The Components SDK relies heavily on provider configuration to function correctly. This section details the necessary setup for `OrderlyAppProvider`, network settings, and chain filtering.\n\n### Provider Setup\nThere are two main providers: `OrderlyConfigProvider` and `OrderlyAppProvider`.\n\n- **`OrderlyAppProvider`**: Use this when you are using Orderly React components (like `TradingPage`). It wraps `OrderlyConfigProvider` and adds additional context for UI components.\n- **`OrderlyConfigProvider`**: Use this if you are only using hooks and not the pre-built UI components.\n\n```tsx\nimport { OrderlyAppProvider } from \"@orderly.network/react\";\n\nfunction App() {\n  return (\n    <OrderlyAppProvider\n      brokerId=\"your_broker_id\"\n      networkId=\"mainnet\" // or \"testnet\"\n      chainFilter={{ mainnet: [Arbitrum, Ethereum], testnet: [] }}\n      // ... other props\n    >\n      <YourTradingApp />\n    </OrderlyAppProvider>\n  );\n}\n```\n\n### Network Configuration\nThe `networkId` prop determines whether the app connects to Orderly's mainnet or testnet infrastructure. It must be a string (`\"mainnet\"` or `\"testnet\"`), **not** a numeric chain ID.\n\n**Note:** Switching between `mainnet` and `testnet` requires a page reload because they are separate environments. You cannot change this prop at runtime without reloading.\n\n### Chain Filtering\nYou can control which chains appear in the wallet selector and trading interface using the `chainFilter` prop. This is essential for restricting your app to specific networks (e.g., only Arbitrum).\n\n```tsx\nimport { Arbitrum, Optimism, Ethereum } from \"@orderly.network/types\";\n\n<OrderlyAppProvider\n  chainFilter={{\n    mainnet: [Arbitrum, Optimism], // Only show these on mainnet\n    testnet: [] // Disable testnets\n  }}\n>\n  {/* ... */}\n</OrderlyAppProvider>\n```\n\n### Custom Wallet Connection\nIf your app already has a connected wallet (e.g., via `ethers` or `wagmi`), you should implement a **Custom Wallet Connection Provider**. This prevents the `TradingPage` from prompting the user to connect again.\n\nRefer to the \"Custom wallet connection provider\" section in the React SDK documentation to wire your existing wallet connector into Orderly's context.\n\n### Troubleshooting\n- **\"useConfig must be used within Provider\"**: Ensure you are not mixing v1 and v2 packages. All `@orderly.network` packages must be on the same aligned version.\n- **Wallet connects but sign-in fails**: Check that your `networkId` matches the environment where your Broker ID is registered. A hardcoded `mainnet` config with a testnet-only broker ID will cause failures.",
      "keywords": [
        "OrderlyAppProvider",
        "chainFilter",
        "networkId",
        "wallet connection",
        "configuration",
        "provider context",
        "testnet"
      ]
    },
    {
      "id": "sdk-3",
      "title": "Account Management and Authentication",
      "category": "SDK",
      "content": "Managing user accounts and authentication is a core part of the Orderly SDK. The SDK abstracts away the complexity of EIP-712 signing and key storage via the `useAccount` hook and the underlying Keystore.\n\n### Account Registration and Connection\nThe `useAccount` hook handles the connection and registration flow.\n\n```tsx\nimport { useAccount } from \"@orderly.network/hooks\";\n\nfunction ConnectWallet() {\n  const { account, createAccount } = useAccount();\n\n  const handleRegister = async () => {\n    try {\n      // createAccount handles the registration and EIP-712 signing\n      await createAccount();\n    } catch (e) {\n      console.error(\"Registration failed\", e);\n    }\n  };\n\n  return <button onClick={handleRegister}>Register / Connect</button>;\n}\n```\n\n**Note:** `createAccount` is specifically for registration. If you encounter `walletClient is undefined`, ensure the wallet is connected and you have called `account.setAddress` before attempting to register.\n\n### Accessing Orderly Keys\nOrderly uses an off-chain keypair (Orderly Key/Secret) for API authentication. The SDK manages this Keystore in `localStorage`.\n\nYou can access these keys programmatically if you need to display them to the user or use them in a backend context.\n\n```tsx\nconst { account } = useAccount();\n\n// Retrieve the stored Orderly Key\nconst orderlyKey = account.keyStore.getOrderlyKey();\nconsole.log(\"Orderly Public Key:\", orderlyKey);\n```\n\n### Switching Chains\nFor integrations supporting multiple EVM chains, you can switch the active chain context programmatically.\n\n```tsx\nconst switchChain = async () => {\n  await account.switchChainId(42161); // Switch to Arbitrum\n};\n```\n\n### Broker Admin Setup\nTo perform broker-level operations (like setting fees), you need a broker admin account.\n\n1. Register a wallet as a normal user under your Broker ID.\n2. Retrieve the API Key/Secret from the UI's \"Manage Account\" modal (reveal keys action).\n3. Use these credentials in your backend scripts or admin tools.\n\n**Note:** The wallet address is **not** the `account_id`. You must use the specific `account_id` associated with the registered wallet.",
      "keywords": [
        "useAccount",
        "authentication",
        "EIP-712",
        "keystore",
        "broker admin",
        "wallet connection",
        "orderly key"
      ]
    },
    {
      "id": "sdk-4",
      "title": "Troubleshooting Common SDK Errors",
      "category": "Troubleshooting",
      "content": "This guide addresses frequent errors encountered during Orderly SDK integration and their solutions.\n\n### Webpack/Bundler Errors\n#### Error: `Attempted import error: 'createClient' is not exported from '@layerzerolabs/scan-client'`\n**Cause:** CRA/Webpack configurations often fail to handle `.mjs` files in `node_modules`.\n**Solution:** Add a webpack rule to your config (e.g., in `craco.config.js` or `next.config.js`).\n\n```javascript\nwebpack: (config) => {\n  config.module.rules.push({\n    test: /\\.mjs$/,\n    include: /node_modules/,\n    type: \"javascript/auto\",\n  });\n  return config;\n}\n```\n\n#### Error: `export 'default' (reexported as 'useSWR') was not found in 'swr'` (Next.js)\n**Cause:** Next.js App Router treats files as server components by default.\n**Solution:** Add `\"use client\";` at the very top of the file where the error occurs.\n\n### Runtime Errors\n#### Error: `Cannot read properties of undefined (reading 'get')` from `useConfig`\n**Cause:** Mixing Orderly SDK v1 and v2 packages in the same application breaks the React Context.\n**Solution:** Ensure all `@orderly.network/*` packages are upgraded to the same aligned version (e.g., all v2.x).\n\n#### Error: `configStore is not defined, please use OrderlyProvider`\n**Cause:** Occurs when using modules like `@orderly.network/portfolio` or `@orderly.network/affiliate` without the proper provider wrapper.\n**Solution:** Wrap your application (or the specific module tree) with `OrderlyAppProvider` or `OrderlyConfigProvider`.\n\n### Wallet and Network Issues\n#### Issue: Solana wallet disconnects on page refresh (SDK v2.8.1+)\n**Cause:** A bug in earlier v2 versions caused the default chain to revert to EVM after refresh.\n**Solution:** Upgrade to SDK v2.8.10 or later.\n\n#### Issue: \"Wrong network\" when switching to Solana Mainnet\n**Cause:** The Solana wallet adapter network defaults to Devnet.\n**Solution:** Explicitly set the network in the `WalletConnectorProvider`.\n\n```tsx\nimport { WalletAdapterNetwork } from \"@solana/wallet-adapter-base\";\n\n<WalletConnectorProvider solanaInitial={{ network: WalletAdapterNetwork.Mainnet }}>\n  {/* ... */}\n</WalletConnectorProvider>\n```\n\n### TradingView Issues\n#### Issue: TradingView overrides (colors/styles) not applying\n**Cause 1:** Using the free version of the TradingView library, which doesn't support all overrides.\n**Cause 2:** Browser localStorage is caching old settings.\n**Solution:**\n1. Ensure you have a valid TradingView Advanced Charts license.\n2. Clear browser localStorage and cache.\n3. Verify your `tradingViewConfig` prop uses the correct `overrides` syntax.",
      "keywords": [
        "webpack",
        "next.js",
        "useConfig",
        "solana",
        "tradingview",
        "provider error",
        "debugging"
      ]
    },
    {
      "id": "sdk-5",
      "title": "Advanced SDK Features and Integrations",
      "category": "SDK",
      "content": "Beyond basic trading, the Orderly SDK supports advanced features like leverage management, collateral tracking, and custom fee structures.\n\n### Leverage Management\nLeverage in Orderly is account-wide (cross-margin) by default, though newer versions support symbol-level leverage. Use the `useLeverage` hook to manage it.\n\n```tsx\nimport { useLeverage } from \"@orderly.network/hooks\";\n\nfunction LeverageControl() {\n  const [maxLeverage, { update, isMutating }] = useLeverage();\n\n  const handleUpdate = async () => {\n    await update({ leverage: 10 }); // Set max leverage to 10x\n  };\n\n  return (\n    <div>\n      <p>Current Max Leverage: {maxLeverage}x</p>\n      <button onClick={handleUpdate} disabled={isMutating}>\n        Set to 10x\n      </button>\n    </div>\n  );\n}\n```\n\n### Collateral and Balance\nTo display user balances and free collateral, use the `useCollateral` hook.\n\n```tsx\nconst { totalCollateral, freeCollateral, totalValue } = useCollateral();\n```\n\n- **`freeCollateral`**: The funds available to open new positions.\n- **`totalCollateral`**: Total wallet balance plus unrealized PnL.\n\n### Fee Tiers and Broker Admin\nOrderly does not enforce a fee-tier structure on the backend; it stores a specific fee rate per user. Brokers must implement their own tiering logic.\n\n1. **Default Fee:** Set a default fee for new users via the \"Update Default Broker Fee\" endpoint.\n2. **Custom Fees:** Use the provided Python script or admin tools to batch update user fee rates based on volume (tiering).\n\n### Liquidation Data\nThere is no dedicated hook for liquidation history. Fetch it using the private API endpoint via `usePrivateQuery`.\n\n```tsx\nconst { data: liquidations } = usePrivateQuery(\"/v1/liquidations\");\n```\n\n### Referral System\nTo integrate referrals:\n1. **Validation:** Use `useCheckReferralCode` (works without wallet connection) to validate a code from a URL parameter (e.g., `?ref=CODE`).\n2. **UI:** Use the `@orderly.network/affiliate` package for pre-built dashboard components.\n\n```tsx\nimport { Dashboard, ReferralProvider } from '@orderly.network/affiliate';\n\n<ReferralProvider\n  becomeAnAffiliateUrl=\"...\"\n  referralLinkUrl=\"...\"\n>\n  <Dashboard.DashboardPage />\n</ReferralProvider>\n```\n\n### Geo-Restrictions\nThe SDK supports geo-blocking by region. You can configure it to block access or show a disclaimer that allows the user to proceed after acknowledgement.",
      "keywords": [
        "leverage",
        "collateral",
        "fees",
        "referrals",
        "liquidation",
        "broker admin",
        "geo-restriction"
      ]
    },
    {
      "id": "sdk-6",
      "title": "SDK Overview and Integration Options",
      "category": "SDK",
      "content": "Orderly Network provides a robust set of SDKs designed to help builders launch decentralized exchanges (DEXs) and trading applications quickly. Orderly provides the perpetual trading infrastructure, order-matching engine, and cross-chain connectivity, while partners build the trading UIs on top.\n\n## Integration Paths\n\nYou can integrate Orderly Network using four primary approaches, depending on your need for speed versus customization:\n\n### 1. Components SDK (React Components)\n- **Best for:** Quickest time-to-market with minimal UI effort.\n- **Details:** Pre-built, themable React components (e.g., TradingPage, OrderBook, Deposit).\n- **Reference:** `OrderlyNetwork/js-sdk-demo` repo.\n\n### 2. Hooks SDK (React Hooks)\n- **Best for:** Developers who want full control over their UI but need logic/state management.\n- **Details:** Provides React hooks for account management, data fetching, and trading logic.\n- **Reference:** `OrderlyNetwork/example-dex` repo.\n\n### 3. Core SDK (`@orderly.network/core`)\n- **Best for:** Non-React frameworks or minimal wrapper requirements.\n- **Details:** A minimal wrapper around Orderly’s API and EIP-712 signing.\n\n### 4. Direct REST API\n- **Best for:** Full control or non-JavaScript environments.\n- **Details:** Integrate directly via REST APIs following the \"Build on EVM\" documentation. A Python connector is also available at `orderly-evm-connector-python`.\n\n## Orderly Architecture\n\nOrderly splits the stack into three distinct layers:\n\n1.  **Asset Layer (Asset Vaults):** Deployed on each supported chain. Users interact here to register, deposit, and withdraw funds.\n2.  **Settlement Layer (Orderly L2):** Runs on a single chain. Users do not interact directly; it acts as the transaction ledger.\n3.  **Engine Layer (Orderbook):** Provides the orderbook and order-related services. Users interact here to manage orders and execute trades.\n\n## Orderly One\n\nOrderly One is a no-code SDK/toolkit that enables developers to launch DEX front-ends connecting to Orderly’s backend. Builders retain full control over their front-end, branding, and user experience. It is a toolkit rather than a managed service.\n\n## Getting Started\n\n- **EVM Quick Start:** `/build-on-omnichain/building-on-omnichain`\n- **NEAR Quick Start:** `/build-on-near/building-on-near`\n- **SDK Overview:** `/sdks/overview`\n\n## Integration Timeframe\n\nThe average integration time is currently around **2–3 weeks**. Early integrations (like WOO) took longer due to less polished documentation, but the process is now streamlined.",
      "keywords": [
        "SDK overview",
        "integration options",
        "architecture",
        "Orderly One",
        "Components SDK",
        "Hooks SDK",
        "Core SDK",
        "REST API"
      ]
    },
    {
      "id": "sdk-7",
      "title": "React Components SDK Guide",
      "category": "SDK",
      "content": "The React Components SDK allows you to build a fully functional trading interface using pre-built UI blocks and pages. It is organized into three layers: **UI Components** (basic elements), **Block Components** (DEX-specific blocks like OrderBook), and **Pages** (full screens like TradingPage).\n\n## Installation\n\nInstall the base component libraries and import the required styles:\n\n```bash\nnpm install @orderly.network/ui @orderly.network/react-app\n```\n\n```ts\nimport \"@orderly.network/ui/dist/styles.css\";\n```\n\n## Setup and Providers\n\nWrap your application with `OrderlyAppProvider` to set global configuration:\n\n```tsx\nimport { OrderlyAppProvider } from \"@orderly.network/react-app\";\n\nconst App = (props) => {\n  return (\n    <OrderlyAppProvider\n      brokerId=\"orderly\"\n      brokerName=\"Orderly\"\n      networkId=\"testnet\"\n      appIcons={{\n        main: { img: \"/logo.png\" },\n        secondary: { img: \"/mobile-logo.png\" }\n      }}\n    >\n      {props.children}\n    </OrderlyAppProvider>\n  );\n};\n```\n\n## Layout with Scaffold\n\nUse the `Scaffold` component from `@orderly.network/ui-scaffold` to handle layout structure (sidebar, top nav, footer).\n\n```tsx\nimport { Scaffold } from \"@orderly.network/ui-scaffold\";\n\n<Scaffold\n  mainNavProps={{\n    logo: { src: \"/logo.png\", alt: \"Logo\" },\n    mainMenus: [\n      { name: \"Trade\", href: \"/trade\" },\n      { name: \"Portfolio\", href: \"/portfolio\" }\n    ]\n  }}\n  routerAdapter={{\n    onRouteChange: (option) => {\n      // Handle navigation logic\n      if (option.target === '_blank') {\n        window.open(option.href, '_blank');\n      } else {\n        // your router navigate function\n      }\n    },\n    currentPath: location.pathname\n  }}\n>\n  {/* Your Page Content */}\n</Scaffold>\n```\n\n## Key Components\n\n### TradingPage\n\nA full-featured trading screen including orderbook, charts, order forms, and position management.\n\n```tsx\nimport { TradingPage } from \"@orderly.network/trading\";\n\n<TradingPage\n  symbol={'PERP_ETH_USDC'}\n  onSymbolChange={(symbol) => console.log(symbol)}\n  tradingViewConfig={{\n    scriptSRC: \"/assets/chart/charting_library/charting_library.js\",\n    library_path: \"/assets/chart/charting_library/\"\n  }}\n/>\n```\n\n### Deposit & Withdraw\n\nRender these components directly or inside a modal.\n\n```tsx\nimport { Deposit, Withdraw, modal } from \"@orderly.network/react\";\n\n// Static usage\n<Deposit onOk={() => console.log(\"Deposit complete\")} />\n\n// Modal usage\nconst { dialog } = modal;\n<Button onClick={() => dialog({ title: \"Withdraw\", content: <Withdraw /> })}>\n  Open Withdraw\n</Button>\n```\n\n### OrderBook\n\nConnect the `OrderBook` component to real-time data streams.\n\n```tsx\nimport { OrderBook } from \"@orderly.network/react\";\nimport { useOrderbookStream, useSymbolsInfo } from \"@orderly.network/hooks\";\n\nexport const MyOrderBook = () => {\n  const [symbol] = useState(\"PERP_ETH_USDC\");\n  const config = useSymbolsInfo();\n  const symbolInfo = config ? config[symbol] : {};\n\n  const [data, { onDepthChange, isLoading, depth, allDepths }] = useOrderbookStream(\n    symbol,\n    undefined,\n    { level: 7 }\n  );\n\n  return (\n    <OrderBook\n      asks={data.asks}\n      bids={data.bids}\n      markPrice={data.markPrice}\n      lastPrice={data.middlePrice!}\n      base={symbolInfo(\"base\")}\n      quote={symbolInfo(\"quote\")}\n      isLoading={isLoading}\n      onDepthChange={onDepthChange}\n      onItemClick={(item) => console.log(\"Clicked\", item)}\n    />\n  );\n};\n```\n\n## Styling\n\nYou can customize styles using CSS variables or specific ID selectors.\n\n**CSS Variables:**\n```css\n:root {\n  --oui-color-primary: #your-color;\n  --oui-font-family: \"Your Font\", sans-serif;\n}\n```\n\n**Specific IDs:**\n```css\n#orderly-order-entry-confirm-button {\n  background-color: #000;\n}\n```",
      "keywords": [
        "React Components",
        "Scaffold",
        "TradingPage",
        "Deposit",
        "Withdraw",
        "OrderBook",
        "Styling",
        "UI Scaffold"
      ]
    },
    {
      "id": "sdk-8",
      "title": "React Hooks SDK Fundamentals",
      "category": "SDK",
      "content": "The React Hooks SDK (`@orderly.network/hooks`) provides the logic and state management layer for Orderly applications. It handles authentication, account management, API requests, and WebSocket connections.\n\n## Installation\n\n```bash\nnpm install @orderly.network/types @orderly.network/hooks\n```\n\n## Initialization\n\nWrap your app with `OrderlyConfigProvider`:\n\n```tsx\nimport { OrderlyConfigProvider } from \"@orderly.network/hooks\";\n\nexport const App = ({ children }) => {\n  return (\n    <OrderlyConfigProvider brokerId=\"<your_id>\" networkId=\"mainnet\">\n      {children}\n    </OrderlyConfigProvider>\n  );\n};\n```\n\n## Account Management\n\n### Connecting a Wallet\n\nUse `useWalletConnector` to handle wallet connections. Note that you must implement the wallet connection UI yourself or use a connector provider.\n\n```tsx\nimport { useWalletConnector } from \"@orderly.network/hooks\";\n\nconst { connect, disconnect, connectedChain } = useWalletConnector();\n\n<button onClick={() => connect()}>Connect Wallet</button>\n```\n\n### Account State\n\nUse `useAccount` to access account status and create Orderly keys.\n\n```tsx\nimport { useAccount } from \"@orderly.network/hooks\";\n\nexport const UserInfo = () => {\n  const { account, state, createAccount, createOrderlyKey } = useAccount();\n\n  const handleCreate = async () => {\n    await createAccount();\n    await createOrderlyKey(30); // Valid for 30 days\n  };\n\n  return (\n    <div>\n      <div>Status: {state.status}</div>\n      <div>Address: {state.address}</div>\n      {state.status !== 'EnableTrading' && (\n        <button onClick={handleCreate}>Enable Trading</button>\n      )}\n    </div>\n  );\n};\n```\n\n### Updating Account Status\n\nAfter connecting a wallet, update the Orderly account state:\n\n```ts\nconst { account } = useAccount();\n\nawait account.setAddress(\"<user_address>\", {\n  provider: window.ethereum, // EIP1193Provider\n  chain: { id: \"0x1\" },\n  wallet: { name: \"MetaMask\" }\n});\n```\n\n## API Data Fetching\n\n### Public API\n\nUse `useQuery` for public GET requests.\n\n```tsx\nconst { data: symbols, isLoading } = useQuery<API.Symbol[]>(\"/v1/public/info\");\n```\n\n### Private API\n\nUse `usePrivateQuery` for authenticated requests. It handles signing automatically.\n\n```tsx\nconst { data: accountInfo, error } = usePrivateQuery(\"/v1/client/info\");\n```\n\n### Mutations (POST/PUT/DELETE)\n\nUse `useMutation` for actions that modify data.\n\n```tsx\nimport { useMutation } from \"@orderly.network/hooks\";\n\nconst [createOrder, { isMutating }] = useMutation(\"/v1/order\");\n\nconst handleSubmit = () => {\n  createOrder({\n    symbol: \"PERP_ETH_USDC\",\n    side: \"BUY\",\n    order_type: \"LIMIT\",\n    order_price: \"3000\",\n    order_quantity: \"0.1\"\n  });\n};\n```\n\n## Configuration\n\nAccess configuration values using `useConfig`.\n\n```ts\nconst networkId = useConfig(\"networkId\");\nconst brokerId = useConfig(\"brokerId\");\n```",
      "keywords": [
        "React Hooks",
        "useAccount",
        "useWalletConnector",
        "useQuery",
        "usePrivateQuery",
        "useMutation",
        "Authentication",
        "ConfigProvider"
      ]
    },
    {
      "id": "sdk-9",
      "title": "React Hooks SDK: Advanced Features",
      "category": "SDK",
      "content": "This guide covers advanced features of the Hooks SDK, including WebSocket subscriptions, trading logic, asset management, and utility hooks.\n\n## WebSocket Subscriptions\n\n### Real-time Data\n\nUse `useWS` to subscribe to public or private topics.\n\n```tsx\nimport { useWS } from \"@orderly.network/hooks\";\n\nexport const TradeStream = () => {\n  const ws = useWS();\n\n  useEffect(() => {\n    const unsubscribe = ws.subscribe(\n      {\n        id: \"id1\",\n        event: \"subscribe\",\n        topic: \"PERP_ETH_USDC@trade\",\n        ts: Date.now()\n      },\n      {\n        onMessage: (data) => console.log(\"Trade:\", data)\n      }\n    );\n    return () => unsubscribe?.();\n  }, []);\n\n  return null;\n};\n```\n\n### Connection Status\n\nMonitor the WebSocket connection status:\n\n```ts\nimport { useWsStatus, WsNetworkStatus } from \"@orderly.network/hooks\";\n\nconst status = useWsStatus();\n\nif (status === WsNetworkStatus.Connected) {\n  // Ready for real-time updates\n}\n```\n\n## Trading Logic\n\n### Take Profit / Stop Loss (TP/SL)\n\nManage TP/SL orders using `useTPSLOrder`.\n\n```ts\nimport { useTPSLOrder } from \"@orderly.network/hooks\";\n\nconst [order, { setValue, submit, validate }] = useTPSLOrder({\n  symbol: \"PERP_BTC_USDC\",\n  average_open_price: 60000,\n  position_qty: 0.1\n});\n\n// Set TP by PnL\nsetValue(\"tp_pnl\", 100);\n\n// Submit order\nawait submit();\n```\n\n### Order Book Stream\n\nStream order book depth for a symbol.\n\n```ts\nimport { useOrderbookStream } from \"@orderly.network/hooks\";\n\nconst [data, { onDepthChange }] = useOrderbookStream(\"PERP_ETH_USDC\", undefined, { level: 7 });\n\nconsole.log(data.asks, data.bids);\n```\n\n## Asset Management\n\n### Deposits\n\nHandle deposit logic, balance fetching, and fee calculation.\n\n```tsx\nimport { useDeposit } from \"@orderly.network/hooks\";\n\nconst { balance, deposit, setQuantity, depositFee } = useDeposit({\n  address: tokenAddress,\n  decimals: 18,\n  srcToken: \"USDC\",\n  srcChainId: 1\n});\n\n// Set amount to calculate fee\nsetQuantity(\"100\");\n\n// Execute deposit\nawait deposit();\n```\n\n### Collateral & Leverage\n\nFetch account collateral metrics and update leverage.\n\n```ts\nimport { useCollateral, useLeverage } from \"@orderly.network/hooks\";\n\nconst { totalCollateral, freeCollateral } = useCollateral({ dp: 2 });\nconst [maxLeverage, { update }] = useLeverage();\n\n// Update max leverage\nawait update({ leverage: 10 });\n```\n\n## Utility Hooks\n\n### Event Emitter\n\nCommunicate between components without prop drilling.\n\n```ts\nimport { useEventEmitter } from \"@orderly.network/hooks\";\n\nconst emitter = useEventEmitter();\n\n// Emit\nemitter.emit(\"custom-event\", payload);\n\n// Listen\nemitter.on(\"custom-event\", (data) => console.log(data));\n```\n\n### Local Storage\n\nSimple state persistence.\n\n```ts\nimport { useLocalStorage } from \"@orderly.network/hooks\";\n\nconst [value, setValue] = useLocalStorage(\"key\", \"default\");\n```",
      "keywords": [
        "WebSocket",
        "useWS",
        "TP/SL",
        "useTPSLOrder",
        "useDeposit",
        "useCollateral",
        "useLeverage",
        "Utility Hooks"
      ]
    },
    {
      "id": "sdk-10",
      "title": "SDK Migration Guide (v1 to v2)",
      "category": "SDK",
      "content": "Migrating to SDK v2 involves updating package names, adjusting provider configurations, and moving to new component structures. This guide outlines the key changes.\n\n## Deprecated Packages\n\nThe following packages are deprecated and should be replaced:\n\n| Old Package | New Package(s) |\n| :--- | :--- |\n| `@orderly.network/react` | `@orderly.network/ui-scaffold`, `@orderly.network/trading` |\n| `@orderly.network/web3-onboard` | `@orderly.network/wallet-connector` |\n| `@orderly.network/referral` | `@orderly.network/affiliate` |\n\n## New Packages\n\nKey new packages introduced in v2 include:\n- **Base/UI:** `@orderly.network/ui`, `@orderly.network/ui-scaffold`, `@orderly.network/react-app`\n- **Pages:** `@orderly.network/trading`, `@orderly.network/portfolio`, `@orderly.network/markets`\n- **Widgets:** `@orderly.network/ui-order-entry`, `@orderly.network/ui-positions`, `@orderly.network/ui-transfer`\n- **Wallet:** `@orderly.network/wallet-connector`, `@orderly.network/default-evm-adapter`\n\n## Styles Import\n\nReplace the old styles import with the new UI package styles:\n\n```ts\n// Old\nimport \"@orderly.network/react/dist/styles.css\";\n\n// New\nimport \"@orderly.network/ui/dist/styles.css\";\n```\n\n## Layout Migration\n\nThe `Layout` component from `@orderly.network/react` is replaced by `Scaffold` from `@orderly.network/ui-scaffold`.\n\n```tsx\n// Old\nimport { Layout } from \"@orderly.network/react\";\n\n// New\nimport { Scaffold } from \"@orderly.network/ui-scaffold\";\n\n<Scaffold\n  mainNavProps={{ /* ... */ }}\n  leftSideProps={{ /* ... */ }}\n>\n  {children}\n</Scaffold>\n```\n\n## OrderlyAppProvider Changes\n\nSeveral props have been removed from `OrderlyAppProvider` and moved to specific components:\n\n- **Removed:** `shareOptions`, `referral`, `topBar`, `footerStatusBarProps`.\n- **New Location:** Configure `shareOptions` and `referral` within the `TradingPage` component. Configure navigation props within the `Scaffold` component.\n\n## Referral Migration\n\nUpdate referral integration to use the new package:\n\n```tsx\nimport { Dashboard, ReferralProvider } from \"@orderly.network/affiliate\";\n\n<ReferralProvider\n  becomeAnAffiliateUrl=\"...\"\n  referralLinkUrl=\"...\"\n  overwrite={{ shortBrokerName: \"NAME\" }}\n>\n  <Dashboard.DashboardPage />\n</ReferralProvider>\n```\n\n## Wallet Connection\n\nReplace `@orderly.network/web3-onboard` with `@orderly.network/wallet-connector`.\n\n```tsx\n// Old\nimport { ConnectorProvider } from \"@orderly.network/web3-onboard\";\n\n// New\nimport { WalletConnectorProvider } from \"@orderly.network/wallet-connector\";\n\n<WalletConnectorProvider>\n  <OrderlyAppProvider>{children}</OrderlyAppProvider>\n</WalletConnectorProvider>\n```",
      "keywords": [
        "Migration",
        "v2",
        "Deprecated",
        "Scaffold",
        "Wallet Connector",
        "Referral",
        "Styles",
        "OrderlyAppProvider"
      ]
    },
    {
      "id": "sdk-11",
      "title": "Core SDK and Custom Integrations",
      "category": "SDK",
      "content": "For developers requiring maximum control or integrating with non-standard frameworks, the Core SDK (`@orderly.network/core`) and custom interfaces provide the necessary building blocks.\n\n## Core SDK Configuration\n\nThe Core SDK relies on `ConfigStore` and `OrderlyKeyStore` interfaces to manage state and keys.\n\n### ConfigStore\n\nStore and retrieve configuration values:\n\n```ts\nimport { ConfigStore, ConfigKey } from \"@orderly.network/core\";\n\nclass MyConfigStore implements ConfigStore {\n  set<T>(key: ConfigKey, value: T): void {\n    // Your storage logic\n  }\n  get<T>(key: ConfigKey): T {\n    // Your retrieval logic\n  }\n  // ... other methods\n}\n```\n\n### Custom Stores in Hooks\n\nPass custom stores to `OrderlyConfigProvider`:\n\n```tsx\nimport { OrderlyConfigProvider } from \"@orderly.network/hooks\";\n\n<OrderlyConfigProvider\n  configStore={myConfigStore}\n  keyStore={myKeyStore}\n  brokerId=\"my-broker\"\n  networkId=\"mainnet\"\n>\n  {children}\n</OrderlyConfigProvider>\n```\n\n## Custom Wallet Integration\n\nTo use a third-party wallet library, implement the `WalletAdapter` interface and provide it via React Context.\n\n```tsx\nimport { WalletConnectorContext } from \"@orderly.network/hooks\";\n\nexport const CustomWalletProvider = ({ children }) => {\n  return (\n    <WalletConnectorContext.Provider\n      value={{\n        connect: async () => { /* ... */ },\n        disconnect: async () => { /* ... */ },\n        chains: [],\n        connectedChain: null,\n        wallet: null,\n        // ... implement all required fields\n      }}\n    >\n      {children}\n    </WalletConnectorContext.Provider>\n  );\n};\n```\n\n## Advanced Configuration\n\n### Custom Fetcher\n\nOverride the default network request logic:\n\n```ts\n<OrderlyConfigProvider\n  fetcher={async (url, init) => {\n    console.log(\"Requesting:\", url);\n    return fetch(url, init);\n  }}\n>\n```\n\n### Chain Filtering\n\nRestrict available chains:\n\n```ts\n<OrderlyConfigProvider\n  chainFilter={['arbitrum', 'optimism']}\n>\n```\n\n## Contract Bindings\n\n### Java (Web3j)\n\nGenerate bindings for the Vault contract:\n\n```bash\nweb3j generate solidity -a ./Vault.json -o ./out -p com.orderly.vault\n```\n\n### TypeScript (TypeChain)\n\nGenerate Ethers v6 bindings:\n\n```bash\ntypechain --target=ethers-v6 ./Vault.json --out-dir ./src/types\n```\n\n## Authentication\n\nIf integrating directly with the API (without Hooks), you must manually construct authentication headers:\n\n- `orderly-timestamp`: Current timestamp in ms.\n- `orderly-account-id`: Your Orderly Account ID.\n- `orderly-key`: Your Public Orderly Key.\n- `orderly-signature`: Ed25519 signature of `{timestamp}{method}{path}{body}`.",
      "keywords": [
        "Core SDK",
        "Custom Wallet",
        "ConfigStore",
        "WalletAdapter",
        "Contract Bindings",
        "Web3j",
        "TypeChain",
        "Authentication"
      ]
    },
    {
      "id": "sdk-12",
      "title": "Handling Events on the Orderly Input Component",
      "category": "SDK",
      "content": "The Orderly Input component provides comprehensive support for standard React events, allowing you to handle user interactions seamlessly. It inherits event handler types from React's `HTMLInputElement` definitions, ensuring type safety and familiarity.\n\n### Keyboard Events\n\nHandle keyboard interactions using `onKeyDown`, `onKeyUp`, and their capture-phase variants. Note that `onKeyPress` is deprecated.\n\n```tsx\n<Input\n  onKeyDown={(e) => {\n    if (e.key === \"Enter\") {\n      // Submit order or confirm value\n    }\n  }}\n  onKeyUp={(e) => {\n    // Validate value after key release\n  }}\n/>\n```\n\n### Mouse and Pointer Events\n\nFor unified mouse, touch, and stylus support, use pointer events. Standard mouse events are also available.\n\n```tsx\n<Input\n  onPointerDown={(e) => {\n    // Handle touch/mouse/stylus press\n  }}\n  onMouseDown={(e) => {\n    // Start drag/select behavior\n  }}\n/>\n```\n\n### Clipboard and Drag-and-Drop\n\nIntercept clipboard operations or implement drag-and-drop behavior directly on the input.\n\n```tsx\n<Input\n  onPasteCapture={(e) => {\n    // Sanitize pasted content early\n  }}\n  onDrop={(e) => {\n    // Handle dropped files or data\n  }}\n/>\n```\n\n### Capture vs. Bubble Phase\n\nMany events, such as `onKeyDown`, `onClick`, and `onPaste`, have corresponding `Capture` variants (e.g., `onKeyDownCapture`). Capture handlers run before bubble handlers, allowing you to intercept events earlier in the propagation cycle.",
      "keywords": [
        "Input component",
        "React events",
        "keyboard events",
        "pointer events",
        "drag and drop",
        "clipboard",
        "event handlers"
      ]
    },
    {
      "id": "sdk-13",
      "title": "Configuring the Orderly Input Component",
      "category": "SDK",
      "content": "The Orderly Input component offers various props to customize its appearance, behavior, and validation. You can control visual styles, add prefixes/suffixes, and enforce input patterns.\n\n### Visual Styling\n\nControl the variant and size of the input to match your design system.\n\n```tsx\n<Input variant=\"outlined\" size=\"small\" />\n```\n\n### Prefix and Suffix\n\nAdd icons, currency labels, or other elements inside the input field using `prefix` and `suffix`.\n\n```tsx\n<Input\n  prefix={<span>USD</span>}\n  suffix={<span>USDC</span>}\n  placeholder=\"Amount\"\n/>\n```\n\n### Numeric Formatting\n\nEnable thousands separators for better readability of numeric inputs.\n\n```tsx\n<Input thousandSeparator />\n```\n\n### Validation and Attributes\n\nPass standard HTML attributes to enforce validation rules.\n\n```tsx\n<Input\n  placeholder=\"Enter email\"\n  pattern=\"^[^@\\\\s]+@[^@\\\\s]+\\\\.[^@\\\\s]+$\"\n/>\n```\n\n### Tooltip Customization\n\nApply custom CSS classes to the tooltip associated with the input.\n\n```tsx\n<Input tooltipClassName=\"my-custom-tooltip\" />\n```",
      "keywords": [
        "Input props",
        "styling",
        "prefix",
        "suffix",
        "validation",
        "numeric formatting",
        "tooltip"
      ]
    },
    {
      "id": "sdk-14",
      "title": "Order Management with React Hooks",
      "category": "SDK",
      "content": "The `@orderly.network/hooks` package provides powerful hooks for managing order lifecycles, streaming live order data, and executing order actions like cancellation and updates.\n\n### Streaming Orders\n\nUse `useOrderStream` to subscribe to a live feed of your orders. You can filter the stream by status, symbol, or side.\n\n```tsx\nconst [orders, actions] = useOrderStream(\n  {\n    symbol: \"PERP_ETH_USDC\",\n    status: \"OPEN\",\n  },\n  { keeplive: true }\n);\n\n// actions includes: isLoading, total, loadMore, refresh, cancelOrder, etc.\n```\n\n### Canceling Orders\n\nThe hook returns specific functions to cancel standard orders, algo orders, and TP/SL orders.\n\n```tsx\n// Cancel a single order\nawait actions.cancelOrder(orderId, \"PERP_ETH_USDC\");\n\n// Cancel all open orders\nawait actions.cancelAllOrders();\n\n// Cancel all TP/SL orders\nawait actions.cancelAllTPSLOrders();\n```\n\n### Updating Orders\n\nModify existing orders or algo orders directly through the stream actions.\n\n```tsx\n// Update a standard order\nawait actions.updateOrder(orderId, { order_quantity: 2 });\n\n// Update an algo order\nawait actions.updateAlgoOrder(orderId, { trigger_price: 3000 });\n```\n\n### Order Entry Workflow\n\nCombine `useOrderEntry` with `useOrderStream` to create a complete trading interface. `useOrderEntry` handles form validation and submission preparation.\n\n```tsx\nconst { formattedOrder, onSubmit, helper } = useOrderEntry(\n  {\n    symbol: \"PERP_ETH_USDC\",\n    side: OrderSide.BUY,\n    order_type: OrderType.LIMIT,\n  },\n  { watchOrderbook: true }\n);\n```",
      "keywords": [
        "useOrderStream",
        "cancel order",
        "update order",
        "algo orders",
        "TPSL",
        "order entry",
        "React hooks"
      ]
    },
    {
      "id": "sdk-15",
      "title": "Fetching and Streaming Market Data",
      "category": "SDK",
      "content": "Access real-time market data, including order books, tickers, and funding rates, using the Orderly React hooks.\n\n### Order Book Stream\n\nSubscribe to a live order book for a specific symbol. You can configure the depth and padding behavior.\n\n```tsx\nconst { asks, bids, markPrice } = useOrderbookStream(\n  \"PERP_ETH_USDC\",\n  undefined,\n  { level: 20, padding: true }\n);\n```\n\n### Ticker Stream\n\nGet live market information and 24-hour price changes for a symbol.\n\n```tsx\nconst marketInfo = useTickerStream(\"PERP_ETH_USDC\");\n// marketInfo contains 24h_change, change, and other MarketInfo fields\n```\n\n### Funding Rates\n\nFetch current and estimated funding rates for a specific market.\n\n```tsx\nconst fundingInfo = useFundingRate(\"PERP_ETH_USDC\");\n// Returns: est_funding_rate, last_funding_rate, next_funding_time, etc.\n```\n\n### Markets Data\n\nRetrieve a list of markets with helpers for managing favorites and recent history.\n\n```tsx\nconst [tickers, helpers] = useMarkets(\"ALL\");\n\n// helpers includes:\n// - addToHistory(symbol)\n// - pinToTop(symbol)\n// - favorites, favoriteTabs\n```",
      "keywords": [
        "orderbook",
        "ticker",
        "funding rate",
        "market data",
        "streaming",
        "useMarkets",
        "real-time"
      ]
    },
    {
      "id": "sdk-16",
      "title": "Account and Collateral Calculations",
      "category": "SDK",
      "content": "The `@orderly.network/perp` SDK provides utility functions to perform complex account calculations, such as margin requirements, collateral values, and leverage estimations.\n\n### Total Value and Collateral\n\nCalculate the total value of a user's assets, including non-USDC holdings, and the total collateral available.\n\n```ts\nimport { totalValue, totalCollateral } from \"@orderly.network/perp\";\n\nconst totalAssetValue = totalValue({\n  USDCHolding: 1000,\n  nonUSDCHolding: [{ holding: 1, markPrice: 2000, discount: 0.1 }],\n  totalUnsettlementPnL: 50,\n});\n\nconst collateral = totalCollateral(inputs);\n```\n\n### Margin Requirements\n\nCompute Initial Margin Rate (IMR) and Maintenance Margin Ratio (MMR) for risk management.\n\n```ts\nimport { IMR, MMR } from \"@orderly.network/perp\";\n\nconst imr = IMR({\n  IMRFactor: 0.0001,\n  baseIMR: 0.1,\n  positionNotional: 10000,\n});\n\nconst mmr = MMR({\n  IMRFactor: 0.0001,\n  baseMMR: 0.05,\n  positionNotional: 10000,\n});\n```\n\n### Leverage and Liquidation\n\nEstimate the leverage impact of a new order or calculate the potential liquidation price.\n\n```ts\nimport { orderUtils } from \"@orderly.network/perp\";\n\n// Estimate leverage after placing an order\nconst estimatedLeverage = orderUtils.estLeverage({\n  newOrder: { price: 3000, qty: 1, symbol: \"PERP_ETH_USDC\" },\n  positions: [],\n  totalCollateral: 1000,\n});\n\n// Estimate liquidation price\nconst liqPrice = orderUtils.estLiqPrice({\n  markPrice: 3000,\n  newOrder: { price: 3000, qty: 1, symbol: \"PERP_ETH_USDC\" },\n  positions: [],\n  totalCollateral: 1000,\n  // ... other inputs\n});\n```",
      "keywords": [
        "margin",
        "collateral",
        "leverage",
        "liquidation",
        "IMR",
        "MMR",
        "account calculations"
      ]
    },
    {
      "id": "sdk-17",
      "title": "Building UIs with Orderly React Components",
      "category": "SDK",
      "content": "The `@orderly.network/react` module offers a suite of pre-built components and layout primitives to accelerate the development of trading interfaces.\n\n### Layout Components\n\nStructure your application using the `Layout` composite component.\n\n```tsx\n<Layout>\n  <Layout.Header>Header</Layout.Header>\n  <Layout.Content>Main Content</Layout.Content>\n  <Layout.Sider>Sidebar</Layout.Sider>\n</Layout>\n```\n\n### Trading Page\n\nRender a full-featured trading page with desktop and mobile variants.\n\n```tsx\n<TradingPage.desktop />\n{/* or */}\n<TradingPage.mobile />\n```\n\n### Modals and Dialogs\n\nUse the `modal` API or dialog components for overlays.\n\n```tsx\nimport { modal, Dialog, DialogContent } from \"@orderly.network/react\";\n\n// Programmatic modal\nmodal.alert({ title: \"Info\", description: \"Order submitted\" });\n\n// Declarative Dialog\n<Dialog>\n  <DialogTrigger>Open</DialogTrigger>\n  <DialogContent closable>Content</DialogContent>\n</Dialog>\n```\n\n### Deposit and Withdraw\n\nIntegrate deposit and withdrawal flows with ready-to-use components.\n\n```tsx\n<DepositAndWithdrawWithDialog />\n{/* or specific components */}\n<Deposit />\n<Withdraw />\n```\n\n### Context Providers\n\nWrap your app with necessary providers to enable state management.\n\n```tsx\n<OrderlyAppProvider config={config}>\n  <AssetsProvider>\n    <SymbolProvider>\n      <TradingPageProvider>{/* App */}</TradingPageProvider>\n    </SymbolProvider>\n  </AssetsProvider>\n</OrderlyAppProvider>\n```",
      "keywords": [
        "React components",
        "Layout",
        "TradingPage",
        "Modal",
        "Dialog",
        "Deposit",
        "Providers"
      ]
    },
    {
      "id": "sdk-18",
      "title": "Orderly React SDK Components Overview",
      "category": "SDK",
      "content": "The Orderly React SDK provides a comprehensive suite of pre-built UI components designed to accelerate the development of trading interfaces. These components handle complex state management, data fetching, and user interactions out of the box.\n\n### Initialization\nTo use Orderly components, you must wrap your application with the `OrderlyAppProvider`. This provider initializes the global SDK state, configuration, and context required by all child components.\n\n```tsx\nimport { OrderlyAppProvider } from \"@orderly.network/react\";\n\nfunction App() {\n  return (\n    <OrderlyAppProvider\n      brokerId={YOUR_BROKER_ID}\n      // Optional configurations\n      includeTestnet={false}\n      referral={{ code: \"REF_CODE\" }}\n      toastLimitCount={5}\n    >\n      <YourTradingApp />\n    </OrderlyAppProvider>\n  );\n}\n```\n\n### Core Trading Components\n\n#### 1. Markets List\nRender a list of trading pairs using `Markets` or `MarketsFull`.\n\n```tsx\nimport { Markets } from \"@orderly.network/react\";\n\n<Markets listHeight={480} />\n```\n\n#### 2. Order Book\nDisplay real-time order book depth.\n\n```tsx\nimport { OrderBook } from \"@orderly.network/react\";\n\n<OrderBook\n  asks={askData}\n  bids={bidData}\n  lastPrice={lastPrice}\n  markPrice={markPrice}\n  base=\"BTC\"\n  quote=\"USDT\"\n/>\n```\n\n#### 3. Order Entry (Trade Ticket)\nAllow users to place market, limit, and stop orders.\n\n```tsx\nimport { OrderEntry } from \"@orderly.network/react\";\n\n<OrderEntry\n  onSubmit={async (data) => {\n    // Handle order submission API call\n    await placeOrder(data);\n  }}\n  onDeposit={() => {\n    // Trigger deposit modal\n  }}\n/>\n```\n\n#### 4. Positions & Orders\nView current positions and order history.\n\n```tsx\nimport { PositionsView, OrdersView } from \"@orderly.network/react\";\n\n<PositionsView\n  dataSource={positions}\n  aggregated={aggregatedData}\n  onMarketClose={(pos) => closePosition(pos)}\n/>\n\n<OrdersView dataSource={orders} />\n```\n\n### Utility Components\n\n- **Sheet/Dialog**: Build modals and drawers using `Sheet`, `SheetContent`, `SheetTrigger`.\n- **Tooltip**: Add context with `Tooltip`, `TooltipTrigger`, `TooltipContent`.\n- **Table**: Render data tables with `Table<RecordType>`.\n- **Input**: Standardized input fields supporting refs.\n\n### Common Patterns\n\n#### Using Refs for Imperative Control\nMany components support refs for imperative control, such as scrolling or focusing.\n\n```tsx\nimport { useRef } from \"react\";\nimport { ListView, Input } from \"@orderly.network/react\";\n\nconst listRef = useRef<{ scroll: (d: { x: number; y: number }) => void }>(null);\nconst inputRef = useRef<HTMLInputElement>(null);\n\n// Scroll list programmatically\nlistRef.current?.scroll({ x: 0, y: 200 });\n\n// Focus input\ninputRef.current?.focus();\n```",
      "keywords": [
        "React",
        "Components",
        "OrderlyAppProvider",
        "OrderBook",
        "OrderEntry",
        "Markets",
        "PositionsView"
      ]
    },
    {
      "id": "sdk-19",
      "title": "State Management and Hooks",
      "category": "SDK",
      "content": "The Orderly SDK offers several hooks to manage application state, fetch data, and interact with the Orderly Network efficiently.\n\n### Account State\nManage user connection, authentication, and trading status.\n\n```ts\nimport { useAccount } from \"@orderly.network/hooks\";\n\nfunction MyComponent() {\n  const { account, state } = useAccount();\n  \n  // Access account details\n  console.log(account.address, account.accountId);\n  \n  // Check connection status\n  if (state === AccountStatusEnum.NotSignedIn) {\n    // Prompt user to sign in\n  }\n}\n```\n\n### Market Data\nFetch market information, tickers, and order book data.\n\n```ts\nimport { useMarkets, useMarketsInfo } from \"@orderly.network/hooks\";\n\nfunction MarketList() {\n  // Fetch all markets\n  const { data: markets, isLoading } = useMarkets(MarketsType.ALL);\n  \n  // Fetch specific market info\n  const { data: marketInfo } = useMarketsInfo(\"PERP_BTC_USDT\");\n}\n```\n\n### WebSocket Status\nMonitor the real-time connection health.\n\n```ts\nimport { useWsStatus, WsNetworkStatus } from \"@orderly.network/hooks\";\n\nfunction ConnectionIndicator() {\n  const status = useWsStatus();\n  \n  if (status === WsNetworkStatus.Connected) {\n    return <span>Connected</span>;\n  }\n  return <span>Reconnecting...</span>;\n}\n```\n\n### Modal and UI State\nControl modals and UI overlays programmatically.\n\n```ts\nimport { useModal } from \"@orderly.network/react\";\n\nfunction DepositButton() {\n  const modal = useModal();\n  \n  const handleOpen = () => {\n    modal.show({ title: \"Deposit\" });\n  };\n  \n  return <button onClick={handleOpen}>Deposit</button>;\n}\n```\n\n### Custom Hooks Integration\nYou can combine Orderly hooks with your own logic to create complex features.\n\n```ts\nimport { useAccount, useMarketsInfo } from \"@orderly.network/hooks\";\n\nfunction useTradingPermissions(symbol: string) {\n  const { state } = useAccount();\n  const { data: marketInfo } = useMarketsInfo(symbol);\n  \n  const isTradingEnabled = state === AccountStatusEnum.EnableTrading;\n  const isMarketOpen = marketInfo?.status === \"TRADING\";\n  \n  return isTradingEnabled && isMarketOpen;\n}\n```",
      "keywords": [
        "Hooks",
        "State Management",
        "useAccount",
        "useMarkets",
        "WebSocket",
        "useModal",
        "React Hooks"
      ]
    },
    {
      "id": "sdk-20",
      "title": "TypeScript Configuration and Types",
      "category": "SDK",
      "content": "The Orderly SDK is built with TypeScript, providing strong type safety for orders, positions, and chain configurations. Leveraging these types helps prevent runtime errors and improves developer experience.\n\n### Core Types\nImport essential types from `@orderly.network/types`.\n\n```ts\nimport type {\n  OrderEntity,\n  Position,\n  API,\n  OrderSide,\n  OrderStatus,\n  OrderType\n} from \"@orderly.network/types\";\n\n// Define a function with typed order data\nfunction processOrder(order: OrderEntity) {\n  if (order.status === OrderStatus.FILLED) {\n    console.log(`Order ${order.orderId} filled at ${order.average_price}`);\n  }\n}\n```\n\n### Chain Configuration\nConfigure supported blockchains using the `ChainConfig` type.\n\n```ts\nimport { Arbitrum, Polygon, Optimism } from \"@orderly.network/types\";\n\nconst supportedChains = [Arbitrum, Polygon, Optimism];\n\nfunction getChainRpc(chainId: number) {\n  const chain = supportedChains.find(c => c.id === chainId);\n  return chain?.chainInfo.rpcUrls[0];\n}\n```\n\n### Enums\nUse enums for consistent state representation.\n\n```ts\nimport { AccountStatusEnum, WithdrawStatus, AlgoOrderType } from \"@orderly.network/types\";\n\nlet status: AccountStatusEnum;\n\nif (!walletConnected) {\n  status = AccountStatusEnum.NotConnected;\n} else if (!isSigned) {\n  status = AccountStatusEnum.NotSignedIn;\n} else {\n  status = AccountStatusEnum.EnableTrading;\n}\n```\n\n### API and WebSocket Types\nType your API responses and WebSocket messages.\n\n```ts\nimport type { API, WSMessage } from \"@orderly.network/types\";\n\nasync function fetchAccountInfo(): Promise<API.AccountInfo> {\n  const res = await fetch(\"/v1/client/info\");\n  return res.json();\n}\n\nfunction handleWsMessage(msg: WSMessage.Order) {\n  console.log(`Order update: ${msg.orderId}`);\n}\n```",
      "keywords": [
        "TypeScript",
        "Types",
        "Chain Configuration",
        "Enums",
        "API Types",
        "OrderEntity",
        "Interfaces"
      ]
    },
    {
      "id": "sdk-21",
      "title": "TradingView Chart Integration",
      "category": "SDK",
      "content": "The `@orderly.network/trading-view` package provides a React wrapper around the TradingView Charting Library, tailored for Orderly Network markets.\n\n### Basic Usage\nImport the `TradingView` component and pass the required props.\n\n```tsx\nimport { TradingView } from \"@orderly.network/trading-view\";\n\nfunction Chart() {\n  return (\n    <TradingView\n      symbol=\"PERP_BTC_USDT\"\n      interval=\"15\"\n      libraryPath=\"/charting_library/\"\n      containerId=\"tv_chart_container\"\n    />\n  );\n}\n```\n\n### Configuration Props\n\n- **symbol**: The trading pair symbol (e.g., `PERP_ETH_USDT`).\n- **interval**: Default chart timeframe (e.g., `\"1\"`, `\"15\"`, `\"D\"`).\n- **libraryPath**: Path to the TradingView library files.\n- **mode**: Chart display mode (`ChartMode.BASIC`, `ChartMode.ADVANCED`, `ChartMode.MOBILE`).\n- **fullscreen**: Boolean to enable fullscreen mode.\n- **overrides**: Object to override chart styles (colors, fonts).\n- **studiesOverrides**: Object to override indicator settings.\n\n### Customization\n\n#### Styling\nCustomize the chart appearance using the `overrides` prop.\n\n```tsx\n<TradingView\n  symbol=\"PERP_SOL_USDT\"\n  overrides={{\n    \"paneProperties.background\": \"#131722\",\n    \"paneProperties.vertGridProperties.color\": \"#363c4e\",\n    \"scalesProperties.textColor\": \"#d1d4dc\"\n  }}\n/>\n```\n\n#### Mobile Mode\nOptimize the chart for mobile devices.\n\n```tsx\nimport { ChartMode } from \"@orderly.network/trading-view\";\n\n<TradingView\n  symbol=\"PERP_BTC_USDT\"\n  mode={ChartMode.MOBILE}\n/>\n```\n\n### Persistence\nThe SDK automatically persists chart settings (interval, line type, display controls) to `localStorage` using keys defined in `TradingViewSDKLocalstorageKey`.",
      "keywords": [
        "TradingView",
        "Charts",
        "Charting Library",
        "Visualization",
        "Mobile",
        "Customization",
        "Overrides"
      ]
    },
    {
      "id": "sdk-22",
      "title": "Utilities and Helper Functions",
      "category": "SDK",
      "content": "The SDK includes various utility functions to handle common tasks such as number formatting, class name generation, and modal management.\n\n### Number Formatting\nUse `parseNumber` to format prices, percentages, and human-readable numbers.\n\n```ts\nimport { parseNumber } from \"@orderly.network/react\";\n\nconst price = parseNumber(1234.5678, {\n  rule: \"price\",\n  precision: 2\n}); // \"1,234.57\"\n\nconst percentage = parseNumber(0.0523, {\n  rule: \"percentages\",\n  precision: 2\n}); // \"5.23%\"\n\nconst humanReadable = parseNumber(1500000, {\n  rule: \"human\"\n}); // \"1.5M\"\n```\n\n### Class Name Utilities\nConditionally combine class names using the `cn` utility (similar to `clsx` or `classnames`).\n\n```ts\nimport { cn } from \"@orderly.network/react\";\n\nconst buttonClass = cn(\n  \"px-4 py-2 rounded\",\n  isActive && \"bg-blue-500 text-white\",\n  isDisabled && \"opacity-50 cursor-not-allowed\"\n);\n```\n\n### Toast Notifications\nTrigger toast notifications for user feedback.\n\n```ts\nimport { toast } from \"@orderly.network/react\";\n\nfunction handleSuccess() {\n  toast(\"Order placed successfully\", {\n    position: \"top-right\",\n    duration: 3000,\n    icon: \"✅\"\n  });\n}\n```\n\n### Modal Helpers\nWrap components to make them modal-compatible.\n\n```tsx\nimport { create } from \"@orderly.network/react\";\n\nfunction MyContent({ title }: { title: string }) {\n  return <div>{title}</div>;\n}\n\nconst MyModal = create(MyContent);\n\n// Usage\n<MyModal id=\"unique-modal\" title=\"Hello\" defaultVisible={true} />\n```",
      "keywords": [
        "Utilities",
        "Formatting",
        "parseNumber",
        "Toast",
        "Modal",
        "ClassName",
        "Helpers"
      ]
    },
    {
      "id": "sdk-23",
      "title": "Core SDK Account Management",
      "category": "SDK",
      "content": "The `@orderly.network/core` package provides the fundamental logic for account creation, authentication, and interaction with the Orderly Network.\n\n### Account Initialization\nCreate an `Account` instance to manage the user session.\n\n```ts\nimport { Account } from \"@orderly.network/core\";\n\nconst account = new Account();\n\n// Login with a wallet address\naccount.login(\"0x123...\");\n\n// Access account properties\nconsole.log(account.address);\nconsole.log(account.accountId);\nconsole.log(account.chainId);\n```\n\n### Account Lifecycle\n\n#### Creating an Account\nIf the user does not have an Orderly account, trigger the creation flow.\n\n```ts\nasync function registerUser() {\n  try {\n    await account.createAccount();\n    console.log(\"Account created successfully\");\n  } catch (error) {\n    console.error(\"Registration failed\", error);\n  }\n}\n```\n\n#### Managing Orderly Keys\nOrderly Keys are required for signing orders off-chain.\n\n```ts\nasync function setupOrderlyKey() {\n  try {\n    await account.createOrderlyKey();\n    console.log(\"Orderly Key registered\");\n  } catch (error) {\n    console.error(\"Key registration failed\", error);\n  }\n}\n```\n\n### Event Handling\nListen to account-level events to update your UI.\n\n```ts\naccount.on(\"ACCOUNT_INFO_UPDATE\", (info) => {\n  console.log(\"Account info updated\", info);\n});\n\naccount.on(\"ASSET_UPDATE\", (assets) => {\n  console.log(\"Balances updated\", assets);\n});\n```\n\n### Wallet Integration\nThe SDK uses adapters to interact with different wallet providers.\n\n```ts\nimport { EtherAdapter } from \"@orderly.network/core\";\n\nconst adapter = new EtherAdapter({\n  // Wallet adapter options\n  provider: window.ethereum\n});\n\n// Get address\nconsole.log(adapter.addresses);\n\n// Switch Chain\nadapter.chainId = 42161; // Arbitrum\n```",
      "keywords": [
        "Account",
        "Authentication",
        "Core SDK",
        "Wallet",
        "Orderly Key",
        "Lifecycle",
        "EtherAdapter"
      ]
    },
    {
      "id": "sdk-24",
      "title": "Configuring the TradingView Component",
      "category": "SDK",
      "content": "The Orderly TradingView component offers extensive customization options for chart appearance, toolbar behavior, and event handling. This guide covers how to configure these props to integrate the chart seamlessly into your application.\n\n### Theme and Toolbar Settings\n\nYou can control the visual theme and the default state of the top toolbar using specific props.\n\n*   **`theme?: string`**: Sets the visual theme of the chart (e.g., 'light', 'dark').\n*   **`topToolbarOpenSetting?: boolean`**: If `true`, the settings panel in the top toolbar opens by default.\n*   **`topToolbarOpenIndicators?: boolean`**: If `true`, the indicators panel opens by default.\n*   **`topToolbarLineType?: string`**: Configures the line type setting exposed via the top toolbar.\n\n### Event Handling and Callbacks\n\nThe component provides hooks to interact with user actions and system events.\n\n*   **`onToast?: any`**: A callback hook used to capture toast/notification events from the TradingView integration. This allows you to handle or display notifications within your own UI framework.\n*   **`positionControlCallback?: Function`**: Triggered when a user performs position control actions directly from the TradingView UI. Use this to sync position changes with your application state.\n\n### Example Implementation\n\nBelow is an example of how to implement the TradingView component with custom theme, toolbar settings, and callbacks.\n\n```tsx\nimport { TradingView } from '@orderly.network/trading-view';\n\nconst MyChartComponent = () => {\n  const handlePositionControl = (data) => {\n    console.log('Position control action:', data);\n    // Update local state or send to backend\n  };\n\n  const handleToast = (event) => {\n    console.log('Toast event:', event);\n    // Custom toast notification logic\n  };\n\n  return (\n    <TradingView\n      theme=\"dark\"\n      topToolbarOpenSetting={false}\n      topToolbarOpenIndicators={true}\n      topToolbarLineType=\"area\"\n      onToast={handleToast}\n      positionControlCallback={handlePositionControl}\n    />\n  );\n};\n```\n\n### Defined In\n*   `packages/trading-view/src/tradingView/tradingView.tsx`",
      "keywords": [
        "TradingView",
        "component",
        "theme",
        "toolbar",
        "callbacks",
        "props",
        "configuration"
      ]
    },
    {
      "id": "sdk-25",
      "title": "Understanding SDK Types: Accounts and Orders",
      "category": "SDK",
      "content": "The Orderly SDK provides robust TypeScript definitions to ensure type safety across your application. This section details the essential types for Account Information and Order creation.\n\n### Account Info (`API.AccountInfo`)\n\nThe `AccountInfo` interface contains critical details about the user's account, including fee rates, leverage limits, and risk parameters.\n\n**Key Fields:**\n*   `account_id: string`\n*   `email: string`\n*   `taker_fee_rate` / `maker_fee_rate: number`\n*   `max_leverage: number`\n*   `imr_factor: { [key: string]: number }`: A map of Initial Margin Requirement factors keyed by symbol or risk bucket.\n*   `max_notional: { [key: string]: number }`: A map of maximum notional values keyed by symbol or risk bucket.\n\n### Order Entity (`OrderEntity`)\n\nThe `OrderEntity` interface is used to construct order payloads. It distinguishes between required fields for basic orders and optional fields for advanced functionality.\n\n**Required Fields:**\n*   `symbol: string`\n*   `order_type: OrderType`\n*   `side: OrderSide`\n\n**Optional Fields:**\n*   `reduce_only?: boolean`: Set to `true` to flag the order as reduce-only.\n*   `broker_id?: string`: Attach a broker identifier.\n*   `order_tag?: string`: Attach a custom tag for tracking.\n*   `algo_type?: AlgoOrderRootType`: Identify the order as an algorithmic order.\n*   `trigger_price?: string | number`: Required for stop orders.\n\n### Example: Creating an Order\n\n```typescript\nimport { OrderEntity } from '@orderly.network/types';\n\nconst createOrderPayload = (): OrderEntity => {\n  return {\n    symbol: \"BTC-PERP\",\n    order_type: \"LIMIT\",\n    side: \"BUY\",\n    order_price: \"50000\",\n    order_quantity: \"0.1\",\n    reduce_only: false,\n    broker_id: \"my-broker-id\",\n    order_tag: \"strategy-1\"\n  };\n};\n```\n\n### Defined In\n*   `packages/types/src/types/api.ts` (AccountInfo)\n*   `packages/types/src/order.ts` (OrderEntity)",
      "keywords": [
        "TypeScript",
        "types",
        "AccountInfo",
        "OrderEntity",
        "imr_factor",
        "reduce_only",
        "broker_id"
      ]
    },
    {
      "id": "sdk-26",
      "title": "Working with Algo Orders and Positions",
      "category": "SDK",
      "content": "Managing algorithmic orders and extended position data requires understanding specific SDK types and WebSocket message structures. This guide explains how to interpret and utilize these data structures.\n\n### Algo Order Types\n\n**`API.AlgoOrder`**\nRepresents the state of an algorithmic order. It includes fields for tracking the order hierarchy and execution status.\n*   **Hierarchy:** `algo_order_id`, `parent_algo_order_id`, `root_algo_order_id`.\n*   **Status:** `algo_status`, `is_triggered`, `is_activated`.\n*   **Execution:** `trigger_price`, `total_executed_quantity`, `total_fee`.\n\n**`WSMessage.AlgoOrder`**\nThis WebSocket message type provides real-time updates for algo orders.\n*   **Execution Data:** Access `executedPrice`, `executedQuantity`, `averageExecutedPrice`, and `fee` to track fills.\n*   **Liquidity:** Check the `maker: boolean` field to determine if a fill was a maker or taker trade.\n*   **Linkage:** Use `rootAlgoOrderId` and `parentAlgoOrderId` to correlate child orders with their roots.\n\n### Position Extensions\n\n**`PositionExt`**\nExtends the base `Position` interface to include additional trading data.\n*   **Take Profit:** Use `tp_trigger_price?: number` to access the configured take-profit trigger price.\n*   **Mark Price:** `mark_price` is available to calculate real-time PnL.\n*   **Liquidation:** `est_liq_price` (nullable) provides the estimated liquidation price.\n\n### Example: Parsing an Algo Order Update\n\n```typescript\nconst handleAlgoOrderMessage = (message: WSMessage.AlgoOrder) => {\n  console.log(`Order ID: ${message.algoOrderId}`);\n  console.log(`Root ID: ${message.rootAlgoOrderId}`);\n  console.log(`Executed Qty: ${message.executedQuantity}`);\n  console.log(`Is Maker: ${message.maker}`);\n\n  if (message.algoStatus === 'FILLED') {\n    console.log('Order filled completely.');\n  }\n};\n```\n\n### Defined In\n*   `packages/types/src/types/api.ts` (AlgoOrder, WSMessage.AlgoOrder, PositionExt)",
      "keywords": [
        "AlgoOrder",
        "WebSocket",
        "PositionExt",
        "TP/SL",
        "algo_type",
        "trigger_price",
        "maker"
      ]
    },
    {
      "id": "sdk-27",
      "title": "Managing Orders and Funds with Hooks",
      "category": "SDK",
      "content": "The `@orderly.network/hook` package provides React hooks to simplify order entry, deposit/withdraw flows, and algo order management. This guide covers the essential hooks for financial operations.\n\n### Order Entry (`useOrderEntry`)\n\nAs of v1.1.2, `useOrderEntry` accepts a single `OrderEntity` object as its parameter.\n\n**Usage:**\n```javascript\nconst { estLiqPrice, estLeverage, metaState } = useOrderEntry({\n  symbol: \"BTC-PERP\",\n  order_type: \"MARKET\",\n  side: \"BUY\",\n  order_quantity: 1\n});\n```\n\n**New Return Values:**\n*   `estLiqPrice`: Estimated liquidation price after opening the position.\n*   `estLeverage`: Leverage change resulting from the order.\n*   `metaState`: Validation results and form status.\n\n### Deposits and Withdrawals\n\n**`useDeposit`**\n*   Simplified API: Call `deposit()` with no parameters.\n*   State Management: Use `setQuantity(quantity: number)` to set the amount before calling `deposit()`.\n*   Fees: Access `depositFee` and `quantity` from the hook return.\n\n**`useWithdraw`**\n*   `availableWithdraw`: A new field indicating how much a user can withdraw immediately without settling PnL (calculated from `unsettledPnL` and `freeCollateral`).\n\n### Algo Order Management\n\nYou can update or cancel existing stop-loss (Algo) orders directly via the hook methods:\n*   `updateAlgoOrder(orderId: string, order: OrderEntity)`: Updates an existing algo order.\n*   `cancelAlgoOrder(orderId: string, symbol?: string)`: Cancels an algo order.\n\n### Example: Updating a Stop Loss\n\n```javascript\nconst { updateAlgoOrder } = useOrderEntry({ /* ... */ });\n\nconst updateStopLoss = async (orderId, newPrice) => {\n  await updateAlgoOrder(orderId, {\n    symbol: \"BTC-PERP\",\n    trigger_price: newPrice,\n    // ... other necessary fields\n  });\n};\n```",
      "keywords": [
        "useOrderEntry",
        "useDeposit",
        "useWithdraw",
        "hooks",
        "algo orders",
        "updateAlgoOrder",
        "cancelAlgoOrder"
      ]
    },
    {
      "id": "sdk-28",
      "title": "Utility Hooks and UI Features",
      "category": "SDK",
      "content": "Beyond core trading logic, the Orderly SDK offers utility hooks for generating shareable assets, managing market data, and handling referral programs.\n\n### PnL Poster Generation (`usePoster`)\n\nGenerate a visual PnL card from a user's position for social sharing.\n\n**Usage:**\n```javascript\nconst { ref, download, copy } = usePoster({\n  backgroundImg: \"/path/image.png\",\n  color: \"rgba(255, 255, 255, 0.98)\",\n  profitColor: \"rgb(0,181,159)\",\n  lossColor: \"rgb(255,103,194)\",\n  data: {\n    message: \"I am the best trader.\",\n    domain: \"broker.com\",\n    position: {\n      symbol: \"BTC-PERP\",\n      side: \"LONG\",\n      leverage: 20,\n      pnl: -1032.23,\n      ROI: -10.25,\n      informations: [\n        { title: \"Open Price\", value: \"59,129.12\" },\n        { title: \"Quantity\", value: \"2\" }\n      ]\n    }\n  }\n});\n\n// Render canvas\nreturn <canvas ref={ref} width={550} height={300} />;\n```\n\n### Order Book Stream (`useOrderBookStream`)\n\nControl how depth levels are handled when data is missing.\n\n**Disable Padding:**\nBy default, the hook pads missing levels with `NaN`. To disable this:\n```javascript\nconst [data] = useOrderBookStream(\"BTC-PERP\", undefined, { \n  level: 10, \n  padding: false \n});\n```\n\n### TP/SL and Referral Hooks\n\n*   **TP/SL Hooks:** Introduced in v1.4.0, these hooks (documented at `/sdks/hooks/orders/use-tp-sl`) allow you to manage Take-Profit and Stop-Loss logic.\n*   **Referral Hooks:** Access `useComission`, `useDaily`, `useRefereeHistory`, and `useRefereeInfo` via `@orderly.network/referral` or the main hooks package.\n\n### UI Customization\n\n*   **Component IDs:** As of v1.5.4, component IDs were added to the Component SDK, allowing for granular CSS targeting and customization.",
      "keywords": [
        "usePoster",
        "useOrderBookStream",
        "referral",
        "TP/SL",
        "padding",
        "canvas",
        "component IDs"
      ]
    },
    {
      "id": "api-29",
      "title": "API Authentication and Orderly Keys",
      "category": "API",
      "content": "Orderly uses a dual-signature system to secure API requests: **EIP-712 Wallet Signatures** for on-chain actions (like withdrawals) and **Orderly Keys (ed25519)** for off-chain trading and private API requests.\n\n### Orderly Key Generation\nThe Orderly keypair (ed25519) is created client-side. The private key (`ORDERLY_SECRET`) is used to sign API requests, while the public key (`orderly-key`) is registered with Orderly.\n\n**Steps to generate and register an Orderly Key:**\n1. Create an ed25519 keypair.\n2. Register the public key with Orderly by submitting it along with an EIP-712 signature from the user's wallet.\n\n**Example (Conceptual):**\n```typescript\n// 1. Generate KeyPair (client-side)\nconst { publicKey, secretKey } = generateKeyPair();\n\n// 2. Register Public Key (requires EIP-712 wallet signature)\nconst registerPayload = {\n  broker_id: \"your_broker_id\",\n  public_key: publicKey,\n  // ... other fields\n};\nconst walletSignature = await signEIP712(registerPayload);\nawait api.post('/v1/register_account', { ...registerPayload, signature: walletSignature });\n```\n\n### Authenticating Private Requests\nOnce registered, private API requests must include the following headers:\n- `orderly-key`: The public Orderly key.\n- `orderly-signature`: The signature of the request payload generated using the private Orderly key (`ORDERLY_SECRET`).\n- `orderly-timestamp`: Current Unix timestamp in milliseconds.\n- `orderly-account-id`: The user's Orderly account ID.\n\n**Note:** The `tag` field is optional when creating an Orderly key, despite some OpenAPI specs marking it as required.\n\n### EIP-712 Wallet Signatures\nCertain actions, specifically **withdrawals**, require an EIP-712 signature signed by the user's wallet private key. This signature is included in the request body, separate from the `orderly-signature` header.\n\n### Common Issues\n- **Code -1607 \"account does not exist\"**: Ensure you are using the correct API base URL for the environment (Mainnet vs. Testnet) where the account was registered.\n  - Mainnet: `https://api-evm.orderly.org`\n  - Testnet: `https://testnet-api-evm.orderly.org`\n- **Code -1601 \"address is invalid\" (Solana)**: When registering a Solana address, you must include `chainType: \"SOL\"` in the payload.",
      "keywords": [
        "authentication",
        "orderly key",
        "EIP-712",
        "API signature",
        "ed25519",
        "broker ID",
        "wallet signature"
      ]
    },
    {
      "id": "api-30",
      "title": "Broker Setup and Admin Operations",
      "category": "Operations",
      "content": "Setting up a broker ID and configuring the admin wallet are essential steps for collecting fees and managing broker-specific settings.\n\n### Broker ID Setup\nTo create a broker ID, provide the following information:\n1. **broker_id**: A short identifier string.\n2. **Broker Name**: Display name.\n3. **Broker Admin Wallet Address**: Must be an EOA (Externally Owned Account). This wallet receives fee rebates and authenticates broker-admin endpoints.\n4. **Default Fee Settings**: Maker and taker fee rates.\n\n### Admin Wallet Registration\nAfter the broker ID is created, you must register the admin wallet:\n1. Register the wallet as a standard user account under your `broker_id`.\n2. Provide the wallet address to the Orderly team to configure it as the admin account.\n3. **Multisig Support**: You can use a multisig wallet as the admin wallet. If using a multisig, use the 'delegate signer address' field in the broker-registration portal.\n\n### Admin Capabilities\nThe admin wallet has exclusive access to:\n- **Fee Collection**: Fee rebates are credited to the admin wallet's Orderly account balance.\n- **Fee Configuration**: Update default maker/taker fees via the private \"Update Default Builder Fee\" endpoint.\n- **Referral Management**: Create and manage referral codes.\n\n### Managing Fees\nTo update default fees, call the private \"Update Default Builder Fee\" endpoint. The request must be authenticated using the admin wallet's Orderly key credentials.\n\n**Example:**\n```bash\ncurl -X POST https://api-evm.orderly.org/v1/client/update_fee \\\n-H \"orderly-key: <ADMIN_PUBLIC_KEY>\" \\\n-H \"orderly-signature: <SIGNATURE>\" \\\n-H \"orderly-timestamp: <TIMESTAMP>\" \\\n-H \"orderly-account-id: <ADMIN_ACCOUNT_ID>\" \\\n-d '{\"maker_fee_rate\": 0.0002, \"taker_fee_rate\": 0.0005}'\n```\n\n### Checking Admin Balance\nTo check the accumulated fees (rebates), use the private `Get Current Holding` endpoint (`/v1/client/holding`) authenticated with the admin wallet's credentials. Note that revenue is credited to the trading balance, not directly sent to the external wallet.",
      "keywords": [
        "broker ID",
        "admin wallet",
        "fee configuration",
        "rebates",
        "multisig",
        "broker registration",
        "fee collection"
      ]
    },
    {
      "id": "api-31",
      "title": "Trading Orders and Algo Orders",
      "category": "Trading",
      "content": "Orderly supports standard limit/market orders as well as algorithmic orders like Take Profit (TP) and Stop Loss (SL).\n\n### Placing Orders\nOrders are placed via the private **Create Order** endpoint.\n\n**Key Parameters:**\n- `order_quantity`: Quantity in base units (e.g., ETH for PERP_ETH_USDC). **Note:** Futures orders do not support `order_amount` (quote currency).\n- `symbol`: The trading pair (e.g., `PERP_ETH_USDC`).\n- `side`: `BUY` or `SELL`.\n- `order_type`: `LIMIT` or `MARKET`.\n- `reduce_only`: Set to `true` to only reduce an existing position.\n\n**Validation:**\nBefore submitting, validate inputs against the **Exchange Information** endpoint (`Get Exchange Information`) to check for minimum price, quantity, and notional values.\n\n### Algo Orders (TP/SL)\nAlgo orders (TP/SL, Trailing Stop, Bracket) are managed separately from standard orders.\n\n**Important:**\n- Standard `GET /v1/orders` does **not** return algo orders. Use the private **Get Algo Orders** endpoint.\n- **TP/SL Quantity**: If a TP/SL order shows quantity as `0`, it represents a full-position close (Position TP/SL).\n- **Algo Types**: Use root types like `STOP`, `TP_SL`, `BRACKET`. `TAKE_PROFIT` and `STOP_LOSS` are child orders within these structures.\n\n**Example Payload (Bracket):**\n```json\n{\n  \"symbol\": \"PERP_ETH_USDC\",\n  \"algo_type\": \"BRACKET\",\n  \"side\": \"BUY\",\n  \"order_quantity\": \"1.0\",\n  \"trigger_price\": \"3000\",\n  \"tp_sl\": {\n    \"tp_trigger_price\": \"3200\",\n    \"sl_trigger_price\": \"2900\"\n  }\n}\n```\n\n### Order State and History\n- **Status**: `NEW` means the order is open. `FILLED` means it executed.\n- **Retention**: Order history is limited. If total orders > 2,000, only the most recent 2,000 are kept. If daily orders > 2,000, only that day's orders are retained.\n- **Market Order Price**: The exact fill price for market orders is uncertain until execution. Check the order history post-execution for the actual price.",
      "keywords": [
        "limit orders",
        "market orders",
        "algo orders",
        "TP/SL",
        "bracket orders",
        "order validation",
        "order history"
      ]
    },
    {
      "id": "api-32",
      "title": "Account Management and Sub-accounts",
      "category": "API",
      "content": "Orderly accounts can be managed as main accounts or split into sub-accounts for isolation of funds and strategies.\n\n### Account Connection States\nUnderstanding the user state is crucial for UI flow:\n1. **NotConnected / Connected**: Wallet connection state only.\n2. **NotSignedIn / SignedIn**: Result of `Get Account` or `Register Account`.\n3. **DisabledTrading / EnableTrading**: Result of `Get/Add Orderly Key`. **Private data (balances) is only available in `EnableTrading` state.**\n\n### Sub-accounts\nSub-accounts allow you to segregate funds and trading strategies under one main wallet.\n\n**Trading on Sub-accounts:**\nTo place an order on a specific sub-account, include the sub-account ID in the `orderly-account-id` header:\n```http\norderly-account-id: {sub_account_id}\n```\n\n**Funds Movement:**\nFunds move between the main account and sub-accounts via internal transfers.\n1. Deposit to the main account.\n2. Call the internal transfer endpoint to move collateral to the sub-account.\n\n**Monitoring Transfers:**\nSubscribe to the private WebSocket topic `wallet-transactions` to track the status of deposits, withdrawals, and internal transfers.\n\n### Rate Limits\n- **Private APIs**: Rate limits are enforced per **account**. Main accounts and their sub-accounts **share** the same limit.\n- **Algo Orders**: Limited to **1 request per second per account**.\n- **Public APIs**: Rate limits are enforced per IP.\n\n### Leverage\nLeverage is set **account-wide**, not per order.\n- **Update**: Use the private `Update Leverage Setting` endpoint.\n- **Query**: Use the public `Get Leverage Configuration` endpoint to see available options (e.g., 1x, 5x, 20x).",
      "keywords": [
        "sub-accounts",
        "account state",
        "internal transfer",
        "leverage",
        "rate limits",
        "wallet connection",
        "EnableTrading"
      ]
    },
    {
      "id": "api-33",
      "title": "Deposits, Withdrawals, and Fees",
      "category": "Operations",
      "content": "Managing asset movement involves understanding supported chains, fee structures, and specific API requirements.\n\n### Supported Chains\n- **Polygon**: Restricted due to exclusivity arrangements. Not available for all brokers.\n- **Solana**: Supported. Ensure you use a reliable RPC provider to avoid CORS/403 errors.\n- **BNB Chain**: Supported. Note that USDC uses 18 decimals on-chain, but Orderly only supports 6 decimals for deposits/withdrawals. Always check the `decimals` field in the `Public Token API`.\n\n### Withdrawal Fees\nWithdrawal fees vary by network and cover gas/cross-chain costs.\n- **Fetch Fees**: Use the public `Get Supported Collateral Info` endpoint.\n- **Minimum Amount**: The withdrawal amount must be greater than the fee. Requesting an amount less than or equal to the fee results in Error Code 5 \"Amount error\".\n\n### Withdrawal Process\n1. **Request**: Submit a withdrawal request via the private API.\n2. **Signature**: Requires an EIP-712 signature signed by the user's wallet.\n3. **Destination**: Withdrawals can only be made to the **login wallet address**.\n\n**Error Code 28 (Polygon)**: Indicates Polygon withdrawals are not enabled for your broker.\n\n### Deposit Tracking\nYou cannot reliably confirm a credit solely via the transaction hash. Use the private WebSocket topic `wallet-transactions` to monitor deposit status updates.\n\n### Solana Specifics\n- **Collateral**: Both USDC and SOL are valid collateral.\n- **RPC Issues**: If `useDeposit` shows 0 balance or fails, switch to a different Solana RPC endpoint that supports browser requests.",
      "keywords": [
        "withdrawal fees",
        "deposits",
        "Solana",
        "Polygon",
        "BNB Chain",
        "EIP-712",
        "collateral"
      ]
    },
    {
      "id": "api-34",
      "title": "Data Analytics and Indexer APIs",
      "category": "API",
      "content": "For building leaderboards, analytics dashboards, or tracking user history, you can use a mix of private authenticated APIs and public indexer APIs.\n\n### Private APIs (Authenticated)\nThese provide real-time data but require user credentials.\n- **Get Builders Leaderboard**: Fetch per-user volume and PnL for your broker.\n- **Get Builders Users Volumes**: Retrieve volume data for users associated with your broker.\n- **Get Position History**: User's historical positions.\n- **Get Orders**: User's order history.\n\n### Public Indexer / Dashboard APIs\nThese provide delayed data (indexed from on-chain events) and do not require user authentication. Useful for public leaderboards or analytics.\n\n**Endpoints:**\n- **Positions**: `GET /ranking/positions?address=<ADDRESS>&broker_id=<BROKER_ID>`\n  - Returns positions sorted by `holding_value` (descending).\n- **Trade History**: `POST /events_v2`\n  - Body: `{ \"account_id\": \"...\", \"event_type\": \"PERPTRADE\", \"from_time\": ..., \"to_time\": ... }`\n  - Limited to a specific time range (e.g., 30 days).\n- **Market Volume**: `GET /v1/kline` (for system-wide volume by pair).\n\n### Campaigns and Points\n- **Campaign Rankings**: Use the public `Get Campaign Ranking` endpoint for competition data. Campaign time windows must be configured by the Orderly team.\n- **Points System**: Orderly One supports a points-based incentive system. Use the staging docs for \"Get User Points Statistics\" for integration.\n\n### Broker Metrics\n- **Volume/TVL**: Use public endpoints `Get Market Volume by Broker` and `Get TVL by Broker`.\n- **Announcements**: Fetch maintenance/listing news via `GET /v1/public/announcement`.",
      "keywords": [
        "analytics",
        "indexer",
        "leaderboard",
        "campaign ranking",
        "trade history",
        "broker metrics",
        "events_v2"
      ]
    },
    {
      "id": "api-35",
      "title": "API Authentication and Request Signing",
      "category": "API",
      "content": "Orderly Network uses a custom authentication scheme for private REST endpoints. This involves generating an Ed25519 keypair, registering the public key, and signing every request with the private key.\n\n### Key Concepts\n\n- **Orderly Key**: An Ed25519 keypair used for API authentication. The public key is registered on-chain via the wallet, and the private key stays client-side.\n- **Headers**: Every private request must include `orderly-key`, `orderly-signature`, `orderly-timestamp`, and `orderly-account-id`.\n- **Signature**: The signature is generated by signing a normalized message string containing the timestamp, HTTP method, request path, and body (if applicable).\n\n### Required Headers\n\n| Header | Description |\n|--------|-------------|\n| `orderly-key` | Your public Orderly key (prefixed with `ed25519:`). |\n| `orderly-signature` | Base64 URL-safe encoded Ed25519 signature of the message. |\n| `orderly-timestamp` | Current epoch time in milliseconds. |\n| `orderly-account-id` | Your Orderly Account ID. |\n| `Content-Type` | `application/json` for POST/PUT, `application/x-www-form-urlencoded` for GET/DELETE. |\n\n### Constructing the Signature Message\n\nThe message to be signed is a concatenation of specific request components:\n\n1. **Timestamp** (in milliseconds)\n2. **HTTP Method** (uppercase, e.g., `POST`)\n3. **Request Path** (including query parameters, excluding base URL)\n4. **Body** (JSON stringified, only for POST/PUT)\n\n**Format:** `{timestamp}{method}{path}{body}`\n\n**Example (POST):**\n```\n1649920583000POST/v1/order{\"symbol\": \"PERP_ETH_USDC\", \"order_type\": \"LIMIT\", \"side\": \"BUY\"}\n```\n\n**Example (GET with no params):**\n```\n1649920583000GET/v1/volume/user/daily\n```\n\n### Code Examples\n\n#### TypeScript (Node.js)\n\n```typescript\nimport { getPublicKeyAsync, signAsync } from '@noble/ed25519';\nimport { encodeBase58 } from 'ethers';\n\nexport async function signAndSendRequest(\n  orderlyAccountId: string, \n  privateKey: Uint8Array, \n  url: string, \n  method: string = 'GET',\n  body?: any\n) {\n  const timestamp = Date.now();\n  const urlObj = new URL(url);\n  \n  // Construct message: timestamp + method + path + query + body\n  let message = `${timestamp}${method}${urlObj.pathname}${urlObj.search}`;\n  if (body) {\n    message += JSON.stringify(body);\n  }\n\n  // Sign with Ed25519\n  const sig = await signAsync(new TextEncoder().encode(message), privateKey);\n  const pubKey = await getPublicKeyAsync(privateKey);\n\n  // Prepare headers\n  const headers = {\n    'Content-Type': (method === 'POST' || method === 'PUT') ? 'application/json' : 'application/x-www-form-urlencoded',\n    'orderly-timestamp': String(timestamp),\n    'orderly-account-id': orderlyAccountId,\n    'orderly-key': `ed25519:${encodeBase58(pubKey)}`,\n    'orderly-signature': Buffer.from(sig).toString('base64url'),\n  };\n\n  // Send request\n  const response = await fetch(url, {\n    method,\n    headers,\n    body: body ? JSON.stringify(body) : undefined,\n  });\n\n  return response.json();\n}\n```\n\n#### Python\n\n```python\nimport base64\nimport json\nimport time\nimport urllib.parse\nfrom base58 import b58decode, b58encode\nfrom cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey\n\ndef sign_request(private_key_b58: str, timestamp: int, method: str, path: str, body: dict = None):\n    # Decode private key\n    key_bytes = b58decode(private_key_b58)\n    private_key = Ed25519PrivateKey.from_private_bytes(key_bytes)\n    \n    # Construct message\n    message = f\"{timestamp}{method}{path}\"\n    if body:\n        message += json.dumps(body, separators=(',', ':'))\n    \n    # Sign\n    signature = private_key.sign(message.encode('utf-8'))\n    sig_b64 = base64.urlsafe_b64encode(signature).decode('utf-8')\n    \n    # Get public key for header\n    pub_key_bytes = private_key.public_key().public_bytes_raw()\n    orderly_key = f\"ed25519:{b58encode(pub_key_bytes).decode('utf-8')}\"\n    \n    return orderly_key, sig_b64\n\n# Usage\n# timestamp = int(time.time() * 1000)\n# orderly_key, sig = sign_request(SECRET, timestamp, \"POST\", \"/v1/order\", order_data)\n```\n\n### Common Issues\n\n- **Timestamp Drift**: Ensure your system clock is synchronized. Requests with timestamps differing from server time by >300 seconds are rejected.\n- **Body Serialization**: When signing POST requests, ensure the JSON body is serialized without extra spaces (standard `JSON.stringify` usually works, but verify separators if using Python).\n- **Key Prefix**: The `orderly-key` header must include the `ed25519:` prefix.\n- **Path Trailing Slashes**: Be consistent with the path. If the endpoint is `/v1/order`, do not sign `/v1/order/` unless specified.",
      "keywords": [
        "authentication",
        "ed25519",
        "signing",
        "headers",
        "rest api",
        "orderly key",
        "signature"
      ]
    },
    {
      "id": "api-36",
      "title": "Account Registration and Management",
      "category": "API",
      "content": "Before trading, a user must register an Orderly Account. This process links a Web3 wallet address to a specific Broker ID (Builder ID) and generates an Orderly Account ID used for all subsequent API interactions.\n\n### Registration Flow\n\n1. **Check Registration**: Verify if the wallet is already registered.\n2. **Get Nonce**: Retrieve a one-time registration nonce.\n3. **Sign Message**: Sign the registration data using the wallet's private key (EIP-712).\n4. **Submit**: Send the signature and data to the registration endpoint.\n\n### Step 1: Check Existing Registration\n\nUse the public endpoint to check if a wallet already has an account under a specific broker.\n\n**Endpoint:** `GET /v1/get_account`\n\n**Query Parameters:**\n- `broker_id`: The Broker ID to check against.\n- `address`: The wallet address.\n\nIf the account exists, you can skip registration and proceed to login/key creation.\n\n### Step 2: Get Registration Nonce\n\n**Endpoint:** `GET /v1/registration_nonce`\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"registration_nonce\": \"1234567890abcdef\"\n  }\n}\n```\n\nThe nonce is valid for 2 minutes.\n\n### Step 3: Sign EIP-712 Typed Data\n\nYou must sign a structured message conforming to the EIP-712 standard.\n\n**Domain:**\n```json\n{\n  \"name\": \"Orderly\",\n  \"version\": \"1\",\n  \"chainId\": 421614,\n  \"verifyingContract\": \"0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC\"\n}\n```\n*Note: The `verifyingContract` is a fixed address for off-chain registration.*\n\n**Types:**\n```json\n{\n  \"EIP712Domain\": [\n    { \"name\": \"name\", \"type\": \"string\" },\n    { \"name\": \"version\", \"type\": \"string\" },\n    { \"name\": \"chainId\", \"type\": \"uint256\" },\n    { \"name\": \"verifyingContract\", \"type\": \"address\" }\n  ],\n  \"Registration\": [\n    { \"name\": \"brokerId\", \"type\": \"string\" },\n    { \"name\": \"chainId\", \"type\": \"uint256\" },\n    { \"name\": \"timestamp\", \"type\": \"uint64\" },\n    { \"name\": \"registrationNonce\", \"type\": \"string\" }\n  ]\n}\n```\n\n**Message:**\n```json\n{\n  \"brokerId\": \"woofi_dex\",\n  \"chainId\": 421614,\n  \"timestamp\": 1710000000000,\n  \"registrationNonce\": \"1234567890abcdef\"\n}\n```\n\n### Step 4: Submit Registration\n\n**Endpoint:** `POST /v1/register_account`\n\n**Body:**\n```json\n{\n  \"message\": {\n    \"brokerId\": \"woofi_dex\",\n    \"chainId\": 421614,\n    \"timestamp\": 1710000000000,\n    \"registrationNonce\": \"1234567890abcdef\"\n  },\n  \"signature\": \"0x...\",\n  \"userAddress\": \"0x123...\"\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"account_id\": \"orderly_account_id_string\"\n  }\n}\n```\n\nStore the `account_id` securely; it is required for the `orderly-account-id` header in all future requests.\n\n### Orderly Key Management\n\nOnce registered, the user needs an Orderly Key (Ed25519) to sign trading requests. This is separate from the wallet key.\n\n**Endpoint:** `POST /v1/orderly_key`\n\n**Body:**\n```json\n{\n  \"message\": {\n    \"brokerId\": \"woofi_dex\",\n    \"chainId\": 421614,\n    \"orderlyKey\": \"ed25519:Base58PublicKey\",\n    \"scope\": \"read,trading\",\n    \"timestamp\": 1710000000000,\n    \"expiration\": 1741536000000\n  },\n  \"signature\": \"0x...\",\n  \"userAddress\": \"0x123...\"\n}\n```\n\n**Scopes:**\n- `read`: Access to private read-only APIs.\n- `trading`: Access to order management APIs.\n- `asset`: Access to deposit/withdrawal APIs.\n\nYou can set an `expiration` time (timestamp in ms) for the key. If lost, simply generate a new one; the old one can be deleted via `POST /v1/client/remove_orderly_key`.\n\n### Delegate Signer (Smart Contract Wallets)\n\nSmart Contract Wallets (AA) cannot sign EIP-712 messages off-chain directly. Orderly supports a **Delegate Signer** flow:\n\n1. **On-chain Delegation**: The smart contract calls `delegateSigner` on-chain, authorizing an EOA (Externally Owned Account).\n2. **Off-chain Confirmation**: The authorized EOA confirms the link via the `delegate_signer` API.\n3. **Trading**: The EOA generates and manages the Orderly Key for trading.\n\nThis allows smart contract users to trade without exposing a private key on the contract.",
      "keywords": [
        "registration",
        "account id",
        "broker id",
        "eip-712",
        "orderly key",
        "delegate signer",
        "wallet"
      ]
    },
    {
      "id": "api-37",
      "title": "Trading API and Order Management",
      "category": "Trading",
      "content": "The Orderly Trading API allows you to create, cancel, and query orders. All trading endpoints require authentication using the Orderly Key (Ed25519).\n\n### Placing an Order\n\n**Endpoint:** `POST /v1/order`\n\n**Request Body:**\n```json\n{\n  \"symbol\": \"PERP_ETH_USDC\",\n  \"order_type\": \"LIMIT\",\n  \"order_price\": \"2200.50\",\n  \"order_quantity\": \"0.1\",\n  \"side\": \"BUY\",\n  \"reduce_only\": false\n}\n```\n\n**Parameters:**\n- `symbol`: The trading pair (e.g., `PERP_BTC_USDC`).\n- `order_type`: `LIMIT`, `MARKET`, `STOP`, `TAKE_PROFIT`, or `STOP_LIMIT`.\n- `side`: `BUY` or `SELL`.\n- `order_quantity`: Amount of the asset.\n- `order_price`: Required for `LIMIT` orders.\n- `reduce_only`: If `true`, the order only reduces the position size.\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"order_id\": \"123456789\",\n    \"client_order_id\": \"my-custom-id\"\n  }\n}\n```\n\n### Algo Orders: TP/SL\n\nOrderly supports Take-Profit/Stop-Loss (TP/SL) algo orders. This creates a root order with child orders that trigger under specific conditions.\n\n**Endpoint:** `POST /v1/algo_order`\n\n**Payload Structure:**\n```json\n{\n  \"symbol\": \"PERP_NEAR_USDC\",\n  \"algo_type\": \"TP_SL\",\n  \"quantity\": \"5.5\",\n  \"trigger_price_type\": \"MARK_PRICE\",\n  \"child_orders\": [\n    {\n      \"symbol\": \"PERP_NEAR_USDC\",\n      \"algo_type\": \"TAKE_PROFIT\",\n      \"side\": \"SELL\",\n      \"type\": \"MARKET\",\n      \"trigger_price\": \"3.365\",\n      \"reduce_only\": true\n    },\n    {\n      \"symbol\": \"PERP_NEAR_USDC\",\n      \"algo_type\": \"STOP_LOSS\",\n      \"side\": \"SELL\",\n      \"type\": \"MARKET\",\n      \"trigger_price\": \"3.36\",\n      \"reduce_only\": true\n    }\n  ]\n}\n```\n\n### Editing Orders\n\nTo modify an existing order, use the edit endpoint. You must provide the `order_id`.\n\n**Endpoint:** `PUT /v1/order`\n\n**Body:**\n```json\n{\n  \"order_id\": \"123456789\",\n  \"order_quantity\": \"0.2\",\n  \"order_price\": \"2250.00\"\n}\n```\n\n### Canceling Orders\n\n**Cancel Single Order:**\n`DELETE /v1/order`\n\n**Body:**\n```json\n{\n  \"order_id\": \"123456789\"\n}\n```\n\n**Cancel All Orders:**\n`DELETE /v1/orders`\n\n### Maintenance and Order Cancellation\n\nBy default, pending orders are **not** automatically cancelled during system maintenance. To enable auto-cancellation for a user:\n\n1. Use the private endpoint `POST /v1/set_maintenance_config`.\n2. Set the appropriate flag to enable auto-cancellation.\n\nBuilders should implement a UI toggle allowing users to opt-in to this feature.\n\n### Fee Rates\n\nYou can fetch the current fee rates for the authenticated user.\n\n**Endpoint:** `GET /v1/client/info`\n\nThis returns the `maker_fee_rate` and `taker_fee_rate` (e.g., `0.0003` for 0.03%).\n\n### Common Issues\n\n- **\"Insufficient Margin\"**: Ensure the user has enough collateral to cover the initial margin requirement for the new position.\n- **\"Order Price Invalid\"**: Check that the price aligns with the current market price and tick size rules.\n- **\"Position Notional Limit\"**: Large orders might exceed the maximum notional value allowed for the specific leverage tier.",
      "keywords": ["order", "trading", "algo order", "tp/sl", "cancel order", "edit order", "fees"]
    },
    {
      "id": "api-38",
      "title": "Internal Transfers API",
      "category": "API",
      "content": "The Internal Transfer API allows moving funds between Orderly accounts under the same Broker ID without incurring on-chain gas fees (off-chain transfer). This requires a specific signature flow combining the Orderly Key (for API auth) and the Wallet Key (for transfer authorization).\n\n### Prerequisites\n\n- Both sender and receiver accounts must be registered under the **same Broker ID**.\n- You need the sender's Orderly Key (Ed25519) and Wallet Key (for EIP-712 signing).\n\n### Step 1: Get Transfer Nonce\n\nFetch a nonce specific to the transfer operation.\n\n**Endpoint:** `GET /v1/transfer_nonce`\n\n**Headers:** Standard Orderly Auth headers (`orderly-key`, `orderly-signature`, etc.).\n\n**Response:**\n```json\n{\n  \"data\": {\n    \"transfer_nonce\": 1\n  }\n}\n```\n\n### Step 2: Sign EIP-712 InternalTransfer Message\n\nConstruct and sign the `InternalTransfer` typed data.\n\n**Domain (On-Chain):**\n```json\n{\n  \"name\": \"Orderly\",\n  \"version\": \"1\",\n  \"chainId\": 42161,\n  \"verifyingContract\": \"0x6F7a338F2aA472838dEFD3283eB360d4Dff5D203\"\n}\n```\n*Note: Use the Ledger contract address for `verifyingContract`.*\n\n**Types:**\n```json\n{\n  \"InternalTransfer\": [\n    { \"name\": \"receiver\", \"type\": \"bytes32\" },\n    { \"name\": \"token\", \"type\": \"string\" },\n    { \"name\": \"amount\", \"type\": \"uint256\" },\n    { \"name\": \"transferNonce\", \"type\": \"uint256\" },\n    { \"name\": \"chainId\", \"type\": \"uint256\" },\n    { \"name\": \"chainType\", \"type\": \"string\" }\n  ]\n}\n```\n\n**Message Values:**\n- `receiver`: The receiver's Orderly Account ID (padded to bytes32).\n- `token`: Token symbol (e.g., `\"USDC\"`).\n- `amount`: Raw amount (e.g., `1000000` for 1 USDC if 6 decimals).\n- `transferNonce`: The nonce obtained in Step 1.\n- `chainId`: The chain ID (e.g., `42161`).\n- `chainType`: `\"EVM\"` or `\"SOL\"`.\n\n### Step 3: Submit Transfer\n\n**Endpoint:** `POST /v2/internal_transfer`\n\n**Headers:** Standard Orderly Auth headers (signed with Orderly Key).\n\n**Body:**\n```json\n{\n  \"message\": {\n    \"receiver\": \"0x0000...0000\",\n    \"token\": \"USDC\",\n    \"amount\": \"1000000\",\n    \"transferNonce\": \"1\",\n    \"chainId\": \"42161\",\n    \"chainType\": \"EVM\"\n  },\n  \"signature\": \"0x...\", \n  \"userAddress\": \"0xSenderAddress\",\n  \"verifyingContract\": \"0x6F7a338F2aA472838dEFD3283eB360d4Dff5D203\"\n}\n```\n\n**Important:**\n- `message.receiver` in the JSON body is a hex string (e.g., `\"0x...\"`), but in the EIP-712 signature it must be treated as `bytes32`.\n- `signature` is the EIP-712 signature from the Wallet.\n- `userAddress` must match the signer of the EIP-712 message.\n\n### Troubleshooting\n\n- **\"Please use the latest version\"**: This error usually means you are trying to transfer to an account with a **different Broker ID**. Internal transfers are strictly intra-broker.\n- **Signature Mismatch**: Ensure the `verifyingContract` in the EIP-712 domain matches the one sent in the JSON body and corresponds to the correct network (Mainnet vs Testnet).",
      "keywords": [
        "internal transfer",
        "off-chain transfer",
        "broker id",
        "eip-712",
        "nonce",
        "verifying contract"
      ]
    },
    {
      "id": "api-39",
      "title": "Broker Operations and Analytics",
      "category": "Operations",
      "content": "Builders (Brokers) have access to specific administrative endpoints to manage users, configure fees, and retrieve analytics data for their DEX.\n\n### Broker ID Setup\n\nTo operate a DEX on Orderly, you need a unique Broker ID.\n\n**Required Information for Setup:**\n1. DEX URL.\n2. Preferred Broker ID (lowercase, alphanumeric, `-`, `_`).\n3. Default Maker/Taker fees (e.g., 3 bps / 6 bps).\n\nContact `product@orderly.network` to provision your Broker ID.\n\n### Fee Management\n\nBrokers can customize fee rates for specific users or set a default for the entire broker.\n\n**Set Default Fee:**\n`POST /v1/broker/fee_rate/default`\n\n**Set Custom Fee for Users:**\n`POST /v1/broker/fee_rate/set`\n\nBatch users by the same fee tier to optimize API calls.\n\n**Reset to Default:**\n`POST /v1/broker/fee_rate/set_default`\n\n### Analytics and Leaderboards\n\nYou can fetch volume and trading statistics to build custom leaderboards or analytics dashboards.\n\n**Get Broker-Level User Activity:**\nEndpoint: `GET /v1/broker/leaderboard` (Private)\n\nThis returns metrics like trade volume and activity counts for users under your broker.\n\n**Get Per-User Volume:**\nEndpoint: `GET /v1/volume/user/daily` (Private)\n\nUse this to fetch daily trading volume per user. You can aggregate this data to create a volume-based rewards system.\n\n### Referral Program\n\nImplement a referral system to incentivize user growth.\n\n**Create Referral Code:**\n`POST /v1/referral/create`\n\nRequires the builder's admin authentication. You must define rebate rates for both the referrer and the referee.\n\n**Bind Code to User:**\n`POST /v1/referral/bind`\n\nCall this when a new user signs up using a referral code.\n\n### Maintenance Monitoring\n\nStay updated on system status to inform your users.\n\n1. **API Check:** `GET /v1/public/get_system_maintenance_status`\n2. **Telegram Channel**: Join the Orderly System Updates channel for announcements.\n\n### Operational Best Practices\n\n- **Demo to Production Migration**: When switching from a demo Broker ID to production, keep the demo environment live in \"read-only\" mode (allow withdrawals/close positions only) so users can safely migrate funds.\n- **Fee Discounts**: If offering token-based fee discounts (e.g., staking your token), implement a script that periodically updates user fee tiers via the API.",
      "keywords": ["broker", "fees", "analytics", "leaderboard", "referral", "maintenance", "admin"]
    },
    {
      "id": "api-40",
      "title": "Infrastructure and Base Endpoints",
      "category": "Infrastructure",
      "content": "This section covers the base URLs, rate limits, and general infrastructure details for the Orderly Network API.\n\n### Base URLs\n\n| Environment | REST API | WebSocket API |\n|-------------|----------|---------------|\n| Mainnet | `https://api.orderly.org` | `wss://ws.orderly.org` |\n| Testnet | `https://testnet-api.orderly.org` | `wss://ws-testnet.orderly.org` |\n\n### Rate Limits\n\nRate limits are enforced per Orderly Key. If you exceed the limit, the API returns HTTP `429`.\n\n**Common Limits:**\n- **Trading Endpoints:** Often limited to ~10-100 requests per second depending on the endpoint.\n- **Read Endpoints:** Generally higher limits (e.g., 10 requests per 60 seconds for account info).\n\nAlways check the specific endpoint documentation for exact limits.\n\n### Error Handling\n\nStandard error response format:\n\n```json\n{\n  \"success\": false,\n  \"code\": -1005,\n  \"message\": \"order_price must be a positive number\"\n}\n```\n\n### Solana Integration Addresses\n\nIf integrating with Solana, use the following addresses:\n\n**Mainnet:**\n- USDC Mint: `EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v`\n- SolConnector: `0xCecAe061aa078e13b5e70D5F9eCee90a3F2B6AeA`\n- Vault: `ErBmAD61mGFKvrFNaTJuxoPwqrS8GgtwtqJTJVjFWx9Q`\n\n**Devnet (Arctic):**\n- USDC Mint: `4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU`\n- SolConnector: `0x5Bf771A65d057e778C5f0Ed52A0003316f94322D`\n- Vault: `9shwxWDUNhtwkHocsUAmrNAQfBH2DHh4njdAEdHZZkF2`\n\n### Security Headers for DNS\n\nTo prevent your custom domain from being flagged as \"unsafe\" by browsers (e.g., Brave), add these DNS records:\n\n**SPF (TXT):**\n```\nType: TXT\nName: @\nValue: v=spf1 -all\n```\n\n**DMARC (TXT):**\n```\nType: TXT\nName: _dmarc\nValue: v=DMARC1; p=reject; sp=reject; aspf=s; adkim=s\n```\n\n### Indexer and Event Queries\n\nFor historical data or complex event queries (beyond standard REST APIs), Orderly provides an indexer-backed query service.\n- **Access:** Available via Swagger/Dashboard.\n- **Limitations:** It supports REST querying only (no streaming/WebSocket). Position updates must be inferred from trade data.",
      "keywords": [
        "base url",
        "rate limit",
        "solana",
        "dns",
        "security",
        "indexer",
        "error handling"
      ]
    },
    {
      "id": "api-41",
      "title": "REST API: Trading and Order Management",
      "category": "API",
      "content": "The Orderly Network REST API provides comprehensive endpoints for managing orders, positions, and account data. This guide covers the core trading operations.\n\n## Authentication\n\nAll private endpoints require an Orderly Key with the appropriate scope (e.g., `trading`, `asset`). Requests must be signed according to the Orderly authentication scheme.\n\n## Order Management\n\n### Creating an Order\n\nTo place a new order (maker or taker), use the `POST /v1/order` endpoint.\n\n*   **Endpoint:** `POST /v1/order`\n*   **Scope:** `trading`\n*   **Rate Limit:** 10 requests per second\n\nThe endpoint responds immediately with an order-created message, while execution updates are delivered via WebSocket streams.\n\n### Editing an Order\n\nYou can amend a pending order's price or quantity.\n\n*   **Endpoint:** `PUT /v1/order`\n*   **Scope:** `trading`\n*   **Rate Limit:** 10 requests per second\n\nOnly `order_price` or `order_quantity` can be changed. The request must include the `order_id` of the pending order.\n\n### Canceling Orders\n\nSeveral options are available for canceling orders:\n\n1.  **Cancel Single Order:**\n    *   By `order_id`: `DELETE /v1/order?order_id={order_id}&symbol={symbol}`\n    *   By `client_order_id`: `DELETE /v1/client/order?client_order_id={client_order_id}&symbol={symbol}`\n    *   **Rate Limit:** 10 requests/second\n\n2.  **Cancel All Open Orders:**\n    *   `DELETE /v1/orders?symbol={symbol}`\n    *   If `symbol` is omitted, it cancels all open orders.\n    *   **Rate Limit:** 10 requests/second\n\n3.  **Batch Cancel Orders:**\n    *   By `order_id`: `DELETE /v1/batch-order?order_ids={id1},{id2}`\n    *   By `client_order_id`: `DELETE /v1/client/batch-order?client_order_ids={id1},{id2}`\n    *   **Limit:** Up to 10 orders per request.\n    *   **Rate Limit:** 10 requests/second\n\n## Algo Orders\n\nAlgo orders, such as stop-loss, take-profit, and trailing stops, require a trigger for execution.\n\n### Creating an Algo Order\n\n*   **Endpoint:** `POST /v1/algo/order`\n*   **Scope:** `trading`\n*   **Rate Limit:** 1 request/second\n\nFor positional TP/SL, the request uses a 2-layer structure with a `childOrder` array. Sub-orders must use `type=CLOSE_POSITION` and set `algoType` to `TAKE_PROFIT` or `STOP_LOSS`. For a trailing stop, set `algoType=TRAILING_STOP`, `type=MARKET`, and provide the `callbackRate`.\n\n### Editing an Algo Order\n\n*   **Endpoint:** `PUT /v1/algo/order`\n*   **Scope:** `trading`\n*   **Rate Limit:** 5 requests/second\n\nOnly the price or quantity of a pending algo order can be amended.\n\n## Batch Operations\n\n### Batch Create Orders\n\n*   **Endpoint:** `POST /v1/batch-order`\n*   **Rate Limit:** 1 request/second\n\nSend a JSON array of up to 10 orders. Each order follows the same parameters as the single Create Order API. Each order in the batch counts toward the overall create order rate limit.\n\n## Querying Orders and Trades\n\n### Get Order Details\n\n*   By `order_id`: `GET /v1/order/{order_id}`\n*   By `client_order_id`: `GET /v1/client/order/{client_order_id}`\n*   **Rate Limit:** 10 requests/second\n\n### List Orders\n\n*   **Endpoint:** `GET /v1/orders`\n*   **Rate Limit:** 10 requests/second\n\nYou can filter orders by status. Convenient bundled statuses are available:\n*   `INCOMPLETE`: `NEW` + `PARTIAL_FILLED`\n*   `COMPLETED`: `CANCELLED` + `FILLED`\n\n### Get Order Trades\n\n*   Standard order: `GET /v1/order/{order_id}/trades`\n*   Algo order: `GET /v1/algo/order/{order_id}/trades`\n*   **Rate Limit:** 10 requests/second\n\n### Query Algo Orders\n\n*   List: `GET /v1/algo/orders` (Rate limit: 5 req/s)\n*   Single by `order_id`: `GET /v1/algo/order/{order_id}`\n*   Single by `client_order_id`: `GET /v1/algo/client/order/{client_order_id}`\n*   **Rate Limit:** 10 requests/second for single queries.\n\n## Common Issues\n\n*   **Invalid Order ID:** When batch canceling, if `0` IDs are provided or all are invalid, the endpoint returns an invalid order ID error.\n*   **Scope Errors:** Ensure your Orderly Key includes the required scope (`trading` for order operations, `asset` for withdrawals/transfers).\n*   **Rate Limits:** Exceeding rate limits will result in HTTP 429 errors. Implement proper backoff strategies in your client.",
      "keywords": ["REST API", "order management", "trading", "algo orders", "batch operations"]
    },
    {
      "id": "api-42",
      "title": "WebSocket API: Market Data and Private Streams",
      "category": "API",
      "content": "Orderly Network offers real-time data feeds via WebSockets for both public market data and private user account information. This guide details how to connect, authenticate, and subscribe to these streams.\n\n## WebSocket Endpoints\n\n### Market Data Streams (Public)\n\n*   **Mainnet:** `wss://ws-evm.orderly.org/ws/stream/{account_id}`\n*   **Testnet:** `wss://testnet-ws-evm.orderly.org/ws/stream/{account_id}`\n\nSupported topics include `orderbook`, `trade`, `ticker`, `tickers`, `bbo`, `bbos`, `estfundingrate`, `indexprice`, `markprice`, `openinterest`, and various `kline` intervals.\n\n### Private User Data Streams\n\n*   **Mainnet:** `wss://ws-private-evm.orderly.org/v2/ws/private/stream/{account_id}`\n*   **Testnet:** `wss://testnet-ws-private-evm.orderly.org/v2/ws/private/stream/{account_id}`\n\nSupported topics include `account`, `balance`, `executionreport`, `liquidationsaccount`, `liquidatorliquidations`, `notifications`, `settle`, `position`, and `wallet`.\n\n## Authentication\n\nPrivate streams require authentication. You can authenticate by sending an auth event after connecting or by appending parameters to the URL.\n\n### Auth Event Method\n\nSend a JSON message with `event: \"auth\"`:\n\n```json\n{\n  \"id\":\"123r\",\n  \"event\":\"auth\",\n  \"params\":{\n    \"orderly_key\":\"ed25519:CUS69ZJOXwSV38xo...\",\n    \"sign\":\"4180da84117fc9753b...\",\n    \"timestamp\":1621910107900\n  }\n}\n```\n\nFor WebSocket auth, the message to sign is just the `timestamp`.\n\n### Query String Method\n\n`wss://ws-private-evm.orderly.org/v2/ws/private/stream/{account_id}?orderly_key=xxxxxxxx&timestamp=xxxxx&sign=xxxxx`\n\n## Connection Management\n\n### Ping/Pong\n\nThe server sends a `ping` every 10 seconds. If the server does not receive a `pong` within 10 seconds for 10 consecutive times, it disconnects the client. Clients should also send a ping every 10 seconds to keep the connection alive.\n\n*   **Client Ping:** `{ \"event\":\"ping\" }`\n*   **Server Pong:** `{ \"event\":\"pong\", \"ts\":1614667590000 }`\n\n### Error Handling\n\nUse the `id` field in the response to map errors to your requests.\n\n```json\n{\n  \"id\": \"clientID7\",\n  \"event\": \"subscribe\",\n  \"success\": false,\n  \"errorMsg\": \"invalid symbol\"\n}\n```\n\n## Subscribing to Topics\n\nTo subscribe, send a message with `event: \"subscribe\"`, the `topic`, and a client-generated `id`.\n\n### Private Topics Examples\n\n**Account Configuration:**\n```json\n{\n  \"id\": \"clientID3\",\n  \"topic\": \"account\",\n  \"event\": \"subscribe\"\n}\n```\nUpdates include `marginMode`, `futuresLeverage`, fee rates, and `symbolLeverage`.\n\n**Balance Updates:**\n```json\n{\n  \"id\": \"clientID3\",\n  \"topic\": \"balance\",\n  \"event\": \"subscribe\"\n}\n```\n\n**Positions:**\n```json\n{\n  \"id\": \"clientID3\",\n  \"topic\": \"position\",\n  \"event\": \"subscribe\"\n}\n```\n\n### Public Topics Examples\n\n**All Tickers:**\n```json\n{\n  \"id\": \"clientID4\",\n  \"topic\": \"tickers\",\n  \"event\": \"subscribe\"\n}\n```\n\n**Symbol Trades:**\n```json\n{\n  \"id\": \"clientID3\",\n  \"topic\": \"PERP_WOO_USDC@trade\",\n  \"event\": \"subscribe\"\n}\n```\n\n**Orderbook Snapshot:**\nTo request an initial snapshot, use `event: \"request\"`:\n```json\n{\n  \"id\": \"clientID1\",\n  \"event\": \"request\",\n  \"params\": {\n    \"type\": \"orderbook\",\n    \"symbol\": \"PERP_NEAR_USDC\"\n  }\n}\n```\n\n## Unsubscribing\n\nSend the same `topic` with `event: \"unsubscribe\"`.\n\n```json\n{\n  \"id\": \"clientID5\",\n  \"topic\": \"bbos\",\n  \"event\": \"unsubscribe\"\n}\n```",
      "keywords": ["WebSocket", "market data", "private streams", "authentication", "real-time"]
    },
    {
      "id": "api-43",
      "title": "REST API: Account, Assets, and Sub-accounts",
      "category": "API",
      "content": "Managing user accounts, assets, and sub-accounts is a core part of integrating with Orderly Network. This section details the endpoints for retrieving account information, managing holdings, and handling withdrawals.\n\n## Account Information\n\n### Aggregate Holdings\n\nRetrieve a summary of token holdings for an account.\n\n*   **Endpoint:** `GET /v1/client/holding`\n*   **Rate Limit:** 10 requests/second\n\n### Aggregate Positions\n\nRetrieve all current positions for an account.\n\n*   **Endpoint:** `GET /v1/positions`\n*   **Rate Limit:** 30 requests per 10 seconds per user\n\nTo get a single position by symbol, use `GET /v1/position/{symbol}`.\n\n### Position History\n\n*   **Endpoint:** `GET /v1/position_history`\n*   **Rate Limit:** 10 requests/second\n\n## Asset Management\n\n### Asset History\n\nRetrieve history of token deposits and withdrawals.\n\n*   **Endpoint:** `GET /v1/asset/history`\n*   **Rate Limit:** 10 requests per 60 seconds\n\n### Withdrawals\n\n**Create Withdrawal Request:**\n\n*   **Endpoint:** `POST /v1/withdraw_request`\n*   **Rate Limit:** 10 requests/second per IP\n*   **Verifying Contract:** `0x6F7a338F2aA472838dEFD3283eB360d4Dff5D203`\n\nIf `allow_cross_chain_withdrawal` is `false` and the request is cross-chain, the API returns error `22 - Cross-chain withdrawal required for this withdrawal request.`\n\n**Get Withdrawal Nonce:**\n\n*   **Endpoint:** `GET /v1/withdraw_nonce`\n*   **Rate Limit:** 10 requests/second\n\nEach nonce can only be used once.\n\n### Internal Transfers\n\nRetrieve internal transfer history.\n\n*   **Endpoint:** `GET /v1/internal_transfer_history`\n*   **Scope:** `asset`\n*   **Rate Limit:** 10 requests/second\n\n## PnL Settlement\n\n### Request Settlement\n\n*   **Endpoint:** `POST /v1/settle_pnl`\n*   **Rate Limit:** 1 request/second\n*   **Verifying Contract:** `0x6F7a338F2aA472838dEFD3283eB360d4Dff5D203`\n\n**Get Settlement Nonce:**\n\n*   **Endpoint:** `GET /v1/settle_nonce`\n*   **Rate Limit:** 10 requests/second\n\n### Settlement History\n\n*   **Endpoint:** `GET /v1/pnl_settlement/history`\n*   **Rate Limit:** 20 requests/second\n\n## Sub-Account Management\n\n### Add Sub-Account\n\n*   **Endpoint:** `POST /v1/client/add_sub_account`\n*   **Rate Limit:** 10 requests/second\n*   **Permission:** Only the main account can call this.\n\n### List Sub-Accounts\n\n*   **Endpoint:** `GET /v1/client/sub_account`\n*   **Rate Limit:** 10 requests/second\n*   **Permission:** Only the main account can call this.\n\n### Settle PnL for Sub-Account\n\n*   **Endpoint:** `POST /v1/sub_account_settle_pnl`\n*   **Rate Limit:** 10 requests/second\n\nThe main account’s Orderly key controls sub-accounts.\n\n## Referral System\n\n### Referee Info\n\n*   **Endpoint:** `GET /v1/referral/referee_info`\n\n### Referral History\n\n*   **Endpoint:** `GET /v1/referral/referral_history`\n\n### Referee Rebate Summary\n\n*   **Endpoint:** `GET /v1/referral/referee_rebate_summary`\n\n## Common Issues\n\n*   **Cross-Chain Withdrawals:** Ensure you handle error code `22` appropriately if your application does not support cross-chain withdrawals.\n*   **Nonce Reuse:** Always fetch a fresh nonce for withdrawal and settlement requests. Reusing a nonce will result in an error.",
      "keywords": ["account management", "withdrawals", "sub-accounts", "PnL settlement", "assets"]
    },
    {
      "id": "api-44",
      "title": "REST API: Public Market Data",
      "category": "API",
      "content": "Orderly Network provides a set of public REST endpoints to fetch market data, configuration, and trading information without authentication. These are essential for building market displays, order forms, and analytics tools.\n\n## Market Configuration\n\n### Supported Tokens\n\nRetrieve the list of tokens that can be used as collateral.\n\n*   **Endpoint:** `GET /v1/public/token`\n*   **Rate Limit:** 10 requests/second per IP\n\n### Futures Market Info\n\nGet basic market information for all symbols or a specific one.\n\n*   **All Symbols:** `GET /v1/public/futures`\n*   **Single Symbol:** `GET /v1/public/futures/{symbol}`\n*   **Rate Limit:** 10 requests/second per IP\n\n### Index Price Sources\n\nRetrieve the sources used for index prices.\n\n*   **Endpoint:** `GET /v1/public/index_price_source`\n*   **Rate Limit:** 10 requests/second per IP\n\n## Order Rules and Validation\n\nBefore placing an order, you should validate price and size constraints against the market's rules.\n\n*   **Endpoint:** `GET /v1/public/info/{symbol}`\n*   **Rate Limit:** 10 requests/second per IP\n\n**Enforce these filters:**\n\n*   **Price Filter:**\n    *   `price >= quote_min`\n    *   `price <= quote_max`\n    *   `(price - quote_min) % quote_tick == 0`\n    *   If BUY: `price <= mark_price * (1 + price_range)`\n    *   If SELL: `price >= mark_price * (1 - price_range)`\n\n*   **Size Filter:**\n    *   `base_min <= quantity <= base_max`\n    *   `(quantity - base_min) % base_tick == 0`\n\n*   **Min Notional:**\n    *   `price * quantity > min_notional`\n\n## Funding Rates\n\n### Predicted Funding Rate (All Markets)\n\n*   **Endpoint:** `GET /v1/public/funding_rates`\n*   **Rate Limit:** 10 requests/second per IP\n\nReturns:\n*   `last_funding_rate`: Latest hourly funding rate.\n*   `est_funding_rate`: Rolling average over the last 8 hours.\n\n### Predicted Funding Rate (Single Market)\n\n*   **Endpoint:** `GET /v1/public/funding_rate/{symbol}`\n*   **Rate Limit:** 30 requests/second per IP\n\n## Market Statistics\n\n### Price Changes\n\nGet current price and historical reference prices (5m, 30m, 1h, 24h, 3d, 7d, 30d).\n\n*   **Endpoint:** `GET /v1/public/market_info/price_changes`\n*   **Rate Limit:** 10 requests/second per IP\n\n### Open Interest\n\nRetrieve long/short open interest for all symbols (excluding market makers).\n\n*   **Endpoint:** `GET /v1/public/market_info/traders_open_interests`\n*   **Rate Limit:** 10 requests/second per IP\n\n### Market Trades\n\nGet the latest public trades.\n\n*   **Endpoint:** `GET /v1/public/market_trades`\n*   **Rate Limit:** 10 requests/second per IP\n\n## Historical Data (Klines)\n\n### Kline History\n\n*   **Endpoint:** `GET /v1/tv/kline_history`\n*   **Rate Limit:** 5 requests per 10 seconds per IP\n\n### TradingView Integration\n\n*   **History:** `GET /v1/tv/history?symbol={}&resolution={}&from={}&to={}`\n*   **Config:** `GET /v1/tv/config`\n*   **Symbol Info:** `GET /v1/tv/symbol_info`\n*   **Rate Limit:** 10 requests/second per IP\n\n## Staking and Strategy Vaults\n\n### VALOR Staking\n\n*   **Batch Info:** `GET /v1/staking/valor/batch_info`\n*   **Pool Info:** `GET /v1/staking/valor/pool_info`\n\n### VALOR2 Staking\n\n*   **Batch Info:** `GET /v1/staking/valor2/batch_info`\n*   **Pool Info:** `GET /v1/staking/valor2/pool_info`\n*   **Redeem Info:** `GET /v1/staking/valor2/redeem`\n*   **Revenue Buyback:** `GET /v1/staking/valor2/revenue_buyback`\n\n### Strategy Vault\n\n*   **Nonce:** `GET /v1/public/sv_nonce`\n*   **Operation Request:** `POST /v1/sv_operation_request`\n\nAll staking endpoints are rate-limited to 10 requests/second per IP.",
      "keywords": ["public API", "market data", "funding rates", "order rules", "klines"]
    },
    {
      "id": "api-45",
      "title": "SDK Integration: React Hooks and Utilities",
      "category": "SDK",
      "content": "The Orderly Network SDK provides React hooks and utilities to simplify integration with the API and WebSocket streams. This guide covers the most commonly used hooks for data fetching, state management, and subscriptions.\n\n## Data Fetching with SWR\n\nThe SDK uses SWR (Stale-While-Revalidate) for data fetching.\n\n### Public Queries\n\nUse `useQuery` for public API endpoints.\n\n```tsx\nimport { useQuery } from \"@orderly.network/hooks\";\n\nconst { data, error, isLoading } = useQuery<API.Symbol[]>(\"/v1/public/info\");\n```\n\n### Private Queries\n\nUse `usePrivateQuery` for authenticated endpoints.\n\n```tsx\nimport { usePrivateQuery } from \"@orderly.network/hooks\";\n\nconst { data } = usePrivateQuery<Account>(\"/v1/client/account\");\n```\n\n### Lazy Fetching\n\nUse `useLazyQuery` to fetch data on demand (e.g., on button click).\n\n```tsx\nconst { data, trigger } = useLazyQuery<API.Symbol[]>(\"/v1/public/info\");\n\n// Call trigger() when needed\n<button onClick={() => trigger()}>Fetch Info</button>\n```\n\n### Infinite Queries\n\nFor paginated data, use `usePrivateInfiniteQuery`.\n\n```tsx\nconst { data, size, setSize } = usePrivateInfiniteQuery(\n  (index) => `/v1/trades?page=${index}`,\n  {\n    formatter: (data) => data.rows // Transform data if needed\n  }\n);\n```\n\n## WebSocket Subscriptions\n\n### Market Data Streams\n\n**Index Price:**\n```tsx\nconst indexPrice = useIndexPrice(\"PERP_ETH_USDC\");\n```\n\n**Mark Price:**\n```tsx\nconst markPrice = useMarkPrice(\"PERP_ETH_USDC\");\n```\n\n**Market Trades:**\n```tsx\nconst { data, isLoading } = useMarketTradeStream(\"PERP_BTC_USDC\");\n// data is an array of Trade objects: { price, side, size, ts }\n```\n\n**All Tickers:**\n```tsx\nconst { data } = useMarketsStream();\n// data is Ticker[] | null\n```\n\n### Private Data Streams\n\n**Positions:**\n```tsx\nconst [positions, info] = usePositionStream();\n// positions: { rows, aggregated, totalCollateral, totalValue, totalUnrealizedROI }\n// info: { margin_ratio, total_collateral_value, rows, ... }\n```\n\n**Holdings:**\n```tsx\nconst { usdc } = useHoldingStream();\n// Returns token object with holding, frozen, pending_short, etc.\n```\n\n**Wallet:**\n```tsx\nuseWalletSubscription({\n  onMessage: (data) => {\n    console.log(\"Wallet update:\", data);\n  }\n});\n```\n\n**PnL Settlement:**\n```tsx\nuseSettleSubscription({\n  onMessage: (data) => {\n    if (data.status === \"COMPLETED\") {\n      // Handle completion\n    }\n  }\n});\n```\n\n## Order Management Hooks\n\n### Order Stream\n\n`useOrderStream` provides a comprehensive interface for managing orders.\n\n```tsx\nconst {\n  data, // Orders list\n  isLoading,\n  actions: {\n    cancelAllOrders,\n    submitting, // { cancelOrder, updateOrder, ... }\n    errors // { cancelOrder, updateOrder, ... }\n  }\n} = useOrderStream();\n\n// Cancel all\nawait cancelAllOrders();\n```\n\n## Wallet and Account\n\n### Account Connection\n\nUse `useAccount` to manage wallet connection and signing.\n\n```tsx\nconst { account } = useAccount();\n\n// Set address for EVM or Solana\naccount.setAddress(address, {\n  provider: walletProvider,\n  chain: {\n    id: chainId,\n    namespace: \"EVM\" // or \"SOL\"\n  },\n  wallet: { name: \"MetaMask\" }\n});\n```\n\n### Deposit Flow\n\n`useDeposit` handles token approvals and balance fetching.\n\n```tsx\nconst {\n  approve,\n  allowance,\n  isNativeToken,\n  fetchBalances\n} = useDeposit();\n\n// Approve token\nawait approve(\"1000000\");\n```\n\n## Utilities\n\n### Storage Hooks\n\nPersist UI state easily.\n\n```tsx\n// Local Storage\nconst [needConfirm, setNeedConfirm] = useLocalStorage(\"CONFIRM_ORDER\", true);\n\n// Session Storage\nconst [sessionVal, setSessionVal] = useSessionStorage(\"TEMP_KEY\", false);\n```\n\n### Throttle and Debounce\n\n```tsx\nconst throttledFn = useThrottledCallback(() => {\n  console.log(\"Throttled\");\n}, 500);\n\nconst debouncedFn = useDebouncedCallback(() => {\n  console.log(\"Debounced\");\n}, 300);\n```",
      "keywords": ["SDK", "React hooks", "WebSocket", "SWR", "useQuery"]
    },
    {
      "id": "api-46",
      "title": "Trading Mechanics: Fees, Funding, and Liquidation",
      "category": "Trading",
      "content": "Understanding the underlying mechanics of trading on Orderly Network is crucial for building robust applications. This section covers fee structures, funding rates, and liquidation processes.\n\n## Trading Fees\n\nFees are determined by whether an order adds or removes liquidity.\n\n*   **Maker Fee:** Applied to orders that add liquidity (e.g., limit orders resting on the book).\n*   **Taker Fee:** Applied to orders that remove liquidity (e.g., market orders).\n\nFor perpetual futures, fees are charged after every trade in USDC and added to the cost basis of the position.\n\n## Funding Rates\n\nFunding rates ensure the perpetual price stays close to the spot price.\n\n### Formula Components\n\n1.  **Interest Rate Adjustment:**\n    `clamp(Interest Rate - Average Premium, cap_ir, floor_ir) / (8/N)`\n    *   `N`: Funding interval (e.g., 8 hours).\n    *   `cap_ir` / `floor_ir`: Market-specific interest rate bounds.\n\n2.  **Final Capping:**\n    The combined result is clamped to the market's `Cap Funding` and `Floor Funding`.\n\n### Example Parameters (BTC/ETH Perp)\n\n*   **Interval:** 8 hours\n*   **Cap Funding:** 0.3000%\n*   **Floor Funding:** -0.3000%\n*   **Interest Rate:** 0.01000%\n*   **Cap IR:** 0.04%\n*   **Floor IR:** -0.04%\n\n### Fetching Funding Rates\n\n*   **REST:** `GET /v1/public/funding_rates` or `GET /v1/public/funding_rate/{symbol}`\n*   **WebSocket:** Subscribe to `estfundingrate` or `{symbol}@estfundingrate`.\n\n## Margin and Leverage\n\n### Initial Margin Ratio (IMR)\n\nIMR determines the required collateral for a position.\n\n`IMR_i = Max(1 / Max Account Leverage, Base IMR_i, IMR Factor_i * Abs(Position Notional_i)^(4/5))`\n\n*   **Base IMR:** The base margin requirement for the market.\n*   **IMR Factor:** Scales margin requirement for large positions (reduces effective leverage as size grows).\n\n### Position Mode\n\nOrderly currently supports **One-Sided Position Mode**. Traders cannot hold both long and short positions for the same perpetual contract simultaneously.\n\n## Liquidation\n\n### Liquidation Process\n\nIf a position's margin falls below the maintenance margin requirement, it becomes eligible for liquidation.\n\n1.  **Insurance Fund:** Absorbs losses from bankrupt accounts.\n2.  **Liquidators:** Can claim positions held by the Insurance Fund at a discount (slightly less than the liquidator fee).\n\n### Liquidation Streams\n\n*   **Public:** `liquidation` topic via WebSocket.\n*   **Private:** `liquidationsaccount` (user's liquidations) and `liquidatorliquidations` (for liquidators) topics.\n\n## Price Sources\n\nOrderly uses a primary oracle for pricing and **Stork** as a backup to verify index prices. Stork provides ultra-low-latency, decentralized price feeds for real-time verification.\n\n## PnL and Balance\n\n### Settling PnL\n\nSettling PnL moves realized profits/losses from unsettled PnL to the available balance.\n\n*   **Effect on UI:** The displayed balance *already* includes unsettled PnL, so settling does not change the total balance shown in the UI.\n*   **Effect on Withdrawals:** Settling is required to make profits withdrawable, as withdrawable balance excludes unsettled profits.\n\n### Calculating Totals\n\nTo calculate total notional or unrealized PnL across positions:\n\n```ts\nimport { totalNotional, totalUnrealizedPnL } from \"@orderly.network/utils\";\n\nconst notional = totalNotional(positions);\nconst pnl = totalUnrealizedPnL(positions);\n```",
      "keywords": ["funding rates", "trading fees", "liquidation", "margin", "IMR"]
    },
    {
      "id": "api-47",
      "title": "Chain Configuration and RPC Setup",
      "category": "Infrastructure",
      "content": "When integrating with Orderly Network, configuring the blockchain connection correctly is essential. The `ChainConfig` interface defines the structure for supported chains, including RPC endpoints, native currency details, and gas thresholds.\n\n### ChainConfig Structure\n\nThe `ChainConfig` object includes the following fields:\n\n- `id: number`: Chain identifier.\n- `chainName: string`: Full name of the chain.\n- `chainNameShort: string`: Short name or abbreviation.\n- `chainLogo: string`: URL to the chain's logo.\n- `blockExplorerName: string`: Name of the block explorer.\n- `requestRpc: string`: A single RPC endpoint string used for requests. This is separate from the list of RPCs in `chainInfo`.\n- `chainInfo: ChainInfo`: Detailed chain information.\n- `minGasBalance: number`: Minimum gas balance required.\n- `minCrossGasBalance: number`: Minimum gas balance for cross-chain operations.\n- `maxPrepayCrossGas: number`: Maximum gas to prepay for cross-chain transactions.\n\n### ChainInfo Details\n\nThe `chainInfo` object contains:\n\n- `chainId: string`: The chain ID (e.g., \"0x1\" for Ethereum Mainnet).\n- `chainName: string`: Name of the chain (default \"Polygon\").\n- `rpcUrls: string[]`: An array of RPC endpoint URLs for the chain.\n- `blockExplorerUrls: string[]`: URLs for the block explorer.\n- `nativeCurrency: NativeCurrency`: Details about the native token.\n\n### Native Currency Configuration\n\nThe `nativeCurrency` object defines the native token properties:\n\n```typescript\n{\n  decimals: number; // Default 18\n  fix: number;      // Default 4\n  name: string;     // Default \"ETH\"\n  symbol: string;   // Default \"ETH\"\n}\n```\n\n### Specifying RPC Endpoints\n\nYou must provide RPC endpoints in two places depending on the use case:\n\n1. **General RPCs**: Use `chainInfo.rpcUrls` to provide a list of endpoints for general interaction.\n   ```typescript\n   chainInfo: {\n     rpcUrls: [\"https://rpc.ankr.com/eth\", \"https://eth.llamarpc.com\"]\n   }\n   ```\n\n2. **Request RPC**: Use `requestRpc` to specify a single endpoint dedicated to request operations.\n   ```typescript\n   requestRpc: \"https://rpc.ankr.com/eth\"\n   ```\n\n### Common Issues\n\n- **Connection Failures**: Ensure the URLs provided in `rpcUrls` and `requestRpc` are accessible and support the required methods.\n- **Gas Errors**: Verify `minGasBalance` and `minCrossGasBalance` are sufficient for the network conditions to prevent transaction failures.",
      "keywords": ["ChainConfig", "RPC", "chainInfo", "nativeCurrency", "gas configuration"]
    },
    {
      "id": "api-48",
      "title": "Core API Types and Interfaces",
      "category": "API",
      "content": "Orderly Network provides a comprehensive set of TypeScript types under the `@orderly.network/types` package, specifically within the `API` namespace. These types model the entities returned by REST and WebSocket endpoints, ensuring type safety across your integration.\n\n### Trading Objects\n\n#### Orders\n\n- `API.Order`: Base order structure containing fields like `symbol`, `order_id`, `price`, `quantity`, `status`, `side`, `reduce_only`, and timestamps (`created_time`, `updated_time`).\n- `API.OrderExt`: Extends `API.Order` by adding `mark_price: string`.\n- `API.OrderResponse`: Represents a paginated response containing `meta` (pagination info) and `rows` (an array of `Order` or `AlgoOrder`).\n- `API.AlgoOrder`: Represents algorithmic orders with fields like `algo_order_id`, `algo_type`, `trigger_price`, `child_orders`, and `reduce_only`.\n- `API.AlgoOrderExt`: Extends `API.AlgoOrder` with `mark_price` and an optional `position` field.\n\n#### Positions\n\n- `API.Position`: Core position data including `symbol`, `position_qty`, `average_open_price`, `mark_price`, `unrealized_pnl`, `imr`, `mmr`, and `timestamp`.\n- `API.PositionExt`: Extends `API.Position` with additional fields like `notional`, `mm`, and margin ratios including orders (`IMR_withdraw_orders`, `MMR_with_orders`).\n- `API.PositionInfo`: Aggregates account-level margin info (e.g., `free_collateral`, `total_collateral_value`, `margin_ratio`) with a `rows` array of positions.\n- `API.PositionTPSLExt`: Extends `PositionExt` to include an optional `algo_order?: AlgoOrder` for Take Profit/Stop Loss details.\n\n#### Trades\n\n- `API.Trade`: Represents a trade execution with fields `symbol`, `side`, `executed_price`, `executed_quantity`, `executed_timestamp`, and `ts`.\n\n### Market Data\n\n- `API.Symbol`: Defines instrument metadata such as `symbol`, `base_tick`, `quote_tick`, `base_min`, `base_max`, `min_notional`, `funding_period`, and liquidation fees.\n- `API.SymbolExt`: Extends `API.Symbol` with display properties (`base_dp`, `quote_dp`), price constraints (`price_range`, `price_scope`), and interest rates.\n- `API.MarketInfo`: Provides real-time market stats including `index_price`, `mark_price`, `24h_open`, `24h_high`, `24h_low`, `24h_volumn`, and `open_interest` (typed as string).\n- `API.MarketInfoExt`: Extends `MarketInfo` with `24h_volume` and `change`.\n- `API.FundingRate`: Contains funding data like `est_funding_rate`, `last_funding_rate`, `next_funding_time`, and `sum_unitary_funding`.\n\n### Account and Chain\n\n- `API.Chain`: Describes chain metadata including `token`, `decimals`, `minimum_withdraw_amount`, `network_infos`, and `chain_details`.\n- `API.ChainDetail`: Specifics for a chain instance like `chain_id`, `contract_address`, `withdrawal_fee`, and `decimals`.\n- `API.Holding`: Represents asset holdings with `token`, `holding`, `frozen`, and `pending_short` amounts.\n- `API.TokenInfo`: Basic token info: `address`, `symbol`, `decimals`, `display_name`.\n\n### Usage Example\n\n```typescript\nimport { API } from \"@orderly.network/types\";\n\nfunction processOrder(order: API.Order) {\n  console.log(`Order ${order.order_id} for ${order.symbol} is ${order.status}`);\n  if (order.reduce_only) {\n    console.log(\"This is a reduce-only order.\");\n  }\n}\n\nfunction displayMarketInfo(info: API.MarketInfo) {\n  console.log(`Mark Price: ${info.mark_price}`);\n  console.log(`24h Volume: ${info[\"24h_volumn\"]}`);\n  // Note: open_interest is a string, parse if needed for math\n  const oi = parseFloat(info.open_interest);\n}\n```",
      "keywords": [
        "TypeScript types",
        "API interfaces",
        "Orders",
        "Positions",
        "Market data",
        "Symbol"
      ]
    },
    {
      "id": "api-49",
      "title": "WebSocket Client Integration",
      "category": "API",
      "content": "The Orderly Network WebSocket client (`WS`) enables real-time data streaming for both public market data and private account updates. It manages separate connections for public and private channels, handling reconnection, authentication, and subscription queuing automatically.\n\n### Initialization and Connection\n\nThe client maintains distinct sockets for public and private data.\n\n- **Public Connection**: Established automatically upon initialization for market data.\n- **Private Connection**: Requires authentication and is opened explicitly for account-specific data.\n\n### Opening a Private Connection\n\nTo access private channels (e.g., account updates, private orders), you must open the private socket and authenticate.\n\n```typescript\nimport { WS } from \"@orderly.network/websocket\";\n\nconst ws = new WS();\n\n// Set the account ID\nws.accountId = \"your-account-id\";\n\n// Open the private connection (triggers authentication)\nws.openPrivate(\"your-account-id\");\n```\n\n### Subscribing to Topics\n\nThe client provides methods to subscribe to topics. You can subscribe to public topics (e.g., tickers) or private topics (e.g., execution reports).\n\n#### Public Subscription\n\n```typescript\nws.subscribe(\n  { topic: \"tickers\", symbol: \"PERP_BTC_USDC\" },\n  {\n    onMessage: (msg) => {\n      console.log(\"Ticker update:\", msg);\n    },\n    onUnsubscribe: (event) => {\n      console.log(\"Unsubscribed from tickers\", event);\n    },\n  }\n);\n```\n\n#### Private Subscription\n\n```typescript\nconst unsubscribe = ws.privateSubscribe(\n  { topic: \"executionreport\" },\n  {\n    onMessage: (msg) => {\n      console.log(\"Order update:\", msg);\n    },\n  }\n);\n\n// Call unsubscribe() to stop listening\n// unsubscribe();\n```\n\n### One-time Subscriptions\n\nFor scenarios where you only need a single message, use `onceSubscribe`.\n\n```typescript\nws.onceSubscribe(\n  { topic: \"markprice\", symbol: \"PERP_ETH_USDC\" },\n  {\n    onMessage: (msg) => {\n      console.log(\"Received mark price once:\", msg);\n    },\n  }\n);\n```\n\n### Advanced Features\n\n#### Custom Subscription ID\n\nYou can pass a custom ID to track subscriptions.\n\n```typescript\nws.subscribe(\n  { topic: \"orderbook\", symbol: \"PERP_SOL_USDC\" },\n  { onMessage: (msg) => {} },\n  false, // once\n  \"custom-sub-id\" // id\n);\n```\n\n#### Event Emission\n\nThe client includes an internal event system for custom events.\n\n```typescript\nws.emit(\"custom_event\", { data: \"value\" });\n\nws.on(\"custom_event\", (data) => {\n  console.log(\"Custom event received:\", data);\n});\n```\n\n#### Reconnection Logic\n\nThe client automatically handles reconnections using `checkSocketStatus`. It monitors heartbeat timers and network status. You can configure the `reconnectInterval` (default 1000ms).\n\n### Lifecycle Management\n\nTo close connections:\n\n```typescript\n// Close private socket specifically\nws.closePrivate(1000, \"User logged out\");\n\n// Close all sockets\nws.close();\n```",
      "keywords": ["WebSocket", "real-time", "subscription", "authentication", "reconnection"]
    },
    {
      "id": "api-50",
      "title": "Strategy Vault API",
      "category": "API",
      "content": "The Strategy Vault API provides endpoints to manage and query data for Strategy Providers (SP) and Liquidity Providers (LP). These endpoints allow you to fetch performance metrics, transaction histories, and vault-specific data.\n\n### Liquidity Provider (LP) Endpoints\n\nThese endpoints are public and allow querying LP-related data.\n\n#### Fee History\n\nFetch the fee history for a liquidity provider.\n\n```http\nGET /v1/public/strategy_vault/lp/fees_history\n```\n\n#### Claimable Assets\n\nGet claimable asset info for processed withdrawals.\n\n```http\nGET /v1/public/strategy_vault/lp/claim_info\n```\n\n#### LP Info\n\nRetrieve general information about a liquidity provider.\n\n```http\nGET /v1/public/strategy_vault/lp/info\n```\n\n#### Performance Metrics\n\nFetch performance metrics for a vault.\n\n```http\nGET /v1/public/strategy_vault/lp/performance\n```\n\n#### Performance Chart\n\nGet TVL/PnL history chart data.\n\n```http\nGET /v1/public/strategy_vault/lp/performance_chart\n```\n\n#### Transaction History\n\nRetrieve the transaction history for a liquidity provider.\n\n```http\nGET /v1/public/strategy_vault/lp/transaction_history\n```\n\n### Strategy Provider (SP) Endpoints\n\n#### Add Orderly Key (Private)\n\nAdd an Orderly access key to a Strategy Provider account.\n\n```http\nPOST /v1/sv/sp_orderly_key\n```\n*Rate Limit: 10 requests/second*\n\n#### Settle PnL (Private)\n\nRequest PnL settlement for a Strategy Provider account.\n\n```http\nPOST /v1/sv/sp_settle_pnl\n```\n*Rate Limit: 1 request/second*\n\n#### SP Info (Public)\n\nFetch public information about Strategy Providers.\n\n```http\nGET /v1/public/strategy_vault/sp/info\n```\n\n#### SP Claim Info (Public)\n\nGet the claimable amount for a Strategy Provider.\n\n```http\nGET /v1/public/strategy_vault/sp/claim_info\n```\n\n#### SP Transaction History (Public)\n\nRetrieve the transaction history for a Strategy Provider.\n\n```http\nGET /v1/public/strategy_vault/sp/transaction_history\n```\n\n### Vault Endpoints\n\n#### Vault Info\n\nFetch metadata and info for a specific vault.\n\n```http\nGET /v1/public/strategy_vault/vault/info\n```\n\n#### Liquidator History\n\nQuery liquidation history for a vault.\n\n```http\nGET /v1/public/strategy_vault/vault/liquidator_history\n```\n\n#### Open Orders\n\nGet open orders for a vault, including algo orders.\n\n```http\nGET /v1/public/strategy_vault/vault/open_orders\n```\n\n#### Overall Info\n\nFetch overall statistics across all Strategy Vaults.\n\n```http\nGET /v1/public/strategy_vault/vault/overall_info\n```\n\n#### Vault Performance\n\nRetrieve performance data for a vault.\n\n```http\nGET /v1/public/strategy_vault/vault/performance\n```\n\n#### Vault Performance Chart\n\nGet TVL/PnL history chart series for a vault.\n\n```http\nGET /v1/public/strategy_vault/vault/performance_chart\n```\n\n#### Vault Positions\n\nQuery current positions held by a vault.\n\n```http\nGET /v1/public/strategy_vault/vault/positions\n```\n\n#### Vault Trade History\n\nRetrieve the trade history for a vault.\n\n```http\nGET /v1/public/strategy_vault/vault/trade_history\n```\n\n### User Statistics\n\n#### User Overall Info\n\nGet a user's overall statistics across Strategy Vaults.\n\n```http\nGET /v1/public/strategy_vault/user/overall_info\n```",
      "keywords": [
        "Strategy Vault",
        "Liquidity Provider",
        "Strategy Provider",
        "performance",
        "vault API"
      ]
    },
    {
      "id": "api-51",
      "title": "Trading API Enhancements and Features",
      "category": "Trading",
      "content": "Orderly Network continuously updates its trading API to provide more control and better execution. This section covers recent enhancements to order placement, market data, and account management.\n\n### Order Placement Enhancements\n\n#### Order Book Level Pricing\n\nWhen placing an order via `POST /v1/order`, you can now derive the price from specific order book levels (bid0-bid4 or ask0-ask4) using the `level` parameter.\n\n```json\n{\n  \"symbol\": \"PERP_BTC_USDC\",\n  \"side\": \"BUY\",\n  \"order_type\": \"LIMIT\",\n  \"quantity\": 0.1,\n  \"level\": \"bid0\"\n}\n```\n\n#### Post-Only Adjustment\n\nTo prevent `POST_ONLY` orders from crossing the spread, enable automatic price adjustment. Set `post_only_adjust: true` in the request body. The system adjusts the price to 1 tick close to the current best price.\n\n```json\n{\n  \"symbol\": \"PERP_ETH_USDC\",\n  \"side\": \"SELL\",\n  \"order_type\": \"LIMIT\",\n  \"post_only\": true,\n  \"post_only_adjust\": true,\n  \"quantity\": 1.0\n}\n```\n\n#### Max Slippage for Market Orders\n\nConstrain market order execution relative to the order book mid-price using the Max Slippage setting.\n\n- **Buy Orders**: Fills occur only at prices > (mid-price - slippage). Remaining quantity is canceled.\n- **Sell Orders**: Fills occur only at prices < (mid-price + slippage). Remaining quantity is canceled.\n\n#### Realized PnL in Order Responses\n\nOrder APIs now return `realized_pnl` for orders that close or reduce positions. No separate endpoint is needed; simply consume the new field in the standard order response.\n\n### Market Data and Discovery\n\n#### Broker Discovery\n\nBrokers are now chain-specific. To discover supported brokers per chain:\n\n```http\nGET /v1/public/chain_info\n```\n\nTo retrieve all brokers a specific address has registered with:\n\n```http\nGET /v1/get_broker\n```\n\n#### Filtering by Order Tag\n\nYou can now filter orders and algo orders using the `order_tag` query parameter.\n\n```http\nGET /v1/orders?order_tag=my_strategy_tag\nGET /v1/algo/orders?order_tag=my_strategy_tag\n```\n\n### Platform Updates\n\n#### Batch Leverage Update\n\nLeverage can now be updated in batches. This functionality was introduced to improve efficiency when managing multiple positions.\n\n#### WebSocket Symbol Filtering\n\nWebSocket execution reports can now be filtered by symbol, reducing bandwidth and client-side processing overhead.\n\n### Referral and Rewards\n\n#### Referral Rebate Summary\n\nThe `GET /v1/referral/rebate_summary` endpoint now includes a `traded_referral` field to track referral trades during the specified date.\n\n#### Market Making Rewards\n\nThe `GET v1/public/market_making_rewards/leaderboard` endpoint has been updated to support all markets and includes an `est_score` field in the response.",
      "keywords": ["order placement", "slippage", "post-only", "realized PnL", "broker discovery"]
    },
    {
      "id": "api-52",
      "title": "Order Management and Algo Trading APIs",
      "category": "API",
      "content": "This guide covers the REST APIs for standard order operations (bulk creation, editing, cancellation) and the advanced Algo Order system supporting Take Profit (TP) and Stop Loss (SL).\n\n## Standard Order Operations\n\n### Bulk and Batch Operations\nTo optimize efficiency, use the bulk and batch endpoints instead of looping single requests.\n\n*   **Bulk Order Creation:** Submit multiple orders in a single request.\n*   **Batch Cancel:** Cancel multiple orders at once using either exchange order IDs or `client_order_id`.\n\n### Editing Orders\nYou can modify existing order parameters without canceling and re-placing them using the Edit Order API.\n\n### Reduce-Only Orders\nThe minimum order size requirement has been removed for reduce-only orders, allowing for precise position closing.\n\n## Algo Orders (TP/SL)\n\nAlgo orders support Stop Loss and Take Profit strategies. These orders auto-cancel if the position is closed.\n\n### Management Modes\n1.  **Full/Entire Position TP/SL:** Applies to the whole position. Maximum of 1 TP and 1 SL order per position.\n2.  **Partial Position TP/SL:** Specifies a specific amount to close. Maximum of 10 partial TP and 10 partial SL orders on each side.\n\n### Supported Endpoints\n*   `GET /v1/algo/order`: Create algo order.\n*   `PUT /v1/algo/order`: Edit algo order.\n*   `DELETE /v1/algo/order`: Cancel algo order.\n\n### Code Example: Creating a Partial TP/SL Order\n```json\nPOST /v1/algo/order\n{\n  \"symbol\": \"PERP_BTC_USDC\",\n  \"side\": \"BUY\",\n  \"order_type\": \"LIMIT\",\n  \"trigger_price\": \"50000\",\n  \"algo_type\": \"TAKE_PROFIT\",\n  \"quantity\": \"0.1\",\n  \"reduce_only\": true\n}\n```\n\n### Common Issues\n*   **Trigger Price Options:** Currently, Mark Price is supported for triggers. Last Price and Index Price support is planned for future expansion.\n*   **Limits:** Ensure you do not exceed the 10-order limit for partial TP/SL strategies.",
      "keywords": [
        "algo orders",
        "take profit",
        "stop loss",
        "bulk orders",
        "batch cancel",
        "edit order",
        "reduce-only"
      ]
    },
    {
      "id": "api-53",
      "title": "Broker Volume and Referral System APIs",
      "category": "API",
      "content": "This section details how to query broker-specific metrics, manage referral codes, and track rebate metrics.\n\n## Broker Volume Data\n\n### REST API\nRetrieve daily broker volume with maker/taker breakdown, order_tag filtering, and total fees collected.\n\n**Endpoint:** `GET /v1/volume/broker/daily`\n\n*   **Frequency:** Updated hourly (increased from daily).\n*   **Features:** Includes address, broker rebate, and supports filtering by `broker_id` and `order_tag`.\n\n### WebSocket Topics\nSubscribe to specific topics for real-time per-broker volume data per market.\n*   Topic: `{broker_id}${symbol}@ticker`\n*   Topic: `{broker_id}$tickers`\n\n## Referral System\n\n### Managing Referral Codes\nUse private REST endpoints to generate and manage personalized referral codes.\n**Endpoint:** `POST /v1/private/create-referral-code`\n\n### Referral Metrics\nRetrieve detailed rebate information for both referrers and referees.\n\n**Get Referral Info:** `GET /v1/referral/info`\nReturns:\n*   **Referrer:** `1d_referrer_rebate`, `7d_referrer_rebate`, `30d_referrer_rebate`, `total_referrer_rebate`.\n*   **Referee:** `1d_referee_rebate`, `7d_referee_rebate`, `30d_referee_rebate`, `total_referee_rebate`.\n\n**Get Rebate Summary:** `GET /v1/referral/rebate_summary`\nReturns volume and fees of all referees for the specific referral code.\n\n### Code Example: Fetching Referral Info\n```bash\ncurl -X GET \"https://api.orderly.org/v1/referral/info\" \\\n  -H \"Authorization: Bearer <your_jwt_token>\"\n```",
      "keywords": [
        "broker volume",
        "referral system",
        "rebate metrics",
        "referral codes",
        "websocket ticker",
        "broker fees"
      ]
    },
    {
      "id": "api-54",
      "title": "Account Management, Fees, and Security",
      "category": "API",
      "content": "Documentation for managing user accounts, setting custom fees, implementing delegate signers, and securing API keys.\n\n## Account and User Data\n\n### Key Endpoints\n*   **Account Details:** `GET /v1/public/account`\n*   **User Statistics:** `GET /v1/client/statistics/daily`\n*   **User Fee Tier:** `GET /v1/broker/user_info`\n\n### Symbol Naming Update\nThe `symbol` field in user info APIs now uses perp symbols (e.g., `PERP_BTC_USDC`) instead of base assets (e.g., `BTC`).\n\n## Fee Management\n\n### Custom Fee Rates\nBrokers can set custom trading fees for users.\n**Endpoint:** `POST /v1/private/update-user-fee-rate`\n\n### Deprecated Fee Tier Sources\nAvoid using the following deprecated sources for fee tiers:\n*   `GET /v1/public/fee_futures/program`\n*   `GET /v1/broker/user_info` (for fee tiers specifically)\n*   Account WebSocket topic (for fee tiers)\n\n## Security: Delegate Signer & Keys\n\n### Delegate Signer\nAllows smart contracts to trade by assigning an Externally Owned Account (EOA) to sign trades via EIP-712 signatures.\n*   **REST API:** Refer to `/build-on-omnichain/evm-api/restful-api/public/delegate-signer`.\n*   **Implementation:** Implement the on-chain Delegate Signer function.\n\n### Key Management\n*   **Orderly Key Creation:** A `tag` parameter is now available when adding an Orderly Key.\n*   **IP Restrictions:** Use endpoints to query and manage IP allowlists for Trading Keys. You can enforce that keys are only usable from specific IP addresses.\n\n## System Maintenance\n\n### Maintenance Status\nCheck if the platform is under maintenance:\n**Endpoint:** `GET /v1/system/maintenance_status`\n\n### Maintenance Configuration\nControl whether orders are automatically canceled during maintenance mode via the configuration endpoint.",
      "keywords": [
        "account management",
        "custom fees",
        "delegate signer",
        "IP restrictions",
        "trading keys",
        "maintenance mode",
        "EIP-712"
      ]
    },
    {
      "id": "api-55",
      "title": "Market Data and Funding Rate APIs",
      "category": "API",
      "content": "Access comprehensive market metadata, token information, and futures funding data.\n\n## General Market Data\n\n### Token Info\nRetrieve token metadata required for deposits/withdrawals and UI display.\n**Endpoint:** `GET /v1/public/token`\n\n### Broker Details\nQuery broker details publicly without authentication.\n**Endpoint:** `GET /v1/public/broker_details`\n\n## Futures Market Data\n\n### Market Info\n*   **All Markets:** `GET /v1/futures/info`\n*   **Single Market:** `GET /v1/futures/info?symbol=PERP_BTC_USDC`\n\n### Fee Information\nAccess futures fee information via the dedicated futures fee endpoint. Note that the public fee information endpoint path has been updated.\n\n## Funding Rates\n\n### Endpoints\n*   **Predicted Funding (All):** Get predicted rates for all markets.\n*   **Predicted Funding (One):** Get predicted rate for a specific market.\n*   **Funding History:** Get historical funding rates.\n*   **Hourly History:** Get granular hourly funding history for a specific market.\n\n### Code Example: Fetching Token Info\n```bash\ncurl -X GET \"https://api.orderly.org/v1/public/token\"\n```\n\n### Common Issues\n*   **Root Domain:** Ensure all REST API requests use the `orderly.org` root domain. Update any integrations pointing to the old domain.",
      "keywords": [
        "market data",
        "funding rates",
        "token info",
        "futures info",
        "broker details",
        "predicted funding"
      ]
    },
    {
      "id": "api-56",
      "title": "Asset Operations and Liquidation",
      "category": "API",
      "content": "Guides for handling deposits, withdrawals, insurance funds, and liquidation processes.\n\n## Deposits and Withdrawals\n\n### Fees and Parameters\n*   **Fees:** Deposits and withdrawals incur a fee to cover cross-chain message costs. Check `withdraw_fee` via `GET /v1/public/token`.\n*   **Withdrawal Request:** Use `POST /v1/withdraw_request` with the `allowCrossChainWithdrawal` parameter.\n\n### Status Updates\nWithdrawal requests may enter a `PENDING_REBALANCE` status, visible in both REST and WebSocket streams.\n\n### Troubleshooting Stuck Withdrawals\nIf a user reports a delayed withdrawal:\n1.  **Check Orderly Dashboard:** Verify on the [Orderly Dune Support Dashboard](https://dune.com/orderly_network/orderly-support-dashboard) if the withdrawal went through (user may have selected wrong chain).\n2.  **Check LayerZero:** Use [LayerZero Scan](https://layerzeroscan.com/) (Source: Orderly) to check for cross-chain message delays (allow 10+ minutes for in-flight messages).\n3.  **Contact Support:** If unresolved, provide user address, amount, and time to Orderly support. Note slower finality on chains like Polygon.\n\n## Liquidation and Insurance Fund\n\n### Liquidation Endpoints\n*   **Claim Liquidated Positions:** `POST /v1/liquidation`. Updated to include a `symbols` array and distinguish high/low risk perpetuals. Supports `limit_price`.\n*   **Get Liquidated Positions:** `GET /v1/liquidation/positions`. The `symbol` parameter is no longer required.\n\n### Insurance Fund\n*   **Claim:** Endpoint added to claim from the insurance fund.\n*   **Info:** `max_notional` and `futures_tier` parameters added to responses for Insurance Fund Info and Account Info.\n\n### Liquidation Model Updates\nSymbols now include a `liquidation_tier` parameter.",
      "keywords": [
        "withdrawals",
        "deposits",
        "liquidation",
        "insurance fund",
        "cross-chain",
        "LayerZero",
        "pending rebalance"
      ]
    },
    {
      "id": "api-57",
      "title": "Strategy Vault API Reference",
      "category": "API",
      "content": "API endpoints for managing Strategy Vaults, including fund transfers, fee history, and period management.\n\n## Fund Transfers and History\n\n### Inflow and Outflow\n*   **Venue Transfer History (Inflow):** `GET /v1/sv/venue_transfer_history` (Rate limit: 10 req/s per IP).\n*   **Venue Withdrawal History (Outflow):** `GET /v1/sv/venue_withdrawal_history` (Rate limit: 10 req/s per account).\n*   **Internal Transfer History:** `GET /v1/sv/internal_transfer_history`. Represents transfers from Non-Vault Accounts to Strategy Provider Accounts (Rate limit: 10 req/s per account).\n\n## Fees and Revenue\n\n*   **Liquidation Fees Share:** `GET /v1/sv/liquidation_fees_share_history` (Rate limit: 10 req/s per account).\n*   **Protocol Revenue Share:** `GET /v1/sv/protocol_revenue_share_history` (Rate limit: 10 req/s per account).\n*   **Strategy Provider Fees:** `GET /v1/public/strategy_vault/sp/fees_history` (Rate limit: 10 req/s per IP).\n\n## Fund Period Management\n\n### Public Information\n*   **Period Info:** `GET /v1/public/strategy_vault/fund/period_info` (Rate limit: 10 req/s per IP).\n*   **Pending Transactions:** `GET /v1/public/strategy_vault/fund/pending_transactions` (Rate limit: 10 req/s per IP).\n*   **Fund Info:** `GET /v1/public/strategy_vault/fund/info` (Rate limit: 10 req/s per IP).\n\n### Strategy Provider Actions\n*   **Manual Period Delivery:** `POST /v1/sv/manual_period_delivery` (Rate limit: 1 req/s per account).\n\n### Code Example: Fetching Period Info\n```bash\ncurl -X GET \"https://api.orderly.org/v1/public/strategy_vault/fund/period_info\"\n```",
      "keywords": [
        "strategy vault",
        "fund transfers",
        "revenue sharing",
        "period delivery",
        "fees history",
        "vault management"
      ]
    },
    {
      "id": "trading-58",
      "title": "Orderly Trading Architecture Overview",
      "category": "Overview",
      "content": "Orderly Network provides an orderbook-based trading infrastructure that powers decentralized exchanges (DEXs) and aggregators. Unlike a typical consumer-facing DEX product, Orderly acts as a backend liquidity layer, settling trades on-chain while maintaining an off-chain matching engine for performance.\n\n### Core Components\n\n1.  **Off-Chain Matching Engine**: Order execution happens in Orderly's backend, not directly on the blockchain. This allows for high throughput and low latency comparable to centralized exchanges (CEXs).\n2.  **Orderly L2 Settlement**: After a trade is matched, the result is recorded as a transaction on the Orderly Network chain (a Layer 2 solution). This serves as a ledger of record. Users do not need to wait for on-chain settlement to trade.\n3.  **Omnichain Liquidity**: Orderly unifies liquidity across multiple blockchains (e.g., Arbitrum, Optimism, Solana, Polygon) into a single orderbook. Traders on different supported chains share the same liquidity depth.\n4.  **Vault System**: Users deposit funds into an Orderly Vault contract on a supported chain. This triggers a cross-chain message (via LayerZero) to credit the user's off-chain trading account.\n\n### Trading Flow\n\n1.  **Deposit**: User sends funds (e.g., USDC) to the Vault contract on their chosen chain.\n2.  **Account Creation**: User registers an account and creates an Orderly Key (ed25519) for signing orders.\n3.  **Trading**: User signs orders with the Orderly Key. These are sent to the matching engine. No gas fees are paid for individual trades.\n4.  **Settlement**: Matched trades are batched and settled on the Orderly L2 chain.\n5.  **Withdrawal**: User requests a withdrawal, signs an EIP-712 message, and funds are released from the Vault to their wallet.\n\n### Key Characteristics\n\n*   **Gasless Trading**: Once funds are deposited and the Orderly Key is active, trading actions do not require gas fees.\n*   **Self-Custodial**: Users maintain control of their assets and private keys. Orderly does not custody funds directly.\n*   **Shared Orderbook**: All brokers (DEXs) built on Orderly share the same orderbook and liquidity.",
      "keywords": [
        "architecture",
        "matching engine",
        "settlement",
        "omnichain",
        "vault",
        "gasless trading"
      ]
    },
    {
      "id": "trading-59",
      "title": "Trading Fees, Broker Revenue, and Rebates",
      "category": "Trading",
      "content": "Orderly employs a fee structure that separates protocol revenue from broker revenue, allowing builders to customize fees for their users while sharing revenue with referrers.\n\n### Fee Structure\n\nThe total fee paid by a trader consists of two parts:\n\n1.  **Orderly Base Fee**: The fee retained by the Orderly protocol.\n    *   **Crypto Markets**: 0% Maker / 0.025% Taker (2.5 bps).\n    *   **RWA Markets**: 0% Maker / 0.045% Taker (4.5 bps).\n2.  **Broker Fee**: An additional fee set by the broker (builder) on top of the base fee. This is the broker's revenue.\n\n**Example Calculation (Crypto Market):**\n*   Orderly Base Taker Fee: 2.5 bps\n*   Broker Configured Taker Fee: 6.0 bps\n*   Total User Fee: 8.5 bps\n*   **Broker Net Revenue**: 6.0 - 2.5 = 3.5 bps\n\n### Broker Fee Distribution\n\n*   **Frequency**: Broker fees are aggregated and credited to the broker's admin wallet Orderly account once per day.\n*   **Collection**: Fees are collected at trade time. To receive rebates, the broker must have a registered admin wallet configured.\n*   **Withdrawal**: Brokers can withdraw accumulated fees from their Orderly account to an on-chain wallet via the standard withdrawal flow.\n\n### Referral System\n\nBrokers can incentivize user acquisition through a referral system that splits the broker's net revenue.\n\n1.  **Participants**:\n    *   **Broker**: Sets the maximum rebate limit (e.g., 80% of net fee).\n    *   **Referrer (Affiliate)**: Receives a share of the rebate.\n    *   **Referee (Trader)**: Receives a discount (rebate) on their fees.\n\n2.  **Rebate Split**:\n    Rebates are calculated from the **Broker Net Fee** (Total Fee - Orderly Base Fee).\n    *   *Example*: If Broker Net Fee is 3 bps and Max Rebate is 80%:\n        *   Total Rebate Pool: 2.4 bps.\n        *   If split is 50/50: Referrer gets 1.2 bps, Referee gets 1.2 bps.\n        *   Broker retains: 0.6 bps.\n\n3.  **Auto-Referral**:\n    Traders can be automatically assigned a referral code once they reach a specific trading volume threshold configured by the broker.\n\n### Tiered Fees\n\nBrokers can implement tiered fee structures (e.g., lower fees for higher volume). This is typically configured via a script run by the broker or set up by the Orderly team, rather than purely through the UI.",
      "keywords": ["fees", "rebates", "referral", "broker revenue", "tiered fees", "base fee"]
    },
    {
      "id": "trading-60",
      "title": "Advanced Order Types: Algo Orders (TP/SL, Bracket)",
      "category": "Trading",
      "content": "Orderly supports advanced algorithmic order types to manage risk automatically, including Stop-Loss (SL), Take-Profit (TP), and Bracket orders.\n\n### STOP Order\n\nTriggers a market or limit order when the mark price crosses a specified `trigger_price`.\n\n**Payload Example:**\n```json\n{\n  \"symbol\": \"PERP_NEAR_USDC\",\n  \"algo_type\": \"STOP\",\n  \"quantity\": \"5.5\",\n  \"side\": \"BUY\",\n  \"type\": \"LIMIT\",\n  \"trigger_price_type\": \"MARK_PRICE\",\n  \"trigger_price\": \"4.203\",\n  \"price\": \"3.5\"\n}\n```\n\n### TP_SL (Take-Profit / Stop-Loss)\n\nAllows setting both a TP and SL trigger for a specific quantity. Supports `LIMIT` or `MARKET` orders for the child legs.\n\n**Payload Example:**\n```json\n{\n  \"symbol\": \"PERP_NEAR_USDC\",\n  \"algo_type\": \"TP_SL\",\n  \"quantity\": 6,\n  \"trigger_price_type\": \"MARK_PRICE\",\n  \"child_orders\": [\n    {\n      \"symbol\": \"PERP_NEAR_USDC\",\n      \"algo_type\": \"TAKE_PROFIT\",\n      \"side\": \"SELL\",\n      \"type\": \"LIMIT\",\n      \"price\": 2.4,\n      \"trigger_price\": 2.3,\n      \"reduce_only\": true\n    },\n    {\n      \"symbol\": \"PERP_NEAR_USDC\",\n      \"algo_type\": \"STOP_LOSS\",\n      \"side\": \"SELL\",\n      \"type\": \"LIMIT\",\n      \"price\": 2.1,\n      \"trigger_price\": 1.9,\n      \"reduce_only\": true\n    }\n  ]\n}\n```\n\n### POSITIONAL_TP_SL\n\nAttaches TP/SL to an entire position rather than a specific order quantity. Only one untriggered `POSITIONAL_TP_SL` is allowed per user.\n\n**Payload Example:**\n```json\n{\n  \"symbol\": \"PERP_NEAR_USDC\",\n  \"algo_type\": \"POSITIONAL_TP_SL\",\n  \"trigger_price_type\": \"MARK_PRICE\",\n  \"child_orders\": [\n    {\n      \"symbol\": \"PERP_NEAR_USDC\",\n      \"algo_type\": \"TAKE_PROFIT\",\n      \"side\": \"SELL\",\n      \"type\": \"CLOSE_POSITION\",\n      \"trigger_price\": \"4.05\",\n      \"reduce_only\": true\n    },\n    {\n      \"symbol\": \"PERP_NEAR_USDC\",\n      \"algo_type\": \"STOP_LOSS\",\n      \"side\": \"SELL\",\n      \"type\": \"CLOSE_POSITION\",\n      \"trigger_price\": \"3.95\",\n      \"reduce_only\": true\n    }\n  ]\n}\n```\n\n### BRACKET Order\n\nA BRACKET order combines an entry order with attached TP/SL logic. It can wrap a `TP_SL` or `POSITIONAL_TP_SL`.\n\n**Payload Example (BRACKET with TP_SL):**\n```json\n{\n  \"symbol\": \"PERP_NEAR_USDC\",\n  \"algo_type\": \"BRACKET\",\n  \"quantity\": \"4\",\n  \"side\": \"BUY\",\n  \"type\": \"LIMIT\",\n  \"price\": 2.03,\n  \"child_orders\": [\n    {\n      \"symbol\": \"PERP_NEAR_USDC\",\n      \"algo_type\": \"TP_SL\",\n      \"child_orders\": [\n        {\n          \"symbol\": \"PERP_NEAR_USDC\",\n          \"algo_type\": \"TAKE_PROFIT\",\n          \"side\": \"SELL\",\n          \"type\": \"LIMIT\",\n          \"price\": 2.06,\n          \"trigger_price\": 2.05,\n          \"reduce_only\": true\n        },\n        {\n          \"symbol\": \"PERP_NEAR_USDC\",\n          \"algo_type\": \"STOP_LOSS\",\n          \"side\": \"SELL\",\n          \"type\": \"LIMIT\",\n          \"price\": 2.02,\n          \"trigger_price\": 2.02,\n          \"reduce_only\": true\n        }\n      ]\n    }\n  ]\n}\n```\n\n### Limits\n*   Maximum 10 untriggered `TP_SL` orders per user.\n*   Maximum 1 untriggered `POSITIONAL_TP_SL` order per user.",
      "keywords": [
        "algo orders",
        "stop loss",
        "take profit",
        "bracket order",
        "trailing stop",
        "conditional orders"
      ]
    },
    {
      "id": "trading-61",
      "title": "Risk Management and Liquidation Mechanics",
      "category": "Trading",
      "content": "Understanding margin requirements and liquidation triggers is critical for managing user positions on Orderly.\n\n### Margin Ratios\n\nLiquidation occurs when the account's **Margin Ratio (MR)** falls below the **Maintenance Margin Ratio (MMR)**.\n\n*   **Holding Notional**: `qty × mark_price`\n*   **Margin Ratio (MR)**: `collateral ÷ holding_notional`\n*   **Collateral**: `total_balance + uPnL`\n\nIf `MR < MMR`, the position is eligible for liquidation.\n\n### Liquidation Types\n\n1.  **Partial Liquidation**: Occurs when the margin is slightly below the requirement. The liquidator sells enough of the position to bring the account back to the required margin level.\n2.  **Full Liquidation**: Occurs when the margin is critically low. The entire position is closed.\n\n*Note: The specific outcome (partial vs. full) can depend on the liquidator's behavior, position notional value, and market conditions.*\n\n### Liquidation Fees\n\nA liquidation fee is applied to the position notional upon liquidation. This fee incentivizes liquidators and can significantly reduce the remaining collateral.\n\n*   **Example**: `liquidation_fee ≈ mark_price × qty × 0.006` (0.6% of notional).\n\n### UI Discrepancies\n\nSometimes the liquidation price displayed in the UI may differ from the actual execution price. Common causes include:\n\n1.  **Parameter Desynchronization**: If risk parameters (like IMR-factor) are updated but the liquidation engine hasn't synced, the UI might calculate a different price than the engine executing the liquidation.\n2.  **Static MMR Assumption**: For very large positions, the UI calculation might assume a static MMR, whereas the actual liquidation engine accounts for dynamic changes in margin requirements as notional value changes.\n3.  **Funding Fees**: Unpaid funding fees can reduce available collateral, triggering liquidation earlier than estimated based solely on price movement.\n\n### PnL Settlement\n\n*   **Unsettled PnL**: Users can trade using unrealized profits as margin without settling. Frequent manual settlement is unnecessary and can temporarily freeze funds.\n*   **Settlement Requirement**: Settlement is only required before withdrawing funds or conducting spot trading with realized profits.",
      "keywords": [
        "liquidation",
        "margin ratio",
        "maintenance margin",
        "risk limits",
        "pnl settlement",
        "imr"
      ]
    },
    {
      "id": "trading-62",
      "title": "Market Listing and Operations",
      "category": "Operations",
      "content": "This section covers the requirements for listing new perpetual markets on Orderly and operational considerations for brokers.\n\n### Listing Requirements\n\nTo list a new perpetual market (perp), the following criteria must be met:\n\n1.  **Market Cap**: FDV must be greater than $20M.\n2.  **Oracle Sources**: At least 3 price feed sources (e.g., CEX listings like Binance, OKX, or on-chain oracles).\n3.  **Market Maker**: A market maker must be committed to providing liquidity on Orderly. If the MM is not already integrated with Orderly, the onboarding process may take longer.\n\n### Liquidity Standards\n\nMarket makers must maintain the following standards:\n\n*   **Depth**: Minimum $20,000 USD within -2% and +2% depth.\n*   **Levels**: Minimum 15 levels (legs) within -2% and +2% depth.\n*   **Spread**: <= 50 basis points (bps).\n*   **Uptime**: >= 90%.\n\n### Broker Operations\n\n#### Admin Wallet Setup\n*   **Requirement**: To collect fee rebates, a broker must register an admin wallet.\n*   **Impact**: Trading can occur before the admin wallet is set up, but no fees will be collected until it is configured.\n*   **Solana**: The broker-registration UI may not support Solana wallets directly. Use the `dex-creator` template or an EVM wallet as an alternative.\n\n#### Fee Configuration\n*   **Updates**: Fee changes (tier or broker-level) are applied via periodic backend checks and are not always immediate (often next-day).\n*   **Custom Fees**: Per-user fee adjustments can be made via script, typically run daily by the broker infrastructure.\n\n#### Maintenance\n*   **Behavior**: During maintenance, trading, deposits, and withdrawals are paused. Pending orders are not automatically cancelled unless configured.\n*   **Risk**: Open positions remain open and can be liquidated if market conditions dictate, even during maintenance.\n\n#### Sub-Accounts\n*   **Limit**: A maximum of 10 sub-accounts can be created under a main account. This is a security constraint and cannot be changed.",
      "keywords": [
        "listing",
        "market maker",
        "liquidity",
        "admin wallet",
        "broker operations",
        "maintenance"
      ]
    },
    {
      "id": "trading-63",
      "title": "Common Trading Issues and FAQ",
      "category": "Troubleshooting",
      "content": "Answers to frequently asked questions and common issues encountered by developers and traders.\n\n### Q: Why does the dashboard 'trades' view differ from my broker UI?\n**A:** The dashboard shows individual trades sorted by execution time. A broker UI might show orders sorted by creation time. One order can result in multiple trades, causing the lists to look different.\n\n### Q: Can users access their account via another broker's UI?\n**A:** No. Users are tied to a specific broker ID. They must use the UI of the broker they registered with.\n\n### Q: Why did my MARKET close order return 'CANCELLED' with 0 executed quantity?\n**A:** This is common on testnet due to low liquidity. The order failed to fill immediately. Retry or add liquidity to the book using another account.\n\n### Q: Why is my position showing `qty = 0` but still visible?\n**A:** This usually happens if there is unsettled PnL or open limit orders associated with the position. Cancel open orders to clear the state.\n\n### Q: Do users pay gas for trading?\n**A:** No. Trading is handled off-chain. Users only pay gas for on-chain actions: deposits and withdrawals.\n\n### Q: How are funding rates handled?\n**A:** Funding rates are exchanged between longs and shorts to align perp prices with spot prices. They are not revenue for Orderly. Settlement typically occurs every 8 hours (00:00, 08:00, 16:00 UTC), though this can change to 4h, 2h, or 1h in high volatility.\n\n### Q: Where does the index price come from?\n**A:** Index prices are sourced from major exchanges (Binance, OKX, Huobi, Gateio, Bybit, KuCoin, MEXC) and weighted accordingly. Orderly does not connect to Binance's liquidity, only its price feed.\n\n### Q: Can I filter the symbols list in my frontend?\n**A:** Yes. Use the `OrderlyAppProvider` `dataAdapter` to process the `symbolList` data and return a filtered result.\n\n### Q: Is there a limit on Orderly Keys?\n**A:** Yes, a maximum of 30 ed25519 Orderly keys can be attached to a single account.",
      "keywords": [
        "faq",
        "troubleshooting",
        "gas fees",
        "funding rates",
        "liquidity",
        "orderly key"
      ]
    },
    {
      "id": "trading-64",
      "title": "Orderly Network Trading Overview",
      "category": "Overview",
      "content": "Orderly Network provides a hybrid central limit order book (CLOB) model that combines the performance of centralized exchanges with the transparency and self-custody of decentralized exchanges. All perpetual futures contracts are denominated and settled in USDC, including Real World Assets (RWA) like SPX500, NAS100, XAU, and XAG.\n\n### Key Concepts\n\n**Shared Liquidity:** Liquidity is pooled and shared across all applications integrated with Orderly. Regardless of the frontend used, traders access the same orderbook and depth.\n\n**Account Structure:** Each wallet address can have multiple Orderly accounts—one per frontend (broker/integrator). The account address is derived from the wallet address and the broker ID. Consequently, trading activity, fees, and volume are compartmentalized per account; orders placed on Front-end A cannot be managed from Front-end B.\n\n**Supported Chains:** Orderly supports trading across multiple EVM chains (Arbitrum, Optimism, Base, Mantle, Ethereum, SEI, Avalanche, Morph, Sonic, Story, Mode, Plume, Abstract, BNB Smart Chain, Monad) and non-EVM chains (Solana).\n\n### Perpetual Futures Contracts\n\nPerpetual futures are derivatives without an expiry date, allowing traders to speculate on underlying price movements with leverage. Orderly supports various order types including MARKET, LIMIT, IOC (Immediate or Cancel), FOK (Fill or Kill), POST_ONLY, REDUCE_ONLY, and conditional orders like STOP_MARKET and STOP_LIMIT.\n\n### MEV Protection\n\nOrderly mitigates Maximal Extractable Value (MEV) risks through:\n- Fast matching by the sequencer to reduce front-running opportunities.\n- Deep liquidity making price manipulation difficult.\n- Off-chain order matching in a neutral environment, preventing on-chain transaction ordering advantages during execution.",
      "keywords": [
        "trading overview",
        "perpetual futures",
        "orderbook",
        "liquidity",
        "account structure",
        "MEV protection"
      ]
    },
    {
      "id": "trading-65",
      "title": "Pricing Mechanics: Index, Mark, and Last Prices",
      "category": "Trading",
      "content": "Understanding the different price types on Orderly is crucial for risk management, liquidation prevention, and accurate PnL calculation.\n\n### Index Price\n\nThe Index Price represents the fair value of the underlying asset. It is computed as the volume-weighted average (VWA) of prices from major spot exchanges (e.g., Binance, OKX, Bybit for BTC/ETH).\n\n**Calculation:**\n- Weights are recalculated every 5 minutes based on the 4-hour trading volume of relevant spot pairs.\n- Formula: `Weight(CEX_i) = Volume(CEX_i) / Total Volume(CEXes)`\n\n**Manipulation Protection:**\n- If a single source deviates by more than 5% from the median price, its contribution is capped/floored within ±5% of the median.\n- If multiple sources deviate significantly, the median price is used instead of the VWA.\n- Sources that do not update for over 10 seconds are disregarded.\n\n### Mark Price\n\nThe Mark Price is used for liquidation logic and PnL calculation. It is less volatile than the Last Price and designed to prevent manipulation-induced liquidations.\n\n**Formula:**\n`Mark Price = Clamp(Median(P1, P2, Last Price), Index Price * (1 + Factor * Cap Funding), Index Price * (1 + Factor * Floor_funding))`\n\nWhere:\n- `P1 = Index Price * (1 + Last Funding Rate * Time until next Funding / dt)`\n- `P2 = Index Price + 15 Minute Moving Average[Basis]`\n- `Factor` varies by market (BTC: 10, ETH: 8, Others: 7).\n\n### Last Price\n\nThe Last Price is simply the price at which the last trade was executed on the orderbook. While useful for market sentiment, it is not used for margin calculations or liquidation triggers due to its volatility.\n\n### Price Limits (Price Range & Scope)\n\nOrderly enforces bands around the Mark Price to ensure order stability:\n\n**Price Range (3% for all markets):**\n- Buy Limit Price <= Mark Price * (1 + 0.03)\n- Sell Limit Price >= Mark Price * (1 - 0.03)\n\n**Price Scope (40% for all markets):**\n- Buy Limit Price >= Mark Price * (1 - 0.40)\n- Sell Limit Price <= Mark Price * (1 + 0.40)\n\nOrders violating these limits are cancelled. Market orders may be partially filled if execution moves outside the Price Range.",
      "keywords": [
        "index price",
        "mark price",
        "last price",
        "price manipulation",
        "liquidation price",
        "price limits"
      ]
    },
    {
      "id": "trading-66",
      "title": "Funding Rates and Insurance Fund",
      "category": "Trading",
      "content": "Funding rates ensure the perpetual futures price stays close to the Index Price. The Insurance Fund protects the system against bankrupt traders.\n\n### Funding Rate Calculation\n\nFunding rates are exchanged between long and short traders periodically (1h, 4h, or 8h depending on the market).\n\n**Impact Prices:**\nOrderly uses Impact Bid/Ask prices rather than best bid/ask to calculate funding, reducing manipulation risk.\n- **Impact Bid Price:** Average fill price for a sell order sized to the **Impact Margin Notional**.\n- **Impact Ask Price:** Average fill price for a buy order sized to the **Impact Margin Notional**.\n\n**Impact Margin Notional:**\nThis is the notional amount available to trade with 1,000 USDC collateral at maximum leverage.\n`Impact Margin Notional = 1,000 USDC * Max Leverage`\n\n**Accrued Funding:**\n`Accrued Funding(dt) = Position Size * Mark Price * Funding Rate`\n\n### Insurance Fund\n\nThe Insurance Fund safeguards the system against insolvent traders.\n\n**Growth:**\nThe fund grows by collecting liquidation fees from accounts that have enough margin.\n\n**Bankruptcy Handling:**\nIf an account's total collateral value becomes negative (bankrupt), the Insurance Fund takes over the positions and debt.\n\n**ADL (Auto-Deleveraging):**\nIn extreme conditions where the Insurance Fund is depleted, ADL is triggered. It selects the most profitable and highly leveraged traders and offsets their positions to cover the deficit.\n\n### Liquidation Mechanics\n\n**Liquidation Trigger:**\nAn account is liquidated if its Margin Ratio falls below the Maintenance Margin Ratio (MMR).\n\n**Process:**\n1. Open orders are cancelled, and USDC balance is frozen.\n2. Positions are transferred to liquidators at a discount (decentralized model).\n3. Anyone with an Orderly account and sufficient margin can act as a liquidator.\n\n**Liquidation Tiers:**\n- **Low Tier Risk (BTC, ETH):** Liquidators claim a ratio across all low-tier symbols.\n- **High Tier Risk (Others):** Liquidators can claim individual symbols.\n\n**Fees:**\nFees (e.g., 0.60% for BTC/ETH) are split between the Insurance Fund and the liquidator based on the remaining margin of the liquidated account.",
      "keywords": [
        "funding rate",
        "insurance fund",
        "liquidation",
        "impact price",
        "ADL",
        "maintenance margin"
      ]
    },
    {
      "id": "trading-67",
      "title": "Order Management and WebSocket Streams",
      "category": "API",
      "content": "Orderly provides a robust API for placing orders and real-time WebSocket streams for monitoring market data and account state.\n\n### Placing Orders\n\n**Endpoint:** `POST /v1/order`\n\n**Supported Order Types:**\n- `MARKET`: Matches until full size is executed or price limit is breached.\n- `LIMIT`: Standard limit order.\n- `IOC`: Immediate or Cancel—fills as much as possible, cancels the rest.\n- `FOK`: Fill or Kill—executes only if the full amount can be filled.\n- `POST_ONLY`: Ensures the order is a maker; cancelled if it would cross the spread.\n- `STOP_MARKET` / `STOP_LIMIT`: Triggered orders based on Mark Price.\n- `REDUCE_ONLY`: Only reduces existing position size.\n\n**Key Parameters:**\n- `symbol`: e.g., `PERP_ETH_USDC`\n- `side`: `BUY` or `SELL`\n- `order_type`: `LIMIT`, `MARKET`, etc.\n- `order_quantity`: Amount to trade.\n- `order_price`: Limit price (required for LIMIT orders).\n- `reduce_only`: Boolean to ensure position reduction.\n- `visible_quantity`: Maximum quantity displayed on the book (iceberg orders).\n\n### WebSocket Streams\n\nConnect to the WebSocket server to receive real-time updates.\n\n**Order Book Updates:**\n- **Incremental:** `{symbol}@orderbookupdate` (200ms interval)\n- **Snapshot:** `{symbol}@orderbook` (1s interval, depth 100)\n\n**Execution Reports:**\nSubscribe to `executionreport` to receive updates on order lifecycle (NEW, FILLED, CANCELED).\n\n**Algo Orders:**\nSubscribe to `algoexecutionreport` for updates on TP/SL or Stop orders.\n\n**Positions:**\nSubscribe to `position` to receive real-time updates on position size, PnL, and margin requirements.\n\n**Example: Subscribe to ETH Orderbook**\n```json\n{\n  \"id\": \"clientID1\",\n  \"topic\": \"PERP_ETH_USDC@orderbook\",\n  \"event\": \"subscribe\"\n}\n```\n\n**Example: Execution Report Payload**\n```json\n{\n  \"topic\": \"executionreport\",\n  \"ts\": 1704679472455,\n  \"data\": {\n    \"symbol\": \"PERP_ETH_USDC\",\n    \"orderId\": 292820969,\n    \"type\": \"LIMIT\",\n    \"side\": \"BUY\",\n    \"quantity\": 1.0,\n    \"price\": 1800.0,\n    \"status\": \"FILLED\",\n    \"executedQuantity\": 1.0\n  }\n}\n```",
      "keywords": [
        "order types",
        "websocket",
        "execution report",
        "orderbook",
        "API",
        "algo orders"
      ]
    },
    {
      "id": "trading-68",
      "title": "Frontend SDK Integration Guide",
      "category": "SDK",
      "content": "The Orderly SDK (`@orderly.network/perp`) simplifies frontend integration by providing hooks for account management, order entry, and data streaming.\n\n### Account Management\n\nAccess the account singleton using `useAccount()`.\n\n**KeyStore Management:**\n```typescript\nconst { account } = useAccount();\n\n// Get the Orderly private key\nconst key = account.keyStore.getOrderlyKey();\n\n// Clean keys\naccount.keyStore.cleanAllKey(address);\n```\n\n**Status Subscription:**\n```typescript\nuseEffect(() => {\n  const handler = (nextState: AccountState) => {\n    console.log(\"Account status changed:\", nextState);\n  };\n  account.on(\"change:status\", handler);\n  return () => account.off(\"change:status\", handler);\n}, []);\n```\n\n### Order Entry\n\nUse `useOrderEntry` to handle form state, validation, and submission.\n\n```typescript\nconst { submit, setValue, values, maxQty, estLiqPrice } = useOrderEntry(\"PERP_ETH_USDC\", {\n  initialOrder: {\n    side: OrderSide.BUY,\n    order_type: OrderType.LIMIT,\n    price: undefined,\n    order_quantity: undefined,\n  },\n  watchOrderbook: true // Required for accurate pricing\n});\n\n// Update a field\nsetValue(\"price\", 1850);\n\n// Submit order\nawait submit();\n```\n\n### Take Profit / Stop Loss (TP/SL)\n\nConfigure TP/SL for a position using `useTPSLOrder`.\n\n```typescript\nconst [values, { setValue, submit }] = useTPSLOrder(position, {\n  defaultOrder: existingAlgoOrder // Optional for editing\n});\n\n// Set Stop Loss trigger price\nsetValue(\"sl_trigger_price\", 1700);\n\n// Set Take Profit based on PnL\nsetValue(\"tp_pnl\", 100);\n\nawait submit();\n```\n\n### Data Streams\n\n**Positions:**\n```typescript\nconst [positions] = usePositionStream();\n```\n\n**Orders:**\n```typescript\nconst [orders] = useOrderStream({ status: OrderStatus.INCOMPLETE });\n```\n\n**Mark Prices:**\n```typescript\nconst { data: markPrices } = useMarkPricesStream(); // Record<symbol, price>\n```",
      "keywords": ["SDK", "hooks", "order entry", "TP/SL", "account management", "React"]
    },
    {
      "id": "trading-69",
      "title": "Margin and PnL Calculations",
      "category": "Trading",
      "content": "Properly calculating margin, PnL, and leverage is essential for building a robust trading interface.\n\n### Notional Value\n\n`Notional Value = Position Qty * Mark Price`\n\n### PnL Calculation\n\n**Unrealized PnL:**\n`Unrealized PnL = Position Qty * (Mark Price - Average Entry Price)`\n\n**Realized PnL:**\n`Realized PnL = Closed Qty * (Average Execution Price - Average Entry Price)`\n\n### Margin Requirements\n\n**Maintenance Margin Ratio (MMR):**\nThe threshold for liquidation.\n`MMR_i = Max(Base MMR_i, (Base MMR_i / Base IMR_i) * IMR Factor_i * Abs(Position Notional_i)^(4/5))`\n\n**Initial Margin Ratio (IMR):**\nThe margin required to open a position. Calculated similarly to MMR but with different base constants.\n\n**Account Margin Ratio:**\n`Margin Ratio = Total Equity / Total Initial Margin`\nLiquidation occurs if `Margin Ratio < Maintenance Margin Ratio`.\n\n### Leverage\n\n`Leverage = Position Notional / Initial Margin`\n\n### SDK Utilities\n\nThe SDK provides utility functions to compute these values accurately.\n\n**Max Tradable Quantity:**\n```typescript\nimport { order } from \"@orderly.network/perp\";\n\nconst maxQty = order.computeMaxQty({\n  symbol: \"PERP_ETH_USDC\",\n  totalCollateral: 1000,\n  markPrice: 2000,\n  positionQty: 0,\n  // ... other parameters\n});\n```\n\n**Liquidation Price:**\n```typescript\nimport { positions } from \"@orderly.network/perp\";\n\nconst liqPrice = positions.liqPrice({\n  MMR: 0.05,\n  markPrice: 2000,\n  positionQty: 0.5,\n  totalCollateral: 100,\n  positions: [] // other positions\n});\n```",
      "keywords": ["margin", "PnL", "leverage", "liquidation", "notional value", "calculations"]
    },
    {
      "id": "trading-70",
      "title": "Troubleshooting Common Trading Issues",
      "category": "Troubleshooting",
      "content": "This section addresses common issues developers and traders may encounter on Orderly Network.\n\n### Orders Not Closing at Expected Price\n\n**Issue:** A limit order did not fill at the specified price, or a market order experienced significant slippage.\n\n**Solutions:**\n1. **Limit Orders:** Verify the order type. For shorts, execution price >= limit price. For longs, execution price <= limit price.\n2. **Market Orders:** Check if slippage tolerance was set. Without slippage protection, execution price is not guaranteed during high volatility.\n3. **Price Limits:** Ensure the order price is within the `Price Range` (±3% of Mark Price). Orders outside this band are cancelled.\n\n### Account Liquidation Unexpectedly\n\n**Issue:** An account was liquidated despite seemingly having sufficient balance.\n\n**Solutions:**\n1. **Check Mark Price:** Liquidations are based on Mark Price, not Last Price. Mark Price may deviate during high volatility.\n2. **Pending Orders:** Open orders consume margin (Initial Margin). Ensure `IMR with orders` is considered.\n3. **Cross-Collateral:** If holding non-USDC assets, check their haircuts/discounts and mark prices.\n\n### Funding Rate Discrepancies\n\n**Issue:** Calculated funding does not match the expected value.\n\n**Solutions:**\n1. **Impact Prices:** Remember that funding uses Impact Bid/Ask prices, not the top of the book.\n2. **Time Period:** Ensure the calculation uses the correct funding period (1h, 4h, or 8h) for the specific market.\n\n### WebSocket Disconnections\n\n**Issue:** Real-time data stops updating.\n\n**Solutions:**\n1. Implement a heartbeat/ping mechanism to detect stale connections.\n2. Handle `close` events and re-subscribe to topics upon reconnection.\n3. Check sequence numbers (`seq`) in execution reports to detect gaps.\n\n### KeyStore/Signature Errors\n\n**Issue:** `Invalid signature` or `Key not found` errors when placing orders.\n\n**Solutions:**\n1. Ensure the `OrderlyKey` is registered via `generateAddOrderlyKeyMessage` and signed by the wallet.\n2. Check that the `brokerId` used in the signature matches the `brokerId` in the API request.\n3. Verify the timestamp in the payload is within the allowed window.",
      "keywords": [
        "troubleshooting",
        "liquidation",
        "order execution",
        "funding rate",
        "websocket",
        "signature errors"
      ]
    },
    {
      "id": "authentication-71",
      "title": "Account Registration and EIP-712 Signing",
      "category": "Authentication",
      "content": "Registering an account on Orderly Network requires an EIP-712 signature to verify wallet ownership. This process involves fetching a nonce, constructing a typed data message, signing it with the user's wallet, and sending it to the registration endpoint.\n\n### 1. Fetch Registration Nonce\nBefore signing, request a unique nonce from the server to prevent replay attacks.\n\n```http\nGET /v1/registration_nonce\n```\n\n### 2. Construct the EIP-712 Message\nThe message must include the `brokerId`, `chainId`, `timestamp`, and the `registrationNonce` obtained in the previous step.\n\n```json\n{\n  \"brokerId\": \"woofi_dex\",\n  \"chainId\": 80001,\n  \"timestamp\": 1685973017064,\n  \"registrationNonce\": \"194528949540\"\n}\n```\n\n### 3. Define EIP-712 Domain and Types\nUse the standard Orderly off-chain domain for registration. Note that `chainId` in the domain is fixed (e.g., 421614) and distinct from the user's connected chain.\n\n```typescript\nconst OFF_CHAIN_DOMAIN = {\n  name: \"Orderly\",\n  version: \"1\",\n  chainId: 421614,\n  verifyingContract: \"0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC\"\n};\n\nconst MESSAGE_TYPES = {\n  Registration: [\n    { name: \"brokerId\", type: \"string\" },\n    { name: \"chainId\", type: \"uint256\" },\n    { name: \"timestamp\", type: \"uint64\" },\n    { name: \"registrationNonce\", type: \"uint256\" }\n  ]\n};\n```\n\n### 4. Sign and Submit\nSign the typed data using your wallet library (e.g., ethers.js) and send the signature to the registration endpoint.\n\n```typescript\nimport { ethers } from \"ethers\";\n\nconst wallet = new ethers.Wallet(process.env.PRIVATE_KEY!);\nconst signature = await wallet.signTypedData(\n  OFF_CHAIN_DOMAIN,\n  { Registration: MESSAGE_TYPES.Registration },\n  registerMessage\n);\n\n// POST to /v1/register_account\nawait fetch('/v1/register_account', {\n  method: 'POST',\n  body: JSON.stringify({\n    message: registerMessage,\n    signature,\n    userAddress: wallet.address\n  })\n});\n```\n\n### Common Issues\n*   **Error -1613 (Address and signature do not match):** This often occurs if you pre-hash the typed data JSON before signing. Ensure you use the native `signTypedData` method provided by your library rather than manually hashing the payload with `sha3`.",
      "keywords": [
        "EIP-712",
        "registration",
        "wallet signature",
        "brokerId",
        "nonce",
        "ethers.js",
        "account creation"
      ]
    },
    {
      "id": "authentication-72",
      "title": "Orderly Key Generation and Management",
      "category": "Security",
      "content": "Orderly Keys (Ed25519) are used to sign API requests for trading and account management without requiring a wallet signature for every action. These keys can be stored locally to facilitate a seamless user experience.\n\n### Generating an Orderly Key\nYou can generate an Ed25519 keypair locally. The public key must be registered on-chain via a wallet signature before it can be used for API authentication.\n\n```typescript\n// Example using a hypothetical utility or library\nconst keyPair = OrderlyKeyStore.generateKey();\nconst publicKey = await keyPair.getPublicKey(); // Base58 encoded\nconst secretKey = keyPair.secretKey;\n```\n\n### Registering the Key (AddOrderlyKey)\nTo associate the Orderly Key with a wallet address, you must sign an `AddOrderlyKey` EIP-712 message.\n\n**Message Fields:**\n*   `brokerId` (string)\n*   `chainId` (uint256)\n*   `orderlyKey` (string): Formatted as `ed25519:<base58_public_key>`\n*   `scope` (string): Permissions granted to the key (e.g., \"read\", \"trading\")\n*   `timestamp` (uint64)\n*   `expiration` (uint64): Maximum expiration is 365 days from creation.\n\n```typescript\nconst orderlyKeyString = `ed25519:${publicKey}`;\n\nconst addKeyMessage = {\n  brokerId: \"woofi_dex\",\n  chainId: 421614,\n  orderlyKey: orderlyKeyString,\n  scope: \"trading\",\n  timestamp: Date.now(),\n  expiration: Date.now() + (365 * 24 * 60 * 60 * 1000)\n};\n\nconst signature = await wallet.signTypedData(\n  OFF_CHAIN_DOMAIN,\n  { AddOrderlyKey: [/* types */] },\n  addKeyMessage\n);\n```\n\n### Using the Key for API Requests\nOnce registered, use the secret key to sign HTTP requests. The signature is derived from the timestamp, HTTP method, path, query string, and body.\n\n**Signature Construction:**\n`<timestamp_ms><HTTP_METHOD><url_path><url_search><body>`\n\n```typescript\n// Example signing logic\nconst timestamp = Date.now();\nconst method = \"POST\";\nconst path = \"/v1/order\";\nconst body = JSON.stringify(orderData);\n\nconst message = `${timestamp}${method}${path}?${query}${body}`;\nconst signature = await keyPair.sign(new TextEncoder().encode(message));\n\n// Headers\nheaders: {\n  \"orderly-key\": `ed25519:${publicKey}`,\n  \"orderly-timestamp\": timestamp,\n  \"orderly-signature\": base58Encode(signature)\n}\n```\n\n### Storage\nStore the `secretKey` securely (e.g., in LocalStorage or an encrypted database) associated with the user's wallet address. The `OrderlyKeyStore` interface provides methods like `setKey(address, keyPair)` and `getOrderlyKey(address)` to manage this persistence.",
      "keywords": [
        "Orderly Key",
        "Ed25519",
        "API authentication",
        "key storage",
        "signing requests",
        "scope",
        "local storage"
      ]
    },
    {
      "id": "authentication-73",
      "title": "Delegate Signer for Smart Contract Wallets",
      "category": "Security",
      "content": "Smart contract wallets (like Safe/Multisig) cannot sign off-chain EIP-712 messages directly. The Delegate Signer flow allows a smart contract to authorize an Externally Owned Account (EOA) to sign messages on its behalf.\n\n### How it Works\n1.  The Smart Contract calls the `delegateSigner` function on the Orderly Vault contract, specifying the EOA address allowed to sign for it.\n2.  The designated EOA (Delegate Signer) then signs Orderly-specific messages (like `DelegateWithdraw` or `DelegateSettlePnl`) using the standard EIP-712 flow.\n\n### Setting the Delegate Signer\nYou must execute a transaction from your smart contract to the Vault contract.\n\n**Solidity Example:**\n```solidity\nimport \"./IVault.sol\";\n\ncontract MySmartWallet {\n    IVault public immutable vault;\n\n    constructor(address _vault) {\n        vault = IVault(_vault);\n    }\n\n    function setDelegateSigner(address delegate, bytes32 brokerHash) external {\n        VaultTypes.VaultDelegate memory data = VaultTypes.VaultDelegate({\n            brokerHash: brokerHash,\n            delegateSigner: delegate\n        });\n        \n        vault.delegateSigner(data);\n    }\n}\n```\n\n### Signing as a Delegate\nWhen the Delegate Signer signs a transaction, they use the \"Delegate\" version of the typed data. For example, for a withdrawal, use `DelegateWithdraw` instead of `Withdraw`.\n\n**DelegateWithdraw Fields:**\n*   `brokerId` (string)\n*   `chainId` (uint256)\n*   `receiver` (address)\n*   `token` (string)\n*   `amount` (uint256)\n*   `withdrawNonce` (uint64)\n*   `timestamp` (uint64)\n*   `delegatedAddress` (address): The address of the Smart Contract wallet.\n\n### Important Notes\n*   **Single Delegate:** Only one EOA can be set as the delegate signer at a time. Setting a new one overrides the previous.\n*   **Broker ID:** You must have your own Broker ID to test and use the Delegate Signer functionality.\n*   **Reference:** A full reference implementation is available at [OrderlyNetwork/broker-registration](https://github.com/OrderlyNetwork/broker-registration).",
      "keywords": [
        "Smart Contract Wallet",
        "Delegate Signer",
        "Multisig",
        "Safe",
        "Vault contract",
        "EOA",
        "off-chain signing"
      ]
    },
    {
      "id": "authentication-74",
      "title": "Wallet Adapter and Core SDK Integration",
      "category": "SDK",
      "content": "The `@orderly.network/core` SDK provides a standardized way to interact with wallets, manage accounts, and handle keys. It abstracts the complexities of EIP-712 signing and key storage.\n\n### Wallet Adapter Interface\nThe `WalletAdapter` interface defines standard methods for interacting with different wallet providers (MetaMask, Phantom, etc.).\n\n**Key Methods:**\n*   `signTypedData(address, data)`: Signs EIP-712 typed data.\n*   `call(address, method, params, options)`: Reads data from a contract without executing a transaction.\n*   `getTransactionReceipt(txHash)`: Fetches transaction status.\n\n```typescript\n// Example: Signing Typed Data\nconst signature = await walletAdapter.signTypedData(userAddress, typedData);\n```\n\n### Account Management\nThe `Account` class is the central entry point for user operations.\n\n**Initialization:**\n```typescript\nimport { Account, LocalStorageStore } from \"@orderly.network/core\";\n\nconst keyStore = new LocalStorageStore(\"mainnet\");\nconst account = new Account(\n  configStore,\n  keyStore,\n  () => walletAdapter // Function returning the adapter\n);\n```\n\n**Creating an Orderly Key:**\n```typescript\n// Creates a key, signs it with the wallet, and stores it\nawait account.createOrderlyKey(365); // Expires in 365 days\n```\n\n**Event Handling:**\nSubscribe to account events to react to state changes.\n```typescript\naccount.on(\"ACCOUNT_UPDATED\", (data) => {\n  console.log(\"Account state changed\", data);\n});\n```\n\n### KeyStore Utilities\nThe `OrderlyKeyStore` (implemented by `LocalStorageStore`) handles the persistence of Orderly Keys.\n\n*   `setKey(address, keyPair)`: Saves a key for a specific address.\n*   `getOrderlyKey(address)`: Retrieves the key.\n*   `setAddress(address)`: Sets the active wallet address.\n\n### Helper Functions\nThe SDK exports utility functions for common tasks:\n*   `parseAccountId(userAddress, brokerId)`: Derives the unique Orderly Account ID.\n*   `parseBrokerHash(brokerId)`: Generates the broker hash required for delegate signing.\n*   `generateRegisterAccountMessage(inputs)`: Generates the full EIP-712 payload for registration.",
      "keywords": [
        "Wallet Adapter",
        "SDK",
        "Account class",
        "LocalStorageStore",
        "KeyStore",
        "events",
        "utilities"
      ]
    },
    {
      "id": "authentication-75",
      "title": "Broker Setup, Graduation, and Admin Access",
      "category": "Operations",
      "content": "To operate a DEX on Orderly, you must register as a Broker, graduate from the demo environment, and configure your admin wallet for fee collection.\n\n### Broker Graduation\nNew DEXes start with a temporary/demo Broker ID. Graduation assigns you a permanent Broker ID and enables full production capabilities.\n\n1.  **Choose Broker ID:** You can request a specific string (e.g., \"mydex\") from the Orderly team.\n2.  **Graduation Process:** Initiated via the Orderly One interface or by contacting support. This may involve a fee, though waivers are possible.\n3.  **Update Config:** After graduation, update your DEX configuration (e.g., `VITE_ORDERLY_BROKER_ID`) to use the new Broker ID.\n\n### Admin Wallet Setup\nThe Admin Wallet is responsible for collecting trading fees.\n\n1.  **Registration:** Register the desired wallet address as an Orderly account under your new Broker ID.\n2.  **Notification:** Contact Orderly support with the wallet address to finalize the admin setup.\n3.  **Access:** Log in to the admin portal at [admin.orderly.network](https://admin.orderly.network/login).\n\n### Admin Credentials\nTo log in to the admin portal, you need an Orderly Key (Secret Key) associated with your admin wallet.\n\n*   **Generating the Key:** Create an Orderly key via the broker registration tool or your DEX interface while connected as the admin wallet.\n*   **Retrieving the Secret:** The secret is stored in `localStorage`. You can derive the public key from the secret (base58 decode, take last 32 bytes, base58 encode) to verify it matches your admin wallet.\n\n### Multisig Considerations\n*   **Login:** Multisig wallets (like Safe) cannot sign the off-chain messages required for standard login. You must use an EOA (Externally Owned Account) for the initial login and key generation steps.\n*   **Fee Collection:** The admin wallet *can* be a multisig, but you must use the Delegate Signer workflow if it needs to perform actions requiring signatures.",
      "keywords": [
        "Broker ID",
        "Graduation",
        "Admin Wallet",
        "Fee Collection",
        "Multisig",
        "Orderly Key",
        "Credentials"
      ]
    },
    {
      "id": "authentication-76",
      "title": "Social Login and Privy Integration",
      "category": "Authentication",
      "content": "Orderly One supports passwordless login methods, including email and social logins (Google, X), via integration with Privy.\n\n### Configuration\nTo enable Privy login:\n\n1.  **Create a Privy App:** Set up an application in the [Privy Dashboard](https://dashboard.privy.io/).\n2.  **Get App ID:** Copy your Privy App ID.\n3.  **Configure Orderly One:** Paste the App ID into your Orderly One DEX configuration.\n4.  **Terms of Use:** Provide a link to your app's Terms of Use as required by Privy.\n\n### Wallet Requirement\nEven with email or social login, a Web3 wallet context is required because Orderly accounts are fundamentally based on a public key and Broker ID. Privy creates an embedded wallet for the user behind the scenes.\n\n*   **Deposits:** Users cannot deposit without a wallet connection. The deposit flow triggers an on-chain transaction that requires the user's signature.\n\n### OAuth Setup (Google/X)\nEnabling Google or X login is considered an advanced setup compared to standard email login.\n\n1.  **Developer App:** Create a developer app with the identity provider (e.g., Google Cloud Console).\n2.  **Credentials:** Obtain the OAuth Client ID and Client Secret.\n3.  **Privy Config:** Enter these credentials into your Privy dashboard configuration for the specific provider.\n\n### Solana vs EVM\nIf using a wallet like Phantom that supports both EVM and Solana, ensure your Privy configuration explicitly selects the desired wallet type. Otherwise, the flow may default to EVM, prompting for an Ethereum signature even if the user intends to use Solana.",
      "keywords": [
        "Privy",
        "Social Login",
        "Email Login",
        "OAuth",
        "Google",
        "Phantom",
        "Embedded Wallet"
      ]
    },
    {
      "id": "wallet-77",
      "title": "Broker Admin Wallet Setup and Management",
      "category": "Operations",
      "content": "## Broker Admin Wallet Setup and Management\n\nThe broker admin wallet is the central account for managing your Orderly Network DEX. It is responsible for collecting broker fees, accessing the admin console, and managing referral codes.\n\n### Initial Setup\n\n1. **Register the Broker ID**: Provide Orderly with your Broker ID, Broker Name, Environment (Production/Staging), Default Taker/Maker Fees, and Tier.\n2. **Register the Admin Wallet**:\n   - Create an Orderly account under your Broker ID using the [broker-registration tool](https://broker.orderly.network/).\n   - You can register on any supported network (chain selection does not affect registration).\n   - **Important**: You must register separately for Mainnet and Testnet if you need access to both environments.\n3. **Finalize with Orderly**: Send the registered wallet address to Orderly support. They will configure it as the admin account in the backend.\n\n### Accessing the Admin Console\n\nOnce the admin wallet is set up, you can access the admin dashboard at [https://admin.orderly.network](https://admin.orderly.network). You must connect using the specific wallet address registered as the admin.\n\n### Changing the Admin Wallet\n\nIf you need to change the admin wallet (e.g., for security or organizational changes):\n\n1. Register the new wallet address as a new account under your Broker ID.\n2. Submit the new address to Orderly support.\n3. The Orderly team will manually update the configuration to switch admin privileges and fee collection to the new address.\n\n**Note**: Multisig wallets (e.g., Safe) are supported as admin wallets. You can also use a smart contract account as the admin recipient while using a delegated wallet for operations.\n\n### Fee Collection\n\nBroker fees are credited daily to the admin wallet's Orderly account in USDC. To withdraw these funds:\n\n1. Log in to your DEX using the admin wallet.\n2. Navigate to the withdrawal section.\n3. Withdraw the USDC balance to your external Web3 wallet.",
      "keywords": [
        "admin wallet",
        "broker setup",
        "fee collection",
        "multisig",
        "orderly console",
        "broker id"
      ]
    },
    {
      "id": "wallet-78",
      "title": "WalletConnect and Mobile Wallet Integration",
      "category": "SDK",
      "content": "## WalletConnect and Mobile Wallet Integration\n\nOrderly One supports WalletConnect (via Reown) to enable mobile wallet connections, particularly for iOS Safari users who lack built-in EVM wallet support.\n\n### Configuration Steps\n\n1. **Create a Reown Project**:\n   - Go to the [Reown (WalletConnect) Dashboard](https://cloud.reown.com/).\n   - Create a new project and copy the **Project ID**.\n\n2. **Configure Orderly One**:\n   - In your Orderly One DEX settings, paste the Reown Project ID.\n   - Ensure your DEX domain (or subdomain) is whitelisted in the Reown project settings.\n\n3. **Troubleshooting**:\n   - **Wallets not appearing**: Verify the Project ID is correct and the domain is whitelisted. Users may need to clear their browser cache.\n   - **Subdomain usage**: If using a subdomain (e.g., `dex.example.com`), you must whitelist the exact subdomain, not just the root domain.\n\n### iOS Safari Specifics\n\niOS Safari does not support direct EVM wallet injection. Users must connect via WalletConnect. Ensure your UI prompts mobile users to select WalletConnect if standard injection wallets are not detected.\n\n### Code Example: Enabling WalletConnect\n\nIf you are building a custom integration, ensure your configuration includes the Reown Project ID:\n\n```typescript\nconst config = {\n  // ... other config\n  walletConnectProjectId: 'YOUR_REOWN_PROJECT_ID',\n};\n```",
      "keywords": [
        "walletconnect",
        "reown",
        "mobile",
        "ios safari",
        "evm wallet",
        "domain whitelist"
      ]
    },
    {
      "id": "wallet-79",
      "title": "Using the Wallet Adapter SDK",
      "category": "SDK",
      "content": "## Using the Wallet Adapter SDK\n\nThe Orderly Wallet Adapter provides a standardized interface to interact with user wallets, handle transactions, and manage account state across different chains.\n\n### Key Functionalities\n\n- **Balance Retrieval**: Fetch on-chain balances for specific tokens.\n- **Transaction Handling**: Send transactions and poll for receipts with backoff.\n- **Unit Conversion**: Convert between human-readable amounts and on-chain units (wei).\n- **Chain Switching**: Programmatically switch the connected wallet's chain.\n\n### Code Examples\n\n#### 1. Fetching Balance\n\n```typescript\nconst balance = await wallet.getBalance('0x1234...');\nconsole.log('Raw Balance:', balance);\n\n// Convert to human readable if necessary\nconst formatted = wallet.formatUnits(balance);\n```\n\n#### 2. Sending a Transaction (Deposit)\n\n```typescript\nimport { Vault__factory } from '@orderly/contracts';\n\nconst vaultContract = Vault__factory.connect(vaultAddress, wallet);\n\nconst depositInput = {\n  accountId: orderlyAccountId,\n  brokerHash: keccak256(toUtf8Bytes(brokerId)),\n  tokenHash: keccak256(toUtf8Bytes(tokenId)),\n  tokenAmount: depositAmount,\n};\n\n// Get required deposit fee\nconst depositFee = await vaultContract.getDepositFee(wallet.address, depositInput);\n\n// Send deposit transaction\nconst tx = await vaultContract.deposit(depositInput, { value: depositFee });\n\n// Poll for receipt with backoff\nconst receipt = await wallet.pollTransactionReceiptWithBackoff(tx.hash);\n```\n\n#### 3. Switching Chains\n\n```typescript\n// Set the chain ID on the adapter\nwallet.chainId = 42161; // Example: Arbitrum\n\n// Or use the Account instance to switch\nconst account = useAccountInstance();\naccount.switchChainId('42161');\n```\n\n#### 4. Subscribing to Events\n\n```typescript\nwallet.on('accountsChanged', (accounts) => {\n  console.log('Accounts changed:', accounts);\n});\n\n// Unsubscribe later\nwallet.off('accountsChanged', handler);\n```",
      "keywords": ["wallet adapter", "sdk", "transactions", "balance", "chain switching", "polling"]
    },
    {
      "id": "wallet-80",
      "title": "Orderly Account ID Computation",
      "category": "SDK",
      "content": "## Orderly Account ID Computation\n\nThe Orderly Account ID is a unique identifier derived from the user's wallet address and the Broker ID. It is required for registering accounts and mapping on-chain deposits to the correct off-chain Orderly account.\n\n### Calculation Logic\n\nThe Account ID is computed by:\n1. Keccak256 hashing the `brokerId` string.\n2. ABI-encoding the `userAddress` (address type) and the hashed `brokerId` (bytes32).\n3. Keccak256 hashing the resulting encoded bytes.\n\n### Code Implementation\n\n```typescript\nimport { AbiCoder, keccak256, solidityPackedKeccak256 } from 'ethers';\n\nexport function getAccountId(userAddress: string, brokerId: string): string {\n  const abicoder = AbiCoder.defaultAbiCoder();\n  \n  // 1. Hash the brokerId\n  const brokerIdHash = solidityPackedKeccak256(['string'], [brokerId]);\n  \n  // 2. ABI encode address + brokerIdHash\n  const encoded = abicoder.encode(\n    ['address', 'bytes32'],\n    [userAddress, brokerIdHash]\n  );\n  \n  // 3. Hash the encoded data\n  return keccak256(encoded);\n}\n```\n\n### Usage Notes\n\n- **Multi-Broker Support**: A single wallet address can have multiple Orderly Accounts if it interacts with different Brokers. Each combination of `walletAddress` + `brokerId` results in a unique `accountId`.\n- **Persistence**: Use `setAccountId` and `getAccountId` helper methods in your application to persist the mapping for the user's session.",
      "keywords": [
        "account id",
        "computation",
        "broker id",
        "keccak256",
        "abi encode",
        "wallet address"
      ]
    },
    {
      "id": "wallet-81",
      "title": "Deposits and Withdrawals Guide",
      "category": "Operations",
      "content": "## Deposits and Withdrawals Guide\n\nManaging funds on Orderly involves moving assets between the user's Web3 wallet and their Orderly account.\n\n### Deposits\n\nTo deposit funds into an Orderly account:\n\n1. **User Action**: The user initiates a deposit on-chain via the Vault contract.\n2. **Fee Handling**: A small native gas fee is required to process the deposit transaction. Ensure the user has sufficient native token (e.g., ETH, MATIC) for gas.\n3. **Confirmation**: Deposits require a certain number of block confirmations before being credited (e.g., Polygon requires ~500 blocks).\n\n**Common Error**: `CALL_REVERTED` usually indicates insufficient native gas tokens in the user's wallet.\n\n### Withdrawals\n\nTo withdraw funds:\n\n1. **Initiate**: The user requests a withdrawal via the DEX UI.\n2. **Processing**: Orderly processes the request and updates the transaction status.\n3. **On-chain Transfer**: Funds are sent from the Orderly Vault to the user's wallet.\n\n### Troubleshooting Stuck Transactions\n\nIf a user reports a deposit is missing:\n\n1. **Check Support Dashboard**: Use the [Orderly Support Dashboard on Dune](https://dune.com/orderly_network/orderly-support-dashboard) to verify if the deposit was received by Orderly. Refresh the dashboard to ensure latest data.\n2. **Check LayerZero Scan**: Search the user's address on [LayerZero Scan](https://layerzeroscan.com/). Look for messages with Orderly as the destination.\n   - **In-flight**: Still processing.\n   - **Delivered**: Processed by Orderly (check dashboard again).\n   - **No message**: Transaction failed or did not reach Orderly.\n3. **Database Check (Internal)**: For support staff, query the `wallet_transaction` table for the user ID. A status of `CONFIRMED` means processed off-chain but pending on-chain send.",
      "keywords": [
        "deposit",
        "withdrawal",
        "vault contract",
        "gas fee",
        "layerzero",
        "troubleshooting"
      ]
    },
    {
      "id": "wallet-82",
      "title": "Staking Wallet and Fee Tiers",
      "category": "Operations",
      "content": "## Staking Wallet and Fee Tiers\n\nOrderly Network offers fee tier reductions based on $ORDER staking. The wallet used for staking does not need to be the same as your broker admin wallet.\n\n### Configuration\n\n- **Separate Wallets**: You can designate a specific wallet address for staking while using a different address as the Broker Admin wallet.\n- **Linking**: Provide the staking wallet address to the Orderly team during broker registration or via a support request to link it to your Broker ID.\n\n### Tier Benefits\n\n- **Base Fees**: Orderly charges a base fee of 3 bps (0.03%) for takers and 0 bps for makers.\n- **Broker Revenue**: Any fees you set above the base fee are your revenue. Staking can reduce the effective base fee or unlock higher revenue share tiers depending on the program rules.\n\n### Chain Agnosticism\n\nStaking information (excluding the raw wallet balance) is chain-agnostic. An EVM address staked on one network will be recognized across all supported EVM networks for tier calculation purposes.",
      "keywords": [
        "staking",
        "fee tiers",
        "order token",
        "broker revenue",
        "wallet linking",
        "reduction"
      ]
    },
    {
      "id": "orders-83",
      "title": "Order Lifecycle, Types, and Parameters",
      "category": "Trading",
      "content": "This guide covers the essential parameters, types, and lifecycle events for placing and managing orders on Orderly Network.\n\n## Order Parameters\nWhen submitting orders, ensure you use the correct fields. The API distinguishes between general fields and specific order submission fields:\n\n- **`order_type`**: Use this field when submitting or updating orders (e.g., `MARKET`, `LIMIT`). Do not use `type`.\n- **`order_quantity`**: Use this field for the quantity of the base asset. Do not use `quantity` or `amount` (quote currency) for futures orders.\n\n### Minimum Notional Value\nEvery order must meet a minimum notional value to be accepted by the matching engine.\n- **Minimum Notional**: 10 USDC.\n- You can find specific symbol requirements in the `Symbol Info` or `Exchange Information` endpoint under the `min_notional` field.\n\n## Order Types\n### Standard Orders\n- **Market**: Executes immediately against available liquidity.\n- **Limit**: Executes only at the specified price or better.\n\n### Reduce-Only Orders\nUse `reduce_only: true` when your intent is to close or reduce an existing position.\n- **Why use it?** Reduce-only orders do not count against your Initial Margin Requirement (IMR). Attempting to close a position with a standard order may fail if you lack sufficient free margin.\n- **Closing a Long**: Submit a `SELL` order with `reduce_only: true`. You do **not** need to pass a negative quantity.\n- **Closing a Short**: Submit a `BUY` order with `reduce_only: true`.\n\n### Algo Orders (TP/SL)\nOrderly supports Take-Profit (TP) and Stop-Loss (SL) logic via algo orders.\n\n#### Position-Based TP/SL\nFor position-based management, use the `TP_SL` order type.\n- **Structure**: A `TP_SL` order consists of exactly one Take-Profit and one Stop-Loss child order. Quantities for both must match.\n- **Multiple TPs**: To execute partial take-profits (e.g., 50% at price A, 50% at price B), submit separate `TP_SL` orders rather than trying to pack multiple TPs into a single structure.\n\n#### Bracket Orders\nA Bracket order tracks a parent entry order and automatically defines exit logic (TP/SL).\n- **Leg 1**: The parent Bracket order and the triggered entry order.\n- **Leg 2**: The `TP_SL` or `POSITIONAL_TP_SL` order managing the exit.\n- **Behavior**: Once the parent order executes, Leg 2 becomes an independent algo order. If a `POSITIONAL_TP_SL` is triggered, any existing `POSITIONAL_TP_SL` orders for that position are canceled to ensure only one is active.\n\n#### Offset Percentage\nWhen using hooks like `useTPSLOrder`, the `offset_percentage` input is multiplied by 100.\n- **Example**: Input `0.1` represents a 10% price move. Input `1.0` represents a 100% move.\n\n## Order Lifecycle\n### Cancellation\n- **Renewal**: Cancelled orders cannot be renewed. You must create a new order.\n- **Partial Fills**: Reduce-only orders may be partially filled. If the remaining quantity cannot be filled because part of the position is reserved by active TP/SL algo orders, the remainder will be canceled.\n\n### Order Tags\n- **`order_tag`**: You can set any string value for `order_tag` without prior approval from Orderly.\n- **Referral Override**: If present, `order_tag` acts like a referral code with higher priority, overriding the user's default referral code for fee rebates.\n\n## Common Errors\n- **Error -1005**: Typically occurs when using `amount` (quote currency) instead of `order_quantity` (base asset) for futures orders. Ensure you are sending the base token quantity.",
      "keywords": [
        "order types",
        "reduce-only",
        "TP/SL",
        "bracket orders",
        "min notional",
        "order parameters",
        "algo orders"
      ]
    },
    {
      "id": "orders-84",
      "title": "Deposits, Withdrawals, and Vault Integration",
      "category": "Operations",
      "content": "This section explains how to move assets on and off the Orderly Network, including on-chain integration details for the Vault contract.\n\n## Overview\n- **Deposits**: Users deposit assets into the Orderly Vault on a supported source chain (e.g., Arbitrum, Optimism). Funds are then bridged to the Orderly L2.\n- **Withdrawals**: Funds are transferred from Orderly L2 back to the source chain vault and then to the user's wallet.\n\n## Timing and Finality\n### Deposit Times\n- **Optimism/Arbitrum**: Fast (~20 blocks, tens of seconds).\n- **Polygon PoS**: Slower (~500+ blocks). This delay is due to LayerZero finality settings and Polygon reorg considerations.\n\n### Withdrawal Times\n- **Expected**: Fast (~1 minute) as transfers originate from Orderly's L2.\n- **Delays**: Delays of several minutes may occur due to system timing or finality checks. Check on-chain transaction status if delays persist.\n\n## On-Chain Integration (EVM)\nTo integrate deposits directly from your dApp, interact with the Vault contract on the source chain.\n\n### 1. Approve Spending\nFirst, approve the Vault contract to spend the user's tokens (e.g., USDC).\n\n```javascript\n// Example using ethers.js\nconst tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);\nawait tokenContract.approve(vaultAddress, amount);\n```\n\n### 2. Calculate Deposit Fee\nQuery the `getDepositFee` function to determine the gas required for the cross-chain message.\n\n```javascript\nconst depositInput = {\n  accountId: orderlyAccountIdBytes, // bytes32\n  brokerHash: keccak256(brokerId),  // bytes32\n  tokenHash: keccak256(\"USDC\"),     // bytes32\n  tokenAmount: amount               // uint128\n};\n\nconst fee = await vaultContract.getDepositFee(userAddress, depositInput);\n```\n\n### 3. Execute Deposit\nCall the `deposit` function, passing the calculated fee as native value (ETH/BNB/etc.).\n\n```javascript\nawait vaultContract.deposit(depositInput, { value: fee });\n```\n\n### Deposit Data Structure\nThe `depositInput` struct requires:\n- `accountId`: `keccak256(abi.encode(address, bytes32))` where bytes32 is `keccak256(brokerId)`.\n- `brokerHash`: `keccak256(brokerIdString)`.\n- `tokenHash`: `keccak256(tokenString)`.\n- `tokenAmount`: Amount in smallest unit (wei/atoms).\n\n## Fees\n- **Deposit Fees**: Orderly does not charge a deposit fee. However, users pay the network gas and LayerZero cross-chain messaging fee. This varies by chain and congestion.\n- **Withdrawal Fees**: Varies by chain (e.g., ~1 USDC on Solana/Arbitrum, ~10 USDC on Ethereum).\n\n## Subaccounts\n- **Restrictions**: Only the main account can perform deposits and withdrawals. Subaccounts are for internal transfers only.\n- **Flow**: Deposits always credit the main account first. Users must then transfer funds to subaccounts if needed.\n\n## Contract Addresses\nRefer to the official documentation for the specific Vault addresses on Arbitrum, Optimism, Base, Polygon, and other supported networks.",
      "keywords": [
        "deposits",
        "withdrawals",
        "vault contract",
        "LayerZero",
        "subaccounts",
        "cross-chain",
        "gas fees"
      ]
    },
    {
      "id": "orders-85",
      "title": "Broker IDs, Account Registration, and Fees",
      "category": "Overview",
      "content": "Understanding Broker IDs, account structure, and the fee model is crucial for integrating with Orderly Network.\n\n## Broker IDs\nA Broker ID represents your application (dApp) on Orderly.\n- **Uniqueness**: Each builder requires a unique Broker ID to segregate users and configurations.\n- **Development**: You can use documented demo Broker IDs for initial testing.\n- **Production**: Contact the Orderly team to create your specific Broker ID. Setup is typically quick.\n- **Casing**: Broker IDs should be **lowercase**. Using mixed case can lead to integration issues.\n\n## Account Registration\nUsers must register their wallet with Orderly before trading. This involves signing an EIP-712 message.\n\n### EIP-712 Domain\n```json\n{\n  \"name\": \"Orderly\",\n  \"version\": \"1\",\n  \"chainId\": 291, // Orderly L2 Chain ID\n  \"verifyingContract\": \"0x0000000000000000000000000000000000000000\" // Placeholder\n}\n```\n*Note: The `verifyingContract` is a placeholder as there is no single smart contract verifying off-chain orders directly on L2 for this specific message type in all contexts, though the Ledger contract is used for withdrawals.*\n\n### Registration Types\n```javascript\nconst types = {\n  EIP712Domain: [\n    { name: \"name\", type: \"string\" },\n    { name: \"version\", type: \"string\" },\n    { name: \"chainId\", type: \"uint256\" },\n    { name: \"verifyingContract\", type: \"address\" }\n  ],\n  Registration: [\n    { name: \"brokerId\", type: \"string\" },\n    { name: \"chainId\", type: \"uint256\" },\n    { name: \"timestamp\", type: \"uint64\" },\n    { name: \"registrationNonce\", type: \"uint256\" }\n  ]\n};\n```\n\n### Account ID Calculation\nThe internal Account ID is derived from the user's address and the Broker ID.\n\n```typescript\nimport { ethers } from 'ethers';\n\nfunction getAccountId(userAddress: string, brokerId: string): string {\n  const brokerHash = ethers.solidityPackedKeccak256(['string'], [brokerId]);\n  const abiCoder = ethers.AbiCoder.defaultAbiCoder();\n  return ethers.solidityPackedKeccak256(\n    ['bytes'],\n    [abiCoder.encode(['address', 'bytes32'], [userAddress, brokerHash])]\n  );\n}\n```\n\n## Fee Structure\nOrderly uses a tiered fee model based on volume and staking.\n\n### Base Fees vs. User Fees\n- **Base Fee**: The fee charged by Orderly protocol (e.g., 3 bps taker, 0 bps maker).\n- **User Fee**: The fee displayed to and paid by the user.\n- **Broker Revenue**: The difference between the User Fee and the Base Fee.\n  - *Example*: If User Fee is 6 bps and Base Fee is 3 bps, the Broker earns 3 bps.\n\n### Fee Tiers\n- **Public**: 3.00 bps taker (default).\n- **Silver/Gold/Platinum**: Lower base fees available based on 30-day aggregate volume and $ORDER staking.\n\n### Referral Codes\n- **Format**: 4-10 characters, uppercase letters and numbers only.\n- **Creation**: Managed via the Orderly Admin Console.\n- **Priority**: `order_tag` in an order overrides the user's default referral code.\n\n## Broker Migration\nChanging Broker IDs creates a completely new account context. Users will not see balances or positions associated with the old Broker ID. Always maintain the same Broker ID for production to preserve user access.",
      "keywords": [
        "broker ID",
        "account registration",
        "EIP-712",
        "fee structure",
        "referral codes",
        "account ID",
        "tiered fees"
      ]
    },
    {
      "id": "orders-86",
      "title": "PnL Settlement and Liquidation Mechanics",
      "category": "Trading",
      "content": "This guide details how Profit and Loss (PnL) is handled and the liquidation process on Orderly Network.\n\n## PnL and Unsettled PnL\n- **Unsettled PnL**: Realized profit or loss from closed positions that has not yet been credited to or debited from the available balance.\n- **Settlement**: The process of moving Unsettled PnL to the settled balance. This requires an on-chain transaction on Orderly L2 and incurs gas costs.\n\n### Handling 0-Quantity Positions\nWhen a position is closed, it may temporarily remain as a \"0-qty\" position holding Unsettled PnL.\n- **UI Recommendation**: It is safe to hide 0-qty positions from the UI to avoid user confusion.\n- **Auto-Settlement**: Builders generally avoid auto-settling on every close to save gas costs. Users typically settle manually when needed.\n\n## Liquidation\nOrderly uses a cross-margin model where all positions share the same collateral pool.\n\n### Liquidation Trigger\nLiquidation occurs when the account's margin ratio falls below the Maintenance Margin Requirement (MMR).\n\n### Liquidation Fee Distribution\nWhen a position is liquidated:\n- **50%** of the liquidation fee goes to the liquidator.\n- **50%** goes to the Insurance Fund.\n\n### Verification\nYou can view liquidation records on the Orderly Dashboard by searching for the user address and Broker ID. Note that the dashboard may not show the specific open orders (like Stop Loss) that were active at the time of liquidation.\n\n## Margin Modes\n- **Current Support**: Only Cross Margin is supported.\n- **Isolated Margin**: Planned for future release but not currently available.",
      "keywords": [
        "PnL settlement",
        "liquidation",
        "cross margin",
        "insurance fund",
        "unsettled PnL",
        "maintenance margin"
      ]
    },
    {
      "id": "orders-87",
      "title": "Orderly One DEX Configuration and Customization",
      "category": "Operations",
      "content": "Orderly One allows builders to launch and customize a DEX with minimal code. This section covers configuration, domains, and branding.\n\n## Graduation and Broker ID\n- **Graduation**: The process of moving from a demo setup to a production Broker ID.\n- **Broker ID Creation**: Graduation creates the Broker ID on Mainnet. For Testnet, use the dedicated Testnet Admin UI.\n- **Revenue**: You only earn broker revenue after graduating and using your own Broker ID.\n\n## Custom Domain Setup\nTo use your own domain (e.g., `app.yourdex.com`):\n\n### 1. DNS Configuration\nAdd a **CNAME** record at your domain provider.\n- **Type**: CNAME\n- **Host/Name**: `app` (or your chosen subdomain)\n- **Value**: `orderlynetworkdexcreator.github.io`\n\n*Note: Do not use mixed case in domain configuration within Orderly One.*\n\n### 2. Orderly One Configuration\n1. Go to the DEX Management page.\n2. Enter your domain (lowercase) in the domain field.\n3. Click \"Update DEX Configuration\".\n\n### 3. SSL/HTTPS\n- **Propagation**: SSL certificate issuance can take 1-2 days. The DEX may not load correctly until the certificate is valid.\n- **Enforce HTTPS**: Enable \"Enforce HTTPS\" in the settings to redirect HTTP traffic automatically.\n\n## Customization\n### Branding\n- **Logos**: Upload logos in PNG format for transparency support. Configure both Primary and Secondary Logos to prevent branding reverting to Orderly defaults during interactions.\n- **Colors**: Modify theme colors (Primary, Base Foreground) to change UI accents like navigation links and text colors.\n\n### CSS Overrides\nYou can inject custom CSS to hide or modify elements.\n\n**Example: Hiding \"Powered by Orderly\" Footer**\n```css\n.oui-scaffold-footer-powered-by {\n  display: none;\n}\n```\n*Apply this in Edit Desktop -> Theme -> Edit CSS.*\n\n### Navigation\nConfigure which pages appear in the main navigation menu and their order via the Orderly One settings.\n\n## Points and Leaderboards\n- **Points System**: Orderly One supports a built-in, customizable points system that can be activated in a few clicks.\n- **Leaderboards**: PnL-based leaderboards are supported. To show user nicknames, you must integrate an external user profile system as Orderly does not store handles.",
      "keywords": [
        "Orderly One",
        "custom domain",
        "DNS",
        "SSL",
        "branding",
        "CSS customization",
        "graduation"
      ]
    },
    {
      "id": "orders-88",
      "title": "Order Lifecycle and Management",
      "category": "Trading",
      "content": "Managing orders effectively is critical for any trading integration. This guide covers the lifecycle of an order, from creation and validation to modification, cancellation, and status tracking within the Orderly Network ecosystem.\n\n### Order Creation and Validation\n\nWhen creating orders, precision and validation are key. Use the `useOrderEntry` hook to manage order state and perform pre-submission checks.\n\n**Precision Rules:**\n- `order_quantity` must be provided with a numeric precision within 8 digits.\n\n**Validation:**\nAlways validate orders before submission to ensure they meet margin and risk requirements.\n\n```typescript\nimport { useOrderEntry } from \"@orderly.network/hooks\";\n\nconst { helper, submit, submitting } = useOrderEntry(symbol, { \n  initialOrder: { /* ... */ } \n});\n\nconst handleSubmit = async () => {\n  // Validate the order\n  const result = await helper.validate();\n  if (result) {\n    console.error(\"Validation failed:\", result);\n    return;\n  }\n\n  // Submit the order\n  await submit();\n};\n```\n\n### Editing and Cancelling Orders\n\nOrderly provides hooks to modify or cancel existing orders programmatically.\n\n**Editing an Order:**\nUse `updateOrder` from `useOrderStream` to modify order parameters.\n\n```typescript\nconst [_, { updateOrder }] = useOrderStream({ status: OrderStatus.INCOMPLETE });\n\nconst onEdit = async (orderId, values) => {\n  const res = await updateOrder(orderId, values);\n  return res;\n};\n```\n\n**Cancelling an Order:**\nUse `cancelOrder` to remove an active order.\n\n```typescript\nconst [_, { cancelOrder }] = useOrderStream({ status: OrderStatus.NEW });\n\nconst onCancel = async (orderId) => {\n  const res = await cancelOrder(orderId);\n  return res;\n};\n```\n\n### Order Statuses\n\nOrders transition through various states. Use the `OrderStatus` enum to track these changes:\n- `OPEN`: Order is active on the book.\n- `NEW`: Order has been received but not yet processed.\n- `PARTIAL_FILLED`: Order has been partially executed.\n- `FILLED`: Order has been completely executed.\n- `CANCELLED`: Order was cancelled by the user or system.\n- `REJECTED`: Order was not accepted (e.g., insufficient margin).\n\n### Client Order IDs\n\nUse `client_order_id` to attach a custom identifier to your orders. This ID must be unique among open orders. If a new order is submitted with a `client_order_id` that already exists on an open order, the new order will be rejected.\n\n```typescript\n// Query order by client_order_id\nconst order = await GET /v1/client/order/{client_order_id};\n```",
      "keywords": [
        "order lifecycle",
        "validation",
        "cancellation",
        "edit order",
        "client order id",
        "order status",
        "useOrderEntry"
      ]
    },
    {
      "id": "orders-89",
      "title": "Algo Orders: TP/SL Management",
      "category": "Trading",
      "content": "Algorithmic orders, specifically Take-Profit (TP) and Stop-Loss (SL) orders, allow for automated risk management. This section details how to create, manage, and track TP/SL orders using the Orderly SDK.\n\n### TP/SL Order Structure\n\nTP/SL orders can be hierarchical. A root order may contain child orders (e.g., a TP order and an SL order). The `ComputedAlgoOrder` type is used to handle the state of these orders, including computed fields for offsets and PnL.\n\n**Key Computed Fields:**\n- `sl_offset`: Stop loss price offset.\n- `sl_offset_percentage`: Stop loss percentage offset.\n- `tp_offset`: Take profit price offset.\n- `tp_offset_percentage`: Take profit percentage offset.\n\n```typescript\n// Updating TP/SL fields\nsetValues({\n  quantity: 0.1,\n  tp_offset_percentage: 10,\n  sl_offset_percentage: 5,\n});\n```\n\n### Managing TP/SL Orders\n\nYou can cancel all TP/SL orders or target specific child orders within a strategy.\n\n**Cancel All TP/SL Orders:**\n```typescript\nconst [_, { cancelAllTPSLOrders }] = useOrderStream();\nawait cancelAllTPSLOrders();\n```\n\n**Cancel Specific Child Order:**\nTo cancel only the TP or SL leg of a strategy, use the child order ID and the root order ID.\n\n```typescript\nconst [_, { cancelTPSLChildOrder }] = useOrderStream();\nawait cancelTPSLChildOrder(childOrderId, rootAlgoOrderId);\n```\n\n### Filtering and Tracking\n\nFilter the order stream to display only TP/SL related orders.\n\n```typescript\nconst [orders] = useOrderStream({\n  includes: [AlgoOrderRootType.TP_SL, AlgoOrderRootType.POSITIONAL_TP_SL],\n});\n```\n\n### Execution Reports\n\nSubscribe to `algoexecutionreport` or `algoexecutionreportv2` via WebSocket to receive real-time updates on algo order status.\n\n**v2 Payload Structure:**\nThe v2 report provides a nested structure for hierarchical orders.\n```json\n{\n  \"rootAlgoOrderId\": 654400003,\n  \"algoOrderId\": 654400003,\n  \"status\": \"FILLED\",\n  \"childOrders\": [\n    { \"algoOrderId\": 654400004, \"status\": \"PENDING\" }\n  ]\n}\n```",
      "keywords": [
        "algo orders",
        "take profit",
        "stop loss",
        "TP/SL",
        "algoexecutionreport",
        "ComputedAlgoOrder",
        "cancelTPSLChildOrder"
      ]
    },
    {
      "id": "orders-90",
      "title": "Margin, Liquidation, and Settlement",
      "category": "Operations",
      "content": "Understanding margin requirements and liquidation mechanics is essential for maintaining account health and managing risk on Orderly Network.\n\n### Margin Modes\n\nOrderly currently supports **Cross-Margin** mode only. In this mode, your total USDC collateral is shared across all open positions to calculate a unified margin ratio.\n\n### Margin Ratios\n\nTwo key ratios determine the health of your account:\n1. **Account Margin Ratio (AMR):** The ratio of your equity to your total position value.\n2. **Maintenance Margin Ratio (MMR):** The minimum margin ratio required to keep positions open.\n\n**Liquidation Trigger:**\nAn account is subject to liquidation when `AMR < MMR`.\n\n### Calculating Free Collateral\n\nFree collateral represents the available funds to open new positions. It accounts for total collateral and the initial margin required by open orders.\n\n```typescript\nimport { FreeCollateralInputs } from \"@orderly.network/types\";\n\nconst inputs: FreeCollateralInputs = {\n  totalCollateral: new Decimal(\"1000\"),\n  totalInitialMarginWithOrders: 200\n};\n\nconst freeCollateral = calculateFreeCollateral(inputs);\n```\n\n### Settlement Process\n\nProfit and Loss (PnL) settlement occurs periodically. When a user calls to settle PnL, the system matches their unsettled PnL against accounts with opposing unsettled PnL.\n\n**Example:**\n- Account X has +20,000 USDC unsettled PnL.\n- Account A has -15,000 USDC unsettled PnL.\n- Account B has -5,000 USDC unsettled PnL.\n\n**Process:**\n1. X settles 15,000 vs A. X's balance increases by 15,000. Remaining unsettled: +5,000.\n2. X settles 5,000 vs B. X's balance increases by 5,000. Remaining unsettled: 0.\n\n### Programmatic Settlement\n\nYou can trigger settlement using the Account instance.\n\n```typescript\nconst account = useAccountInstance();\nawait account.settle();\n```",
      "keywords": [
        "margin",
        "liquidation",
        "AMR",
        "MMR",
        "settlement",
        "cross-margin",
        "free collateral"
      ]
    },
    {
      "id": "orders-91",
      "title": "Portfolio Integration Guide",
      "category": "SDK",
      "content": "Integrating the Orderly Portfolio module into your Next.js application provides users with a comprehensive view of their history, settings, and assets. This guide covers setup for both App Router and Pages Router architectures.\n\n### App Router Setup\n\nCreate route files that export the specific module pages.\n\n**History Page:**\nCreate `app/portfolio/history/page.tsx`:\n```typescript\nimport { HistoryModule } from \"@orderly.network/portfolio\";\nconst { HistoryPage } = HistoryModule;\n\nexport default function HistoryPageRoute() {\n  return <HistoryPage />;\n}\n```\n\n**Settings Page:**\nCreate `app/portfolio/setting/page.tsx`:\n```typescript\nimport { SettingModule } from \"@orderly.network/portfolio\";\nconst { SettingPage } = SettingModule;\n\nexport default function SettingPageRoute() {\n  return <SettingPage />;\n}\n```\n\n### Pages Router Setup\n\nFor the Pages Router, export the components directly from the route files.\n\n**History Page:**\nCreate `pages/portfolio/history.tsx`:\n```typescript\nimport { HistoryModule } from \"@orderly.network/portfolio\";\nexport default HistoryModule.HistoryPage;\n```\n\n**Settings Page:**\nCreate `pages/portfolio/setting.tsx`:\n```typescript\nimport { SettingModule } from \"@orderly.network/portfolio\";\nexport default SettingModule.SettingPage;\n```\n\n### Mobile Navigation\n\nTo handle navigation automatically within the Portfolio module, use the `PortfolioLayoutWidget` with a `routerAdapter`.\n\n```typescript\nimport { PortfolioLayoutWidget } from \"@orderly.network/portfolio\";\n\nconst routerAdapter = {\n  onRouteChange: ({ href, name }) => {\n    router.push(href);\n  },\n  currentPath: router.pathname,\n};\n\nfunction PortfolioLayout({ children }) {\n  return (\n    <PortfolioLayoutWidget routerAdapter={routerAdapter} current={router.pathname}>\n      {children}\n    </PortfolioLayoutWidget>\n  );\n}\n```",
      "keywords": [
        "portfolio",
        "next.js",
        "app router",
        "pages router",
        "history",
        "settings",
        "navigation"
      ]
    },
    {
      "id": "orders-92",
      "title": "UI Customization and Accessibility",
      "category": "SDK",
      "content": "Orderly UI components are designed to be customizable and accessible. This section explains how to theme the components and ensure they meet accessibility standards.\n\n### Theming with CSS Variables\n\nCustomize the look and feel by defining CSS variables in a `:root` selector. Note that color values should be provided as raw channels (without `rgb()`) to support Tailwind-style opacity modifiers.\n\n**Example `theme.css`:**\n```css\n:root {\n  /* Primary color (RGB channels only) */\n  --oui-color-primary: 182 79 255;\n  \n  /* Background color */\n  --oui-color-background: 27 32 40;\n  \n  /* Border radius */\n  --oui-rounded: 6px;\n  \n  /* Font family */\n  --oui-font-family: 'Manrope', sans-serif;\n}\n```\n\n**Incorrect vs Correct:**\n```css\n/* Incorrect */\n--oui-color-primary: rgb(182 79 255);\n\n/* Correct */\n--oui-color-primary: 182 79 255;\n```\n\n### Accessibility (A11y) Attributes\n\nOrderly UI components support standard ARIA attributes to ensure compatibility with screen readers and assistive technologies.\n\n**Common Attributes:**\n- **`aria-disabled`**: Indicates an element is disabled but visible. Accepts boolean or string.\n  ```tsx\n  <Button aria-disabled={true}>Disabled Button</Button>\n  ```\n\n- **`aria-expanded`**: Marks collapsible elements (e.g., dropdowns) as expanded or collapsed.\n  ```tsx\n  <div aria-expanded={isOpen}>Content</div>\n  ```\n\n- **`aria-haspopup`**: Indicates that an element controls a popup menu, dialog, or listbox.\n  ```tsx\n  <button aria-haspopup=\"menu\">Menu</button>\n  ```\n\n- **`aria-busy`**: Indicates a region is being updated (e.g., loading data).\n  ```tsx\n  <div aria-busy={isLoading}>Loading orders...</div>\n  ```\n\n- **`aria-current`**: Identifies the currently active item (e.g., in a pagination list or tabs).\n  ```tsx\n  <li aria-current=\"page\">Page 1</li>\n  ```\n\n- **`aria-modal`**: Marks a dialog as modal.\n  ```tsx\n  <Dialog aria-modal={true} />\n  ```",
      "keywords": [
        "theming",
        "css variables",
        "accessibility",
        "aria",
        "customization",
        "ui components",
        "a11y"
      ]
    },
    {
      "id": "orders-93",
      "title": "Chain Configuration and Types",
      "category": "Infrastructure",
      "content": "Orderly Network supports multiple blockchains. Properly configuring chain metadata ensures correct transaction handling and UI display.\n\n### Chain Identifiers\n\nA chain configuration requires both a numeric ID and a string-based chain ID.\n\n- `id: number`: A unique numeric identifier for the chain.\n- `chainInfo.chainId: string`: The standard EVM chain ID as a string (e.g., `\"0x1\"` for Ethereum Mainnet).\n\n### Native Currency Metadata\n\nDefine the native currency for the chain using `chainInfo.nativeCurrency`.\n\n```typescript\nconst chainConfig = {\n  chainInfo: {\n    nativeCurrency: {\n      decimals: 18,    // Token decimals\n      fix: 4,         // Display precision\n      name: \"Ether\",  // Currency name\n      symbol: \"ETH\"   // Currency symbol\n    },\n    // ... other config\n  }\n};\n```\n\n### Block Explorer Configuration\n\nProvide block explorer URLs to allow users to view transactions on-chain.\n\n```typescript\nconst chainConfig = {\n  blockExplorerName: \"Etherscan\",\n  chainInfo: {\n    blockExplorerUrls: [\n      \"https://etherscan.io\"\n    ]\n  }\n};\n```\n\n### Predefined Constants\n\nOrderly exports constants for supported chains to simplify integration.\n\n```typescript\nimport {\n  ARBITRUM_MAINNET_CHAINID,\n  ARBITRUM_MAINNET_CHAINID_HEX,\n  ARBITRUM_TESTNET_CHAINID\n} from \"@orderly.network/types\";\n\nconsole.log(ARBITRUM_MAINNET_CHAINID); // 42161\n```\n\n### Branding and UI\n\nUse the following fields to display chain information in your UI:\n- `chainName: string`: Full name of the chain.\n- `chainNameShort: string`: Abbreviated name.\n- `chainLogo: string`: URL or identifier for the chain logo.",
      "keywords": [
        "chain config",
        "chain id",
        "native currency",
        "block explorer",
        "arbitrum",
        "types",
        "metadata"
      ]
    },
    {
      "id": "positions-94",
      "title": "Position Data and PnL Calculations",
      "category": "SDK",
      "content": "This guide covers how to retrieve position data, calculate Profit and Loss (PnL), and understand the metrics returned by Orderly Network's SDKs.\n\n### Retrieving Position Data\nUse the `usePositionStream` hook to access real-time position data. Aggregated values such as `aggregated.unrealPnL`, `aggregated.notional`, and `aggregated.unsettledPnL` are denominated in **USDC**.\n\n```typescript\nconst { aggregated, dataSource } = usePositionStream();\n// aggregated.unrealPnL is in USDC\n```\n\n### Calculating ROI\nTo get the account-level unrealized Return on Investment (ROI):\n\n1.  **Use `usePositionStream`**: Read the `totalUnrealizedROI` field.\n2.  **Convert to Percentage**: Multiply the value by 100 (e.g., `0.0005` represents `0.05%`).\n\n**Note:** Unsettled PnL percent is not a built-in metric. If you need to calculate it manually:\n\n```typescript\n// Formula: Total Unsettled PnL % = (Total Unsettled PnL / (Total Value - Total Unsettled PnL)) * 100\nconst { totalValue, unsettledPnL } = useCollateral();\nconst unsettledPnLPercent = (unsettledPnL / (totalValue - unsettledPnL)) * 100;\n```\n\n### Calculating Tradable Balance\nTo compute the real-time balance available for opening new positions in a cross-margin account, you must include unrealized PnL.\n\n**Formula:**\n`Tradable Balance = (Settled Funds + Real-time Floating PnL) - Total Initial Margin Required`\n\n### Position Margin and Value\nWhen calculating position margin and value, always treat the **position size as an absolute value** to handle both long (positive) and short (negative) positions correctly.\n\n```typescript\n// Example: Accessing specific PnL fields from PositionExt\nconst position: PositionTPSLExt = ...;\n\nconst unrealizedPnL = position.unrealized_pnl; // number\nconst unrealizedROI = position.unrealized_pnl_ROI; // number\nconst unsettledPnL = position.unsettled_pnl; // number\nconst unsettledROI = position.unsettled_pnl_ROI; // number\nconst notional = position.notional; // number\nconst maintenanceMargin = position.mm; // number\n```",
      "keywords": [
        "PnL",
        "ROI",
        "usePositionStream",
        "unrealized PnL",
        "tradable balance",
        "USDC",
        "margin"
      ]
    },
    {
      "id": "positions-95",
      "title": "Margin and Leverage Calculations",
      "category": "Trading",
      "content": "Understanding margin requirements and leverage is critical for risk management. This section details the formulas for Initial Margin Ratio (IMR), Maintenance Margin Ratio (MMR), and Account Margin Ratio (AMR).\n\n### Key Formulas\n\n**1. Account Margin Ratio (AMR)**\nRepresents the health of the account. If there are no open positions, the default is 1000%.\n\n```text\nAccount Margin Ratio = Total Collateral Value / Sum(Abs(Position Notional i))\n```\n\n**2. Initial Margin Ratio (IMR)**\nRequired to open a position.\n\n```text\nIMR_i = Max(1 / Max Account Leverage, Base IMR_i, IMR Factor_i * Abs(Position Notional_i)^(4/5))\ninitial_margin_i = abs(position_notional_i * IMR_i)\n```\n\n**3. Maintenance Margin Ratio (MMR)**\nRequired to keep a position open.\n\n```text\nMMR_i = Max(Base MMR_i, (Base MMR_i / Base IMR_i) * IMR Factor_i * Abs(Position Notional_i)^(4/5))\nmaintenance_margin_i = abs(position_notional_i * MMR_i)\n```\n\n### SDK Implementation\nYou can use the `useMarginRatio` hook to retrieve these values dynamically. Note that in v2, `currentLeverage` can be `null`.\n\n```typescript\nconst { marginRatio, currentLeverage, mmr } = useMarginRatio();\n\n// Handle null leverage safely\nconst displayLeverage = currentLeverage ?? '-';\n```\n\n### Building a Leverage Slider\nUse `useLeverage` to get valid leverage steps (config) for your UI controls. The maximum supported leverage is **100x**.\n\n```typescript\nconst [maxLeverage, { config: leverageLevers }] = useLeverage();\nconst [leverage, setLeverage] = useState(() => maxLeverage ?? 0);\n\nconst leverageValue = useMemo(() => {\n  return leverageLevers.findIndex((item) => item === leverage);\n}, [leverage, leverageLevers]);\n\n// Map slider index to leverage value\n<Slider\n  min={0}\n  max={leverageLevers.length - 1}\n  value={[leverageValue]}\n  onValueChange={(value) => {\n    const _value = leverageLevers[value[0]];\n    setLeverage(_value);\n  }}\n/>\n```\n\n### Trading Conditions\nTo open a new futures position or execute a withdrawal, the account's **Margin Ratio must be higher than the Initial Margin Ratio (IMR)**.",
      "keywords": [
        "IMR",
        "MMR",
        "leverage",
        "margin ratio",
        "formulas",
        "useMarginRatio",
        "useLeverage"
      ]
    },
    {
      "id": "positions-96",
      "title": "Liquidations and Risk Management",
      "category": "Operations",
      "content": "This guide explains liquidation mechanics, fee calculations, and how to handle liquidation events via WebSocket streams.\n\n### Liquidation Triggers\nA position is liquidated if the Account Margin Ratio falls below the Maintenance Margin Ratio (MMR).\n\n*   **Low-tier Liquidation:** Involves multiple symbols.\n*   **High-tier Liquidation:** Involves a single symbol.\n\n### Liquidation Fees\nFees are charged to the user being liquidated and paid to the liquidator.\n\n**Low-tier (Multiple Symbols):**\n```text\nUser Liquidation Fee = Sum[Liquidation Fee(Symbol i) * Abs(Notional i)]\nLiquidator Fee = Sum[Liquidation Fee(Asset i) * Abs(Notional i)]\n```\n\n**High-tier (Single Symbol):**\n```text\nUser Liquidation Fee = Liquidation Fee(Symbol i) * Abs(Notional i)\nLiquidator Fee = Sum[Liquidation Fee(Asset i) * Abs(Notional i)]\n```\n\n### Partial vs. Full Takeover\nLiquidators may only take over a portion of a position if the notional value exceeds specific thresholds:\n*   **Low-tier:** Min 10,000 USDC.\n*   **High-tier:** Min 5,000 USDC.\n\nIf below the threshold, the liquidator must take over *all* positions (low-tier) or the *entire* position (high-tier).\n\n### Insurance Fund and ADL\nIf the Account Margin Ratio is too low to cover the minimum liquidator fee, remaining assets are transferred to the Insurance Fund. **Auto-Deleveraging (ADL)** is triggered if:\n1.  Liquidators do not take over positions.\n2.  Positions remain unclaimed on the Insurance Fund.\n3.  The Insurance Fund Margin Ratio falls below `min_insurance_fund_margin_ratio`.\n\n### WebSocket Liquidation Updates\nSubscribe to the `liquidation` topic to receive real-time updates. Messages are pushed within ~1 second of changes.\n\n```json\n{\n  \"topic\": \"liquidation\",\n  \"ts\": 1684926668235,\n  \"data\": [\n    {\n      \"liquidationId\": 1,\n      \"timestamp\": 1684821114917,\n      \"type\": \"liquidated\",\n      \"positionsByPerp\": [\n        {\n          \"symbol\": \"PERP_NEAR_USDC\",\n          \"positionQty\": 12.6,\n          \"liquidatorFee\": 0.0175\n        }\n      ]\n    }\n  ]\n}\n```",
      "keywords": [
        "liquidation",
        "ADL",
        "Insurance Fund",
        "liquidator fee",
        "WebSocket",
        "risk",
        "margin call"
      ]
    },
    {
      "id": "positions-97",
      "title": "PnL Settlement and Withdrawals",
      "category": "Operations",
      "content": "Profit and Loss (PnL) must be settled before it can be withdrawn. This section explains the settlement lifecycle and how to calculate withdrawable balances.\n\n### Settling PnL\nRealized and unrealized PnL from open or closed positions must be \"settled\" into the account's USDC balance.\n\n*   **Scope:** Settling PnL applies to the **entire account**, not individual positions.\n*   **Automation:** It is **not** performed automatically when closing a position. You must explicitly call the settle PnL function.\n*   **Funding:** Accrued funding is settled only when a PnL settlement is called on the account.\n\n### Withdrawable Balances\nUse the `useWithdraw` hook to determine how much a user can withdraw.\n\n```typescript\nconst { availableWithdraw, availableBalance, unsettledPnL } = useWithdraw();\n```\n\n*   **`availableWithdraw`**: The maximum balance withdrawable **immediately** without having to settle PnL.\n*   **`availableBalance`**: The balance available to withdraw **after** settling all outstanding unsettled PnL.\n*   **`unsettledPnL`**: PnL not yet settled into the account balance. If positive, it becomes withdrawable after settlement.\n\n### Common Issues\nIf a user deposits funds but the balance \"doesn't show up,\" check if they opened a position with maximum leverage and are currently at a loss. In this scenario, deposited funds may be absorbed by the Initial Margin requirement to keep the position open, rather than appearing as free balance.",
      "keywords": [
        "settlement",
        "withdrawal",
        "useWithdraw",
        "unsettled PnL",
        "funding",
        "USDC",
        "balance"
      ]
    },
    {
      "id": "positions-98",
      "title": "PnL Sharing and Poster UI Configuration",
      "category": "SDK",
      "content": "This guide covers how to configure the PnL sharing card (poster), including colors, background images, and layout customization using `shareOptions` and `usePoster`.\n\n### Configuring Colors and Backgrounds\nTo customize profit/loss colors and background images, use the `shareOptions` prop. Ensure you provide at least two background images to avoid selection bugs.\n\n```typescript\nshareOptions={{\n  pnl: {\n    profitColor: 'yellow',\n    lossColor: 'blue',\n    backgroundImages: [\n      '/images/poster_bg_1.png',\n      '/images/poster_bg_2.png',\n      // ... add more images\n    ],\n    layout: {\n      message: {\n        width: 100,\n        height: 25,\n        fontSize: 16,\n        position: { left: 300, top: 150 }\n      }\n    }\n  }\n}}\n```\n\n### Customizing Layout with `usePoster`\nYou can define a custom layout configuration (`PosterLayoutConfig`) to control the positioning and styling of text elements on the generated poster.\n\n```javascript\nexport const DefaultLayoutConfig = {\n  domain: { fontSize: 13, position: { left: 20, bottom: 17 } },\n  message: { fontSize: 20, color: \"white\", textBaseline: \"top\", position: { left: 20, top: 16 } },\n  position: { fontSize: 20, color: \"rgba(255,255,255,0.98)\", position: { left: 20, top: 70 } },\n  unrealizedPnl: {\n    fontSize: 36,\n    color: \"rgba(255,255,255,0.5)\",\n    secondaryColor: \"rgba(255,255,255,0.5)\",\n    position: { left: 20, top: 110 }\n  },\n  informations: {\n    fontSize: 12,\n    color: \"rgba(255, 255, 255, 0.8)\",\n    labelColor: \"rgba(255,255,255,0.36)\",\n    position: { left: 20, top: 150 }\n  },\n  updateTime: { fontSize: 10, color: \"rgba(255,255,255,0.5)\", textAlign: \"end\", position: { right: 15, bottom: 17 } }\n};\n```\n\n### Known Issues\n*   **Background Selection:** Providing fewer than two background images may cause the background selection feature to fail.\n*   **Title Color:** There is a known bug where `profitColor` and `lossColor` might not apply to specific title elements. This is expected to be fixed in a later version.",
      "keywords": [
        "PnL sharing",
        "poster",
        "usePoster",
        "shareOptions",
        "UI",
        "background images",
        "layout"
      ]
    },
    {
      "id": "deposits-99",
      "title": "OmniVault and Multi-Collateral Deposit Guide",
      "category": "Operations",
      "content": "This guide covers the implementation of deposits into the Orderly Network OmniVault and multi-collateral system, including address configuration, hash computation, and deposit constraints.\n\n### OmniVault Overview\nOmniVault supports omnichain deposits, allowing Liquidity Providers (LPs) to deposit USDC from supported networks (Arbitrum, Base, Optimism) into a unified strategy vault. You can deposit on one chain and withdraw/claim on another.\n\n### Contract Addresses\nYou must use chain-specific addresses for the Vault and Token contracts.\n\n**Mantle Mainnet:**\n*   **USDC.e:** `0x09bc4e0d864854c6afb6eb9a9cdf58ac190d0df9`\n*   **Vault:** `0x816f722424b49cf1275cc86da9840fbd5a6167e9`\n\n**Arbitrum Sepolia (Example):**\n*   **USDC:** `0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d`\n*   **Vault:** `0x0EaC556c0C2321BA25b9DC01e4e3c95aD5CDCd2f`\n\n*Always refer to the `/build-on-omnichain/addresses` endpoint for the latest list of networks and addresses.*\n\n### Computing Hashes\nTo execute a vault deposit, you must compute the `brokerHash` and `tokenHash` using the Keccak-256 algorithm on the UTF-8 bytes of the string values.\n\n**TypeScript (ethers v6):**\n```typescript\nconst encoder = new TextEncoder();\nconst brokerHash = keccak256(encoder.encode(\"woofi_pro\")); // Replace with your broker ID\nconst tokenHash = keccak256(encoder.encode(\"USDC\"));\n```\n\n**Python (web3.py):**\n```python\nbroker_hash = w3.keccak(text=\"woofi_pro\")\ntoken_hash = w3.keccak(text=\"USDC\")\n```\n\n**Java (BouncyCastle):**\n```java\nKeccak.Digest256 brokerHash = new Keccak.Digest256();\nbrokerHash.update(brokerId.getBytes(\"UTF-8\"));\nbyte[] brokerHashBytes = brokerHash.digest();\n```\n\n### Deposit Constraints\n*   **Minimum Deposit:** 10 USDC.\n*   **Lock-up Duration:** 2 days.\n    *   The lock-up begins at the start of the vault period during which the deposit is processed, not necessarily the exact transaction timestamp.\n    *   Shares are available for withdrawal only after the lock-up ends.\n*   **Strategy Provider:** The Strategy Provider deposits funds that remain locked to ensure alignment with LPs (\"skin in the game\").\n\n### Multi-Collateral Caps\nWhen dealing with multi-collateral deposits, be aware of the following limits:\n\n**Supported Collaterals:** USDT, ETH, SOL, BNB, YUSD, WBTC, USD1.\n\n**Per-User Maximums:**\n*   USDT: 500,000\n*   ETH: 100\n*   SOL: 2,000\n*   BNB: 500\n*   YUSD: 50,000\n*   WBTC: 5\n*   USD1: 500,000\n\n**Global Maximums (Selected Examples):**\n*   **USDT:** Arbitrum (2M), Ethereum (3M), BSC (4M)\n*   **ETH:** Arbitrum (1,000), Ethereum (500), Base (500)\n*   **SOL:** Solana (40,000)",
      "keywords": [
        "omnivault",
        "deposit",
        "keccak256",
        "brokerHash",
        "multicollateral",
        "vault addresses",
        "lock-up"
      ]
    },
    {
      "id": "deposits-100",
      "title": "SDK Implementation: Deposits and Withdrawals",
      "category": "SDK",
      "content": "This section explains how to use the Orderly SDK to handle deposit and withdrawal operations, including fee calculation and transaction execution.\n\n### Depositing Funds (`useDeposit`)\nThe `useDeposit` hook manages the deposit process, fee fetching, and destination information.\n\n**Key Properties:**\n*   `depositFee` (bigint): The fee required for the deposit transaction. Refreshes when quantity changes.\n*   `depositFeeRevalidating` (boolean): Indicates if the fee is being recalculated.\n*   `dst` (object): Contains destination token/network metadata.\n    *   `address`: Token address (defaults to USDC.address).\n    *   `chainId`: Target chain ID.\n    *   `network`: Network short name (e.g., \"Arbitrum\").\n    *   `symbol`: Token symbol (e.g., \"USDC\").\n\n**Example Implementation:**\n```tsx\nimport { useDeposit } from '@orderlynetwork/hooks';\n\nconst MyDepositComponent = () => {\n  const { \n    deposit,      // Function to execute transaction\n    depositFee,   // Current fee amount\n    quantity,     // Current state amount\n    setQuantity,  // Update amount (triggers fee refresh)\n    dst           // Destination info\n  } = useDeposit({ /* config */ });\n\n  const handleDeposit = async () => {\n    // Ensure user knows the fee\n    console.log(\"Fee:\", depositFee.toString());\n    \n    // Execute deposit\n    await deposit();\n  };\n\n  return (\n    <div>\n      <p>Target Network: {dst.network}</p>\n      <input \n        value={quantity} \n        onChange={(e) => setQuantity(e.target.value)} \n      />\n      <button onClick={handleDeposit}>Deposit</button>\n    </div>\n  );\n};\n```\n\n### Withdrawing Funds (`useWithdraw`)\nTo withdraw funds, use the `useWithdraw` hook. Note that you cannot withdraw directly from a sub-account; you must first transfer funds back to the main account.\n\n**Parameters:**\n*   `chainId`: The network ID to withdraw to.\n*   `amount`: The amount to withdraw.\n*   `token`: The token symbol (e.g., \"USDC\").\n*   `allowCrossChainWithdraw`: Boolean indicating if cross-chain withdrawal is permitted.\n\n**Example Implementation:**\n```tsx\nimport { useWithdraw } from '@orderlynetwork/hooks';\nimport { useAccountInstance } from '@orderlynetwork/hooks';\n\nconst MyWithdrawComponent = () => {\n  const { withdraw, availableWithdraw, isLoading } = useWithdraw();\n  const account = useAccountInstance();\n\n  const handleWithdraw = async () => {\n    await withdraw({\n      chainId: Number(account.chainId),\n      amount: availableWithdraw.toString(), // Withdraw max available\n      token: \"USDC\",\n      allowCrossChainWithdraw: false\n    });\n  };\n\n  return (\n    <button onClick={handleWithdraw} disabled={isLoading}>\n      Withdraw Max\n    </button>\n  );\n};\n```\n\n### Ether Adapter\nFor lower-level integration, the Ether adapter provides a direct deposit method:\n\n```typescript\n// adapter.deposit(from, to, amount)\nawait adapter.deposit(\n  \"0xUserAddress...\",\n  \"0xVaultAddress...\",\n  \"1000000\" // Amount in smallest unit\n);\n```",
      "keywords": [
        "useDeposit",
        "useWithdraw",
        "SDK",
        "React hooks",
        "deposit fee",
        "withdrawal",
        "Ether adapter"
      ]
    },
    {
      "id": "deposits-101",
      "title": "Chain-Specific Deposit Requirements (Solana & NEAR)",
      "category": "Operations",
      "content": "Different blockchains have specific requirements for successful deposits on Orderly Network. Below are the critical details for Solana and NEAR.\n\n### Solana Deposits\n**Mandatory Fee Fetching:**\nFor Solana deposits, it is **mandatory** to fetch the deposit fee and include it in the deposit transaction value. LayerZero fees are calculated on-chain and can fluctuate. Failure to include the correct fee will result in transaction failure.\n\n**Gas Requirements:**\nDepositing is an on-chain action. Ensure the depositing account holds sufficient native SOL to pay for gas fees. A common error is attempting to deposit without the necessary SOL balance for transaction execution.\n\n### NEAR Deposits and Storage\nNEAR utilizes a storage staking model. If a withdrawal appears stuck or a deposit fails to register properly, it is often due to storage management.\n\n**Registering Storage (`storage_deposit`)**\nBefore interacting with the asset manager, users must pay a storage registration fee.\n\n*   **Method:** `storage_deposit`\n*   **Arguments:**\n    ```json\n    {\n      \"account_id\": \"optional_near_account\",\n      \"registration_only\": true\n    }\n    ```\n*   **Payment:** You must attach a NEAR deposit. The minimum required amount can be found via `storage_balance_bounds`.\n*   **Behavior:** If `registration_only` is `true`, only the minimum amount is accepted. If the account already exists, this flag cannot be true.\n\n**Withdrawing Storage (`storage_withdraw`)**\nTo reclaim storage fees:\n*   **Method:** `storage_withdraw`\n*   **Arguments:** `{ \"amount\": \"amount_to_withdraw\" }` (optional)\n*   **Behavior:** If amount is `null`, the full available balance is refunded.\n\n**Closing Account (`storage_unregister`)**\n*   **Method:** `storage_unregister`\n*   **Arguments:** `{ \"force\": bool }`\n*   **Payment:** Attach exactly 1 yoctoNEAR.\n*   **Behavior:** If `force` is `true`, remaining tokens are burned, and the account closes.\n\n**Common Issue:**\nIf a withdrawal from the contract appears stuck, check if the user has paid the fungible-token storage registration fee. Once paid, withdrawals proceed normally.",
      "keywords": [
        "Solana",
        "NEAR",
        "storage deposit",
        "LayerZero fees",
        "gas fees",
        "storage_unregister",
        "blockchain specifics"
      ]
    },
    {
      "id": "deposits-102",
      "title": "Funding Rate Calculation and WebSocket Streams",
      "category": "API",
      "content": "This document details how funding rates are calculated on Orderly Network and how to subscribe to real-time estimated funding rate updates via WebSocket.\n\n### Calculation Logic\nThe Average Premium is calculated based on samples taken at regular intervals.\n\n*   **Sampling Interval:** Every 15 seconds.\n*   **Formula:** Arithmetic mean of all samples in the period.\n    $$ \\text{Average Premium} = \\frac{\\text{Premium}_1 + \\text{Premium}_2 + \\dots + \\text{Premium}_N}{N} $$\n\n**Sample Counts (N) by Interval:**\n*   **1-hour interval:** 240 samples\n*   **4-hour interval:** 960 samples\n*   **8-hour interval:** 1,920 samples\n\n### WebSocket Subscription\nTo receive real-time estimated funding rates, subscribe to the specific topic for your perpetual symbol.\n\n**Topic Format:** `{symbol}@estfundingrate`\n\n**Subscription Payload:**\n```json\n{\n  \"id\": \"clientID11\",\n  \"topic\": \"PERP_ETH_USDC@estfundingrate\",\n  \"event\": \"subscribe\"\n}\n```\n\n**Parameters:**\n*   `id` (string, required): Unique client identifier.\n*   `event` (string, required): `subscribe` or `unsubscribe`.\n*   `topic` (string, required): The symbol topic.\n\n**Response Payload:**\nUpdates are pushed every 15 seconds.\n```json\n{\n  \"topic\": \"PERP_ETH_USDC@estfundingrate\",\n  \"ts\": 1682242440000,\n  \"data\": {\n    \"symbol\": \"PERP_ETH_USDC\",\n    \"fundingRate\": 0.00046875,\n    \"fundingTs\": 1682242440000\n  }\n}\n```\n\n### SDK Usage\nYou can also fetch funding rates directly using the SDK hook:\n```typescript\nimport { useFundingRate } from '@orderlynetwork/hooks';\n\nconst fundingRate = useFundingRate(\"PERP_ETH_USDC\");\n```",
      "keywords": [
        "funding rate",
        "WebSocket",
        "API",
        "perpetuals",
        "estfundingrate",
        "calculation",
        "subscription"
      ]
    },
    {
      "id": "deposits-103",
      "title": "Troubleshooting Deposits and Withdrawals",
      "category": "Troubleshooting",
      "content": "This guide addresses common issues developers encounter when handling deposits and withdrawals on Orderly Network.\n\n### Issue: Withdrawal from Sub-account Fails\n**Symptom:** Attempting to withdraw funds results in an error or rejection.\n**Cause:** You cannot withdraw directly from a sub-account.\n**Solution:** You must perform an internal transfer to move funds from the sub-account back to the main account first. Once the funds are in the main account, proceed with the withdrawal.\n\n### Issue: On-chain Deposit Gas Errors\n**Symptom:** User submits a deposit on-chain (e.g., Solana, Ethereum) and receives a \"fee\" or \"gas\" related error.\n**Cause:** The user does not have sufficient native token balance to pay for the gas fees required by the blockchain network.\n**Solution:** Ensure the depositing wallet holds enough native tokens (e.g., SOL, ETH, BNB) to cover the gas cost of the deposit transaction.\n\n### Issue: Solana Deposit Transaction Fails\n**Symptom:** Transaction fails despite having gas.\n**Cause:** The deposit fee (LayerZero fee) was not fetched or included correctly in the transaction value. These fees vary and are calculated on-chain.\n**Solution:** Always fetch the current deposit fee via the API/SDK and explicitly include it in the transaction amount before signing.\n\n### Issue: NEAR Withdrawal Stuck / No Tokens Received\n**Symptom:** Transaction appears complete, but tokens are not received or the withdrawal is pending indefinitely.\n**Cause:** The user has not paid the NEAR fungible-token storage registration fee (`storage_deposit`).\n**Solution:** Instruct the user to call `storage_deposit` on the asset manager contract with the required NEAR deposit to register their account storage.\n\n### Issue: Withdrawal Delays\n**Symptom:** Withdrawal processing takes longer than usual (e.g., > 30 minutes).\n**Cause:** High network activity or minor system issues can cause delays. Historically, significant upticks in activity have resulted in delays of approximately 100 minutes.\n**Solution:** Check the Orderly Network status page. If the system is operational, advise the user to wait. If the delay exceeds expected windows (e.g., > 3 hours), investigate the specific transaction hash on the explorer.",
      "keywords": [
        "troubleshooting",
        "gas error",
        "sub-account",
        "withdrawal delay",
        "storage fee",
        "LayerZero",
        "failed transaction"
      ]
    },
    {
      "id": "withdrawals-104",
      "title": "Implementing Withdrawals with the useWithdraw Hook",
      "category": "SDK",
      "content": "The `useWithdraw` hook provides a comprehensive interface for handling withdrawal logic within your application. It manages default destination details, loading states, and the execution of withdrawal transactions.\n\n### Retrieving Default Destination Details\n\nThe hook returns a `dst` object that describes the default destination asset and network. This is useful for pre-filling forms or determining the active withdrawal context.\n\n```typescript\nconst { dst } = useWithdraw();\n\n// dst object structure:\n// - address: string | undefined (defaults to USDC.address)\n// - chainId: number (defaults to targetChain.network_infos.chain_id)\n// - network: string (defaults to targetChain.network_infos.shortName)\n// - decimals: number\n// - symbol: string\n```\n\nYou can use `dst.chainId` and `dst.symbol` as the default values when calling the withdraw function.\n\n### Executing a Withdrawal\n\nThe `withdraw` function returned by the hook requires a specific input object. It does not take positional arguments.\n\n```typescript\nconst { withdraw, dst } = useWithdraw();\n\nconst handleWithdraw = async () => {\n  try {\n    await withdraw({\n      allowCrossChainWithdraw: true,\n      amount: \"100.50\",\n      chainId: dst.chainId, // Use default from dst object\n      token: dst.symbol     // Use default from dst object\n    });\n  } catch (error) {\n    console.error(\"Withdrawal failed:\", error);\n  }\n};\n```\n\n### Managing Loading States\n\nTo provide a smooth user experience, utilize the `isLoading` boolean returned by the hook. This state remains true while withdrawal-related data is loading or the transaction is being processed.\n\n```typescript\nconst { withdraw, isLoading } = useWithdraw();\n\n<button onClick={handleWithdraw} disabled={isLoading}>\n  {isLoading ? \"Processing...\" : \"Withdraw\"}\n</button>\n```\n\n### Handling Withdrawal Constraints\n\nWithdrawal constraints such as minimum amounts and fees are available via `NetworkInfos`. Note that these fields are optional, so your integration must handle cases where they might be `undefined`.\n\n```typescript\n// Example: Accessing constraints from network info\nconst minAmount = networkInfo.minimum_withdraw_amount;\nconst fee = networkInfo.withdrawal_fee;\n\nif (minAmount !== undefined) {\n  console.log(`Minimum withdrawal: ${minAmount}`);\n}\n```",
      "keywords": [
        "useWithdraw",
        "withdraw",
        "SDK",
        "React hook",
        "NetworkInfos",
        "chainId",
        "token",
        "loading state"
      ]
    },
    {
      "id": "withdrawals-105",
      "title": "Understanding Transaction Hash Delays in Asset History",
      "category": "API",
      "content": "When querying the `/v1/asset/history` endpoint for withdrawal entries, you may encounter records where the `tx_hash` field is missing or empty. This behavior is expected due to the asynchronous nature of blockchain confirmations and data synchronization.\n\n### Why the tx_hash is Missing\n\nThe transaction hash represents the on-chain transaction ID. This ID is not immediately available the moment a withdrawal request is created off-chain. It must first be broadcast to the network, mined into a block, and then indexed back by the Orderly system.\n\n### Synchronization Latency\n\nThe time required for the `tx_hash` to appear varies depending on the destination network's block time and finality requirements. For example:\n\n*   **Polygon:** May require approximately **500 blocks** for confirmation and sync back to the Orderly Network.\n\n### Best Practices for Integration\n\nWhen displaying withdrawal history to users:\n\n1.  **Do not assume immediate presence:** Handle the `tx_hash` field being null or undefined in your UI logic.\n2.  **Display status:** Show a \"Processing\" or \"Confirming\" status if the `tx_hash` is absent but the withdrawal status indicates it is pending.\n3.  **Polling:** If you need to display the transaction link immediately after a user initiates a withdrawal, implement a polling mechanism to re-fetch `/v1/asset/history` until the `tx_hash` appears.",
      "keywords": [
        "tx_hash",
        "asset history",
        "API",
        "synchronization",
        "Polygon",
        "block confirmation",
        "withdrawal status",
        "latency"
      ]
    },
    {
      "id": "withdrawals-106",
      "title": "Withdrawal Fees and UI Categorization Logic",
      "category": "Operations",
      "content": "Managing user expectations regarding withdrawal costs and record categorization is crucial for a smooth operational experience. This section covers how internal transfers are displayed and how to mitigate high network fees.\n\n### Internal Transfer Categorization\n\nIn the Orderly Network ecosystem, internal transfers (transferring funds to another account) are categorized and logged as **withdrawals**.\n\n*   **UI Impact:** Users looking for their internal transfer history should check the **\"Withdrawal\"** tab, not a separate \"Transfer History\" section.\n*   **Implementation:** Ensure your frontend logic routes internal transfer records to the withdrawal history view to prevent user confusion.\n\n### Managing High Withdrawal Fees on Ethereum\n\nWithdrawing broker fees or assets directly to the Ethereum Mainnet can result in high costs, often leaving a noticeable remainder (e.g., ~$10) deducted from the withdrawal amount due to gas fees.\n\n#### Strategies to Reduce Costs\n\n1.  **Use Alternative Networks:** Withdraw via Layer 2 solutions or cheaper sidechains such as **Arbitrum** or **Base**. These networks offer significantly lower withdrawal fees (often a flat ~$1) compared to Ethereum Mainnet.\n2.  **DEX UI Preview:** Encourage users to perform withdrawals directly through your DEX interface. This allows the application to calculate and display the exact network fee *before* the user submits the transaction, ensuring transparency.\n\n#### Broker Fee Considerations\n\nIf you are a broker withdrawing accumulated fees, the network cost (cross-chain or gas) is deducted from the transfer amount. To maximize value, always prefer low-cost networks for the settlement layer.",
      "keywords": [
        "withdrawal fees",
        "broker fees",
        "Ethereum",
        "Arbitrum",
        "Base",
        "internal transfers",
        "UI categorization",
        "gas costs"
      ]
    },
    {
      "id": "subaccounts-107",
      "title": "Understanding Internal Transfer Permissions",
      "category": "Overview",
      "content": "In Orderly Network, internal transfers function differently depending on the relationship between the source and destination accounts. Understanding these distinctions is crucial for managing user funds effectively.\n\n### Transfer Types\n\n1.  **Main Account ↔ Sub-account:**\n    Transfers between a main account and its own sub-accounts generally work out of the box. These are considered internal movements of funds within the same entity.\n\n2.  **User ↔ User (Cross-Account):**\n    Transfers between two different user accounts (e.g., from User A's sub-account to User B's main account) are subject to stricter security controls. These transfers will fail by default unless specific infrastructure requirements are met.\n\n### The Role of Broker IDs\n\nTo enable User-to-User transfers, your application must utilize a specific **Broker ID**. This Broker ID acts as an identifier for your exchange or application within the Orderly Network. Simply having an account is insufficient; the Broker ID itself must be explicitly authorized to handle cross-account internal transfers.",
      "keywords": [
        "internal transfer",
        "subaccount",
        "permissions",
        "broker id",
        "cross-account",
        "user-to-user",
        "main account"
      ]
    },
    {
      "id": "subaccounts-108",
      "title": "Configuring Broker ID for Cross-Account Transfers",
      "category": "Operations",
      "content": "To enable internal transfers between different user accounts under your application, you must configure your Broker ID correctly. This process ensures that only authorized brokers can facilitate cross-account fund movements.\n\n### Prerequisites\n*   An active Orderly Network account.\n*   Admin access to create or manage Broker IDs.\n\n### Setup Steps\n\n**1. Create a Broker ID**\nIf you do not yet have your own Broker ID set up, you must create one first. This distinguishes your integration from others on the network.\n\n**2. Whitelist the Broker ID**\nOnce the Broker ID exists, it must be whitelisted specifically for internal transfers. Without this whitelist entry, any attempt to transfer funds between two distinct users will be rejected by the system.\n\n### Configuration Example\nWhile the exact API endpoint depends on your specific integration layer, the configuration generally involves registering your Broker ID with the transfer permission.\n\n```json\n{\n  \"broker_id\": \"your-app-broker-id\",\n  \"permissions\": {\n    \"internal_transfer\": true,\n    \"cross_account_transfer\": true\n  }\n}\n```\n\nAfter applying this configuration, user-to-user internal transfers performed under this Broker ID will be processed successfully.",
      "keywords": [
        "broker id",
        "whitelisting",
        "setup",
        "configuration",
        "cross-account",
        "internal transfer",
        "infrastructure"
      ]
    },
    {
      "id": "subaccounts-109",
      "title": "Troubleshooting Failed Internal Transfers",
      "category": "Troubleshooting",
      "content": "If you encounter issues where internal transfers succeed for main-to-sub accounts but fail for transfers between different users, follow this diagnostic guide.\n\n### Symptom\n*   **Success:** Transferring funds from `UserA_Main` to `UserA_Sub`.\n*   **Failure:** Transferring funds from `UserA_Sub` to `UserB_Main`.\n\n### Common Cause\nThe most likely cause is that your **Broker ID has not been whitelisted** for cross-account internal transfers. The network explicitly blocks user-to-user transfers for brokers that have not completed this setup step to prevent unauthorized fund movement.\n\n### Resolution Checklist\n\n1.  **Verify Broker ID Existence:**\n    Confirm that you are not using a default or shared Broker ID. You must have your own unique Broker ID created.\n\n2.  **Check Whitelist Status:**\n    Ensure your specific Broker ID has been added to the allowlist for internal transfers.\n\n3.  **Implement the Fix:**\n    *   Create the Broker ID if missing.\n    *   Contact the relevant administrative interface or support to whitelist the Broker ID for internal transfers.\n\nOnce the Broker ID is whitelisted, retry the transfer request. No code changes are typically required in the client-side logic; the authorization happens at the broker infrastructure level.",
      "keywords": [
        "troubleshooting",
        "transfer failed",
        "cross-account",
        "error",
        "broker id",
        "whitelisting",
        "user-to-user"
      ]
    },
    {
      "id": "errors-110",
      "title": "Broker Registration Tool: Single Broker ID Limitation",
      "category": "Troubleshooting",
      "content": "### Issue Description\n\nDevelopers using the broker registration tool may encounter a situation where the tool temporarily accepts only a single `broker_id` (e.g., \"aden\") instead of the intended configuration. This behavior was identified as a configuration bug within the tool itself.\n\n### Resolution\n\nThis issue has been identified and fixed by the Orderly Network team. Once the fix is deployed, the tool will function as expected.\n\n### Action Required for Builders\n\n**No immediate action is required.** Builders do not need to fork their codebase or roll back their implementations specifically to address this issue. The fix is applied at the tool configuration level, ensuring normal operations resume automatically upon deployment.",
      "keywords": ["broker registration", "broker_id", "configuration bug", "rollback", "tool fix"]
    },
    {
      "id": "errors-111",
      "title": "Handling Token Decimals on BNB Chain",
      "category": "Troubleshooting",
      "content": "### Issue Description\n\nWhen building a DEX UI on the BNB Chain, you may encounter issues where token amounts are displayed incorrectly or calculated wrongly. This typically occurs because BNB Chain tokens may have different decimal precision compared to other chains supported by Orderly Network.\n\n### Root Cause\n\nThe UI attempts to interpret token amounts using a standard decimal count (e.g., 18), but the specific token on BNB Chain might use a different value (e.g., 8). This mismatch causes the frontend to grab the wrong decimals for display and calculation logic.\n\n### Solution\n\nEnsure your UI logic dynamically fetches and utilizes the specific `decimals` property for each token from the chain's token metadata, rather than relying on a hardcoded constant.\n\n```javascript\n// Incorrect: Hardcoding decimals\nconst amount = rawAmount / Math.pow(10, 18);\n\n// Correct: Using dynamic decimals\nconst tokenDecimals = getTokenMetadata(tokenSymbol).decimals;\nconst amount = rawAmount / Math.pow(10, tokenDecimals);\n```\n\nAlways verify the decimal precision for tokens specifically on BNB Chain during integration testing.",
      "keywords": [
        "BNB Chain",
        "token decimals",
        "UI mismatch",
        "calculation error",
        "display values",
        "precision"
      ]
    },
    {
      "id": "errors-112",
      "title": "Resolving SWR Export Errors in Next.js",
      "category": "SDK",
      "content": "### Error Message\n\nYou may encounter the following error when using SWR with Orderly Network SDKs in a Next.js environment:\n\n```\nexport 'SWRConfig' (or other SWR exports) was not found in 'swr'\n```\n\n### Cause\n\nThis error occurs because SWR hooks and context providers rely on client-side features. In Next.js (specifically the App Router), components are Server Components by default, where client-side libraries like SWR cannot be imported directly.\n\n### Solution\n\nAdd the `'use client'` directive at the very top of the file where you are importing or using SWR-related exports.\n\n```tsx\n'use client'; // Add this line at the top\n\nimport { SWRConfig } from 'swr';\n\nexport default function Provider({ children }) {\n  return <SWRConfig>{children}</SWRConfig>;\n}\n```\n\nThis directive tells Next.js to render the component on the client side, allowing SWR to function correctly.",
      "keywords": ["Next.js", "SWR", "SWRConfig", "export error", "use client", "client component"]
    },
    {
      "id": "errors-113",
      "title": "Managing States in Referral Hooks",
      "category": "SDK",
      "content": "When integrating referral features, it is critical to handle loading and error states gracefully to ensure a smooth user experience. The Orderly SDK provides specific hooks to check referral codes and retrieve referral info.\n\n### Checking Referral Code Existence\n\nUse the `useCheckReferralCode` hook to verify if a code is valid before proceeding.\n\n```tsx\nimport { useCheckReferralCode } from '@orderly.network/hooks';\n\nfunction ReferralChecker({ code }) {\n  const { isExist, isLoading, error } = useCheckReferralCode(code);\n\n  if (isLoading) return <div>Checking code...</div>;\n  if (error) return <div>Error checking code.</div>;\n\n  return (\n    <div>\n      {isExist ? 'Code is valid!' : 'Code not found.'}\n    </div>\n  );\n}\n```\n\n### Retrieving Referral Information\n\nUse the `useReferralInfo` hook to get detailed data. Always check `isLoading` and `error` before attempting to read the data or call methods like `getFirstRefCode()`.\n\n```tsx\nimport { useReferralInfo } from '@orderly.network/hooks';\n\nfunction ReferralDashboard() {\n  const { isLoading, error, data, getFirstRefCode } = useReferralInfo();\n\n  if (isLoading) return <div>Loading referral data...</div>;\n  if (error) return <div>Failed to load data.</div>;\n\n  const firstCode = getFirstRefCode();\n\n  return <div>Your referral code: {firstCode}</div>;\n}\n```",
      "keywords": [
        "referral code",
        "useCheckReferralCode",
        "useReferralInfo",
        "loading state",
        "error handling",
        "hooks"
      ]
    },
    {
      "id": "errors-114",
      "title": "Copying Poster Images to Clipboard",
      "category": "SDK",
      "content": "The `usePoster` hook allows you to generate and copy poster images to the user's clipboard. This process involves checking browser support and handling potential asynchronous errors.\n\n### Implementation\n\nThe hook returns `canCopy` (boolean) and a `copy` function. You must verify `canCopy` is true before attempting to copy.\n\n```tsx\nimport { usePoster } from '@orderly.network/hooks';\n\nfunction SharePoster() {\n  const { canCopy, copy, error } = usePoster();\n\n  const handleCopy = async () => {\n    if (!canCopy) {\n      alert('Clipboard copying is not supported in this browser.');\n      return;\n    }\n\n    try {\n      await copy();\n      alert('Poster copied to clipboard!');\n    } catch (err) {\n      console.error('Failed to copy:', err);\n    }\n  };\n\n  return (\n    <div>\n      <button onClick={handleCopy} disabled={!canCopy}>\n        Copy Poster Image\n      </button>\n      {error && <p style={{ color: 'red' }}>Error: {error.message}</p>}\n    </div>\n  );\n}\n```\n\n### Error Handling\n\nIf the copy operation fails, the hook will set the `error` property to an `Error` object. Always check this state to provide feedback to the user if the action fails.",
      "keywords": [
        "usePoster",
        "clipboard",
        "copy image",
        "canCopy",
        "poster generation",
        "async error"
      ]
    },
    {
      "id": "configuration-115",
      "title": "Broker Setup and Fee Configuration",
      "category": "Operations",
      "content": "This guide covers the initial configuration of a broker on Orderly Network, including setting default fees and understanding broker tiers.\n\n### Initial Broker Setup\nWhen registering a new broker, you must provide the following core parameters:\n\n*   **broker_id**: The unique identifier for the broker.\n*   **broker_name**: The display name for the broker.\n*   **default_taker_fee**: The standard fee applied to taker orders.\n*   **default_maker_fee**: The standard fee applied to maker orders.\n\n**Fee Configuration:**\nFees are flexible. For example, setting the default taker fee to `0.03%` is explicitly allowed. These fees are not permanent; they can be modified later via the admin console as your strategy evolves.\n\n### Broker Tiers and Fee Verification\nOrderly Network supports broker tiers (e.g., Gold tier) which offer reduced base fees based on staking requirements.\n\n*   **Verification:** If you have staked for a specific tier (like Gold), the system will apply the corresponding base taker fee (e.g., 2.5 bps) automatically, even if the visual badge in the UI is delayed or unclear.\n*   **Troubleshooting:** If the UI badge does not reflect your expected tier, verify the actual fee values applied in the system or admin view rather than relying solely on the UI badge.\n\n### Common Issues\n\n*   **Issue:** Fees seem higher than expected after staking.\n    *   **Solution:** Check the `broker_taker_fee` value in the system configuration. Ensure the staking transaction for the tier (e.g., Gold) is fully confirmed.",
      "keywords": [
        "broker setup",
        "maker fee",
        "taker fee",
        "broker tier",
        "gold tier",
        "fees configuration",
        "staking"
      ]
    },
    {
      "id": "configuration-116",
      "title": "Defining Chain Configurations",
      "category": "Infrastructure",
      "content": "Orderly Network requires specific chain configuration objects to handle multi-chain interactions. This guide details the structure of the chain configuration object, distinguishing between top-level properties and the nested `chainInfo` object.\n\n### Top-Level Properties\nThese properties reside directly on the chain configuration object:\n\n*   `id` (number): A unique numeric identifier for the chain.\n*   `chainName` (string): The full human-readable name of the chain.\n*   `chainNameShort` (string): An abbreviated label for the chain (e.g., \"Arb\" for Arbitrum).\n*   `chainLogo` (string): A reference to the chain's logo asset.\n*   `minGasBalance` (number): The minimum gas balance required for on-chain operations.\n*   `minCrossGasBalance` (number): The minimum balance required for cross-chain operations.\n*   `maxPrepayCrossGas` (number): The maximum amount of gas allowed for prepayment in cross-chain scenarios.\n\n### The `chainInfo` Object\nThe `chainInfo` object contains EIP-3085-style wallet metadata.\n\n*   `chainId` (string): The Chain ID as a string (e.g., `\"421613\"`). **Note:** This must be a string, not a number.\n*   `rpcUrls` (string[]): Array of RPC endpoint URLs.\n*   `blockExplorerUrls` (string[]): Array of block explorer base URLs.\n*   `chainName` (string): The chain name used within the wallet provider context.\n*   `nativeCurrency` (object): Metadata about the native currency.\n    *   `decimals` (number): Default is often 18 or 6.\n    *   `fix` (number): A precision/formatting parameter (default often 4 or 6).\n    *   `name` (string): Currency name (e.g., \"ETH\").\n    *   `symbol` (string): Currency symbol (e.g., \"ETH\").\n\n### Example Configuration\n\n```typescript\nconst arbitrumConfig = {\n  id: 421613,\n  chainName: \"Arbitrum Sepolia\",\n  chainNameShort: \"Arb Sepolia\",\n  minGasBalance: 0.0002,\n  minCrossGasBalance: 0.002,\n  maxPrepayCrossGas: 0.03,\n  chainInfo: {\n    chainId: \"421613\", // Must be string\n    chainName: \"Arbitrum Sepolia\",\n    rpcUrls: [\"https://sepolia-rollup.arbitrum.io/rpc\"],\n    blockExplorerUrls: [\"https://sepolia.arbiscan.io\"],\n    nativeCurrency: {\n      name: \"Ether\",\n      symbol: \"ETH\",\n      decimals: 18,\n      fix: 4\n    }\n  }\n};\n```\n\n### Integration Notes\n*   **Sei Network:** Sei integration is generally automatic and requires no special custom chain configuration unless you have specific needs.\n*   **Block Explorers:** To construct explorer links, combine the base URL from `chainInfo.blockExplorerUrls` with specific paths (e.g., `/tx/<hash>`).",
      "keywords": [
        "chain configuration",
        "chainId",
        "rpc urls",
        "block explorer",
        "native currency",
        "gas balance",
        "multi-chain"
      ]
    },
    {
      "id": "configuration-117",
      "title": "Configuring Referral Codes and Rebates",
      "category": "Operations",
      "content": "This guide explains how to configure referral codes, specifically focusing on the rebate rate fields and their numeric formats.\n\n### Rebate Rate Fields\nWhen creating or updating a referral code, you will encounter three key fields:\n\n1.  `max_rebate_rate`: The maximum total share of the fee that can be distributed as rebates.\n2.  `referrer_rebate_rate`: The share allocated to the user who created the referral code (the referrer).\n3.  `referee_rebate_rate`: The share allocated to the user using the code (the referee).\n\n### Numeric Format\n**Important:** These values must be defined as **decimals (fractions)**, not basis points.\n\n*   **Example:** `0.1` represents 10%.\n*   **Example:** `0.5` represents 50%.\n\n### Logic and Constraints\n*   **Total Cap:** The sum of `referrer_rebate_rate` and `referee_rebate_rate` must not exceed `max_rebate_rate`.\n*   **Builder Share:** Any remainder of the fee (after rebates are deducted) remains with the builder/broker.\n*   **Flexibility:** You can configure codes so the referee receives a portion, and the code owner retains the ability to adjust the split between referrer and referee, provided they stay within the `max_rebate_rate` limit.\n\n### Dashboard Updates\nChanges to referral splits (rebate percentages) typically reflect immediately on the dashboard. If you do not see the update:\n1.  Refresh the admin console.\n2.  Verify the configuration in the backend settings.\n3.  In rare cases, recreating the referral link may be necessary if the dashboard cache is stale.",
      "keywords": [
        "referral code",
        "rebate rate",
        "referrer",
        "referee",
        "broker fees",
        "decimals",
        "revenue share"
      ]
    },
    {
      "id": "configuration-118",
      "title": "Client-Side Utilities and UI Configuration",
      "category": "SDK",
      "content": "This section details the usage of specific React hooks and configuration patterns for the Orderly Network frontend SDK.\n\n### Chain Lookup Hook\nUse the `useChains` hook to access supported chains and look up configurations by Chain ID.\n\n```typescript\nconst [chains, { findByChainId }] = useChains();\n\n// Lookup by numeric ID\nconst chainConfig = findByChainId(421613);\n```\n\n### Local Storage with TypeScript\nTo persist typed objects (like chart settings) in `localStorage`, use the `useLocalStorage` hook with generics.\n\n```typescript\ntype ChartConfig = {\n  timeframe: string;\n  indicators: string[];\n  theme: \"light\" | \"dark\";\n};\n\nconst [chartConfig, setChartConfig] = useLocalStorage<ChartConfig>(\"CHART_CONFIG\", {\n  timeframe: \"1h\",\n  indicators: [\"MA\", \"RSI\"],\n  theme: \"light\",\n});\n\n// Functional update\nconst toggleTheme = () => {\n  setChartConfig((prev) => ({\n    ...prev,\n    theme: prev.theme === \"light\" ? \"dark\" : \"light\",\n  }));\n};\n```\n\n### Debounced Callbacks\nTo configure a callback that fires immediately on the first click (leading edge) but ignores subsequent rapid clicks (trailing edge), use `useDebouncedCallback` with specific options.\n\n```typescript\nconst clickHandler = useDebouncedCallback(sendMail, 300, {\n  leading: true,\n  trailing: false,\n});\n\n<button onClick={clickHandler}>click me</button>\n```\n\n### Modal Management\nBind a modal handler to a specific ID and pass initial arguments using `useModal`.\n\n```typescript\nconst modalHandler = useModal(\"deposit-modal\", { asset: \"USDC\" });\n```\n\n### Routing Configuration\nStandard route paths for Portfolio mobile pages should align with the `PortfolioLeftSidebarPath` enum:\n*   History: `\"/portfolio/history\"`\n*   Settings: `\"/portfolio/setting\"`\n\n### UI Styling Limitations\n*   **SHORT Label Color:** Currently, the color of the \"SHORT\" label in the UI (indicating a loss) uses a hardcoded constant. It is not yet configurable via the standard profit/loss color configuration settings, though a fix is being investigated.",
      "keywords": [
        "useLocalStorage",
        "useChains",
        "useDebouncedCallback",
        "useModal",
        "typescript",
        "routing",
        "react hooks"
      ]
    },
    {
      "id": "other-119",
      "title": "API Symbol Formats and Fee Rate Interpretation",
      "category": "API",
      "content": "When interacting with Orderly Network APIs, understanding the correct data formats and units is crucial for avoiding errors and misinterpretations.\n\n### Symbol Format\nPublic endpoints often require the full perpetual symbol format rather than a short ticker. For example, querying market info for Bitcoin requires the full symbol string.\n\n**Incorrect:**\n```\nGET /v1/public/info/BTC\n```\n\n**Correct:**\n```\nGET /v1/public/info/PERP_BTC_USDC\n```\n\n### Fee Rate Units\nFee rates returned by endpoints such as `useAccountInfo` or broker APIs are typically expressed in **basis points (bps)**, not percentages.\n\n- **1 basis point (bps)** = 0.01%\n- **Example:** A `futures_maker_fee_rate` of `3` equals 0.03%, and a `futures_taker_fee_rate` of `6` equals 0.06%.\n\nWhen displaying these rates to users or performing calculations, ensure you convert from basis points to the decimal format required by your application logic.",
      "keywords": ["symbol format", "basis points", "fee rates", "API", "perpetuals", "public info"]
    },
    {
      "id": "other-120",
      "title": "Referral System Configuration and Rules",
      "category": "Operations",
      "content": "Orderly Network provides a robust referral system allowing brokers to incentivize user growth. Understanding the binding rules and rate configurations is essential for implementation.\n\n### Referral Code Uniqueness\nReferral codes are **unique system-wide**. You cannot reuse a code like \"TEALSTREET\" across multiple brokers or DEXs. If a code is already in use, you must generate a unique code for each specific broker context.\n\n### Fee Share Configuration\nWhen creating a referral code, you define the rebate rates. For example, to implement a system where the referrer receives 40% of the fee share:\n\n- `max_rebate_rate`: `0.4`\n- `referrer_rebate_rate`: `0.4`\n- `referee_rebate_rate`: `0`\n\n### Binding Rules and Attribution\nReferral volume typically updates within a few minutes. If volume or fee splits are not appearing, verify that:\n1. The referral code is correctly bound to the account.\n2. Binding is established at or before the invitee's DEX graduation.\n3. The binding is unidirectional and immutable (cannot be modified once set).\n\n**Note:** Cross-referrals (e.g., A invites B and B invites A) are prohibited.",
      "keywords": [
        "referral codes",
        "rebate rates",
        "fee share",
        "broker",
        "binding rules",
        "volume attribution"
      ]
    },
    {
      "id": "other-121",
      "title": "Broker Operations: Metrics, Graduation, and Fee Tiers",
      "category": "Operations",
      "content": "Managing a DEX on Orderly Network involves monitoring metrics, handling graduation processes, and configuring fee structures for users.\n\n### Dashboard Metrics\nDashboard statistics, including volume, are updated **hourly**. Campaign statistics also update hourly, though volume data may refresh faster (approximately every 10 minutes). Total volume sections are typically updated around 1–2 AM UTC.\n\n### DEX Graduation\nGraduating a DEX involves two steps:\n1. Create the broker ID and initiate graduation via the admin page.\n2. **Manually complete the graduation** on the specific graduation page.\n\nIf the second step is skipped, the `isGraduated` flag may remain `false` even after the initial admin setup.\n\n### Custom Fee Tiers\nBrokers can implement volume-based custom fee tiers (similar to WOOFi Pro) using the Custom Fees user flow.\n\n- **Implementation:** Update individual user fee rates based on your specific volume rules.\n- **Automation:** A volume-based fee tier admin tool is available to compute and batch-update user rates. This script is typically run daily, meaning fee changes can take up to 24 hours to apply.\n- **Verification:** Verify applied rates by checking the user in the DEX Leaderboard and reviewing their broker/user fee info in the admin console.",
      "keywords": [
        "broker metrics",
        "graduation",
        "fee tiers",
        "volume-based",
        "dashboard stats",
        "custom fees"
      ]
    },
    {
      "id": "other-122",
      "title": "Infrastructure and Deployment Guidelines",
      "category": "Infrastructure",
      "content": "Proper infrastructure setup ensures your DEX is accessible and secure. This section covers domains, DNS, and supported chains.\n\n### Custom Domains and HTTPS\nWhile waiting for an HTTPS certificate to be generated, you may temporarily access the DEX via HTTP. Once the certificate is ready, ensure traffic is routed to HTTPS.\n\n### Vercel DNS Configuration\nIf hosting on Vercel with subdomains like `app.<domain>`, create the following CNAME records:\n\n| Type | Name | Value |\n|------|------|-------|\n| CNAME | app | `cname.vercel-dns.com.` |\n| CNAME | testnet | `cname.vercel-dns.com.` |\n\n### Supported Chains\nOrderly Network supports multiple chains. While the general supported-chains page lists mainnets, specific testnet information (such as Monad) can be found in the omnichain addresses documentation.\n\n**Deprecated Testnets:**\n- ARB-Goerli and OP-Goerli are deprecated. Use **Sepolia** for Arbitrum and Optimism testing.\n\n### Broker Registration\nThere is a single broker-registration app for both mainnet and testnet. To configure for testnet, simply select a testnet network within the app interface.",
      "keywords": ["DNS", "Vercel", "HTTPS", "testnet", "broker registration", "domains"]
    },
    {
      "id": "other-123",
      "title": "SDK Hooks: Account State and Data Fetching",
      "category": "SDK",
      "content": "The Orderly SDK provides various hooks to manage account state, fetch chain data, and handle UI logic efficiently.\n\n### Managing Account State\nWhen using `useAccount`, you can check if the account state is fully resolved using the `validating` property. This is useful for gating UI elements or actions until initialization is complete.\n\n```typescript\nconst { account, state: { validating } } = useAccount();\n\nif (validating) {\n  // Show loading spinner or disable interactions\n  return <LoadingSpinner />;\n}\n\n// Proceed with rendering account data\n```\n\n### Fetching Chain and Collateral Data\nUse specific hooks to retrieve network and asset information:\n\n- **`useChain(tokenSymbol)`**: Fetches chain information for a specific token (e.g., `USDC`).\n- **`useCollateral(options?)`**: Fetches collateral data. You can control decimal precision using the `dp` option.\n\n```typescript\n// Fetch chains for USDC\nconst { chains, isLoading } = useChain(\"USDC\");\n\n// Fetch collateral with 6 decimal places\nconst collateral = useCollateral({ dp: 6 });\n```\n\n### Runtime Network Switching\nThe `networkId` cannot be changed at runtime. If a user needs to switch between mainnet and testnet, the application must trigger a page reload.",
      "keywords": [
        "useAccount",
        "SDK hooks",
        "validating state",
        "useChain",
        "useCollateral",
        "network switching"
      ]
    },
    {
      "id": "other-124",
      "title": "WebSocket Subscriptions and Data Streams",
      "category": "API",
      "content": "Real-time data is essential for trading interfaces. Orderly Network provides WebSocket streams for market data, execution reports, and account updates.\n\n### Execution Reports\nSubscribe to `executionreport` to receive real-time updates on order status. You can filter by specific symbols.\n\n```json\n{\n  \"id\": \"clientID3\",\n  \"topic\": \"executionreport\",\n  \"event\": \"subscribe\",\n  \"params\": {\n    \"symbol\": \"PERP_BTC_USDC,PERP_ETH_USDC\"\n  }\n}\n```\n\n### Market Data Streams\nSubscribe to various market data topics using specific topic formats.\n\n**24h Ticker:**\nTopic: `{symbol}@ticker`\nExample: `PERP_NEAR_USDC@ticker`\nInterval: 1s\n\n**Best Bid/Offer (BBO):**\nTopic: `{symbol}@bbo` (single) or `bbos` (all symbols)\nInterval: 10ms (single), 1s (all)\n\n**Kline (Candlesticks):**\nTopic: `{symbol}@kline_{time}`\nSupported Intervals: `1m`, `5m`, `15m`, `30m`, `1h`, `1d`, `1w`, `1M`\n\n### Asset Conversion Updates\nSubscribe to `assetconvert` to receive updates on collateral conversions (auto or manual). Messages include details such as `convertId`, `convertedAsset`, and `receivedQty`.",
      "keywords": ["WebSocket", "subscriptions", "executionreport", "ticker", "BBO", "market data"]
    },
    {
      "id": "other-125",
      "title": "Omnichain Addresses and Contract Integration",
      "category": "Infrastructure",
      "content": "Integrating with Orderly Network across multiple chains requires referencing the correct contract addresses for Vaults and tokens.\n\n### Finding Contract Addresses\nContract addresses for supported chains (Ethereum, BNB Smart Chain, Abstract, etc.) are listed in the omnichain documentation. You can also fetch ABIs directly from block explorers for verified contracts.\n\n**Example:**\nTo get the Vault ABI on Arbitrum Sepolia, visit the explorer:\n`https://sepolia.arbiscan.io/address/0x0c554ddb6a9010ed1fd7e50d92559a06655da482`\n\n### Abstract Network Example\n**Mainnet:**\n- USDC: `0x84A71ccD554Cc1b02749b35d22F684CC8ec987e1`\n- Vault: `0xE80F2396A266e898FBbD251b89CFE65B3e41fD18`\n\n**Testnet:**\n- USDC: `0xa0BB43E2eA7fcE91F07e628d72fD6333e80F47D2`\n- Vault: `0x2c65ea2eE7265df755d7258291202690c27C6d2d`\n\n### OmniVault\nThe OmniVault contract address (`0x70fe7d65ac7c1a1732f64d2e6fc0e33622d0c991`) is consistent across Arbitrum, Base, Optimism, and Sei. Shares in the OmniVault are **not** tokenized; they represent percentage ownership and are not transferable.",
      "keywords": ["contract addresses", "omnichain", "Vault", "USDC", "Abstract", "OmniVault"]
    },
    {
      "id": "enriched-126",
      "title": "Direct API Authentication (TypeScript)",
      "category": "API",
      "content": "# Direct API Authentication (TypeScript)\n\nThis guide demonstrates how to authenticate with the Orderly Network using direct API calls in TypeScript, bypassing the standard SDK. This approach is essential for developers building backend services, high-frequency trading bots, or applications requiring granular control over the request lifecycle.\n\n## When to use this approach\n\nWhile the Orderly SDK simplifies integration, implementing direct API authentication is preferred when:\n\n*   **Building Backend Services:** You need to execute trades or query data from a secure server environment without wallet popups.\n*   **Developing Trading Bots:** You require minimal latency and overhead, optimizing for execution speed.\n*   **Custom Logic:** You need to intercept, modify, or log requests before they are sent to the network.\n*   **Environment Constraints:** You are working in an environment where the full SDK is too heavy or difficult to bundle.\n\n## Prerequisites\n\nBefore you begin, ensure you have the necessary cryptographic libraries installed. We use `@noble/ed25519` for signing operations and `bs58` (or `ethers`) for encoding keys.\n\n```bash\nnpm install @noble/ed25519 bs58\n```\n\n## Authentication Overview\n\nOrderly Network utilizes a dual-key architecture to separate security concerns:\n\n1.  **Wallet Key:** Your standard Web3 wallet (e.g., MetaMask, Ethereum private key). This is used for **on-chain** operations like depositing funds or withdrawing to Layer 1.\n2.  **Orderly Key:** An Ed25519 keypair generated specifically for **off-chain** API interactions. This key signs requests for trading, account management, and data retrieval.\n\n**Why use two keys?**\nThis separation limits exposure. If your API key (Orderly Key) is compromised, an attacker can trade but cannot withdraw your on-chain funds to their own wallet. Conversely, your Wallet Key never touches the trading API directly, reducing the risk of accidental signing of malicious transactions.\n\n## The `signAndSendRequest` Function\n\nThis function is the core of the authentication flow. It constructs a canonical message, signs it using your private key, and attaches the necessary headers to the HTTP request.\n\n```typescript\nimport { getPublicKeyAsync, signAsync } from '@noble/ed25519';\nimport { encodeBase58 } from 'ethers';\n\nexport async function signAndSendRequest(\n  orderlyAccountId: string,\n  privateKey: Uint8Array | string,\n  input: URL | string,\n  init?: RequestInit | undefined\n): Promise<Response> {\n  // 1. Capture the current time.\n  // This is required to prevent replay attacks, where a valid request is intercepted and resent later.\n  const timestamp = Date.now();\n  const encoder = new TextEncoder();\n\n  const url = new URL(input);\n\n  // 2. Construct the \"message\" to sign.\n  // Orderly requires a specific format: timestamp + HTTP method + path + query string + body\n  // Any deviation from this order or format will result in a signature mismatch.\n  let message = `${String(timestamp)}${init?.method ?? 'GET'}${url.pathname}${url.search}`;\n  \n  // Append the body only if it exists (e.g., for POST/PUT requests)\n  if (init?.body) {\n    message += init.body;\n  }\n\n  // 3. Sign the message using Ed25519.\n  // This generates a cryptographic proof that you possess the private key associated with this request.\n  const orderlySignature = await signAsync(encoder.encode(message), privateKey);\n\n  // 4. Send the request with Orderly-specific headers.\n  return fetch(input, {\n    headers: {\n      // Set Content-Type based on the HTTP method\n      'Content-Type':\n        init?.method !== 'GET' && init?.method !== 'DELETE'\n          ? 'application/json'\n          : 'application/x-www-form-urlencoded',\n      \n      // Required Headers for Authentication:\n      \n      // 'orderly-timestamp': Must match the timestamp used in the message signature.\n      'orderly-timestamp': String(timestamp),\n      \n      // 'orderly-account-id': Identifies which account is performing the action.\n      'orderly-account-id': orderlyAccountId,\n      \n      // 'orderly-key': Your public key, prefixed with the algorithm type.\n      // Allows the server to look up your registered public key to verify the signature.\n      'orderly-key': `ed25519:${encodeBase58(await getPublicKeyAsync(privateKey))}`,\n      \n      // 'orderly-signature': The raw signature, Base64URL encoded.\n      'orderly-signature': Buffer.from(orderlySignature).toString('base64url'),\n      \n      // Merge with any custom headers provided in 'init'\n      ...(init?.headers ?? {})\n    },\n    ...(init ?? {})\n  });\n}\n```\n\n### How the headers work together\n\n1.  **`orderly-key`**: Tells the server *who* is making the request (which public key to use for verification).\n2.  **`orderly-timestamp`**: Tells the server *when* the request was created. The server will reject requests that are too old (usually > 60 seconds) to prevent replay attacks.\n3.  **`orderly-signature`**: Proves that the request was actually generated by the owner of the `orderly-key` at that specific timestamp.\n4.  **`orderly-account-id`**: Links the API key to a specific user account, as one user may have multiple API keys.\n\n## Complete Example: Placing an Order\n\nThe following example demonstrates how to use the helper function above to place a market order on the testnet.\n\n```typescript\nimport bs58 from 'bs58';\nimport { config } from 'dotenv';\nimport { webcrypto } from 'node:crypto';\n\nimport { signAndSendRequest } from './signer';\n\n// POLYFILL: Node.js versions < 19 do not have globalThis.crypto enabled by default.\n// @noble/ed25519 requires the Web Crypto API. This line ensures compatibility.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nif (!globalThis.crypto) globalThis.crypto = webcrypto as any;\n\n// Load environment variables (never hardcode private keys)\nconfig();\n\nasync function main() {\n  const baseUrl = 'https://testnet-api-evm.orderly.org';\n  \n  // The unique identifier for your Orderly account\n  const orderlyAccountId = '<orderly-account-id>';\n\n  // DECODING: Orderly Keys are typically stored as Base58 strings for safe transport/printing.\n  // We must decode them back into raw bytes (Uint8Array) for the signing library to use.\n  const orderlyKey = bs58.decode(process.env.ORDERLY_SECRET!);\n\n  // EXECUTE: Send a POST request to create an order\n  const res = await signAndSendRequest(orderlyAccountId, orderlyKey, `${baseUrl}/v1/order`, {\n    method: 'POST',\n    body: JSON.stringify({\n      symbol: 'PERP_ETH_USDC',\n      order_type: 'MARKET',\n      order_quantity: 0.01,\n      side: 'BUY'\n    })\n  });\n  \n  const response = await res.json();\n  console.log(response);\n}\n\nmain();\n```\n\n## Common Pitfalls and How to Avoid Them\n\n### 1. \"Invalid Signature\" Errors\n**Cause:** This is the most common error. It usually happens because the message string constructed for signing does not match exactly what the server constructs.\n**Solution:**\n*   **No Extra Spaces:** Ensure there are no trailing spaces or newlines in your message string.\n*   **Exact Order:** The order must be strictly `timestamp` + `method` + `path` + `query` + `body`.\n*   **Body Consistency:** If you are sending a JSON body, the string used in the `message` variable must be *identical* to the string sent in the request body. Do not sign the object; sign the stringified JSON.\n\n### 2. \"Unauthorized\" or \"Key Not Found\"\n**Cause:** The Orderly Key you are using has not been registered on-chain for the specified `orderly-account-id`.\n**Solution:**\n*   Ensure you have gone through the [Key Registration process](#) (link to relevant docs) via the SDK or smart contract interaction.\n*   Verify that the `orderly-account-id` in your code matches the account ID the key is bound to.\n\n### 3. Timestamp Sync Issues\n**Cause:** Your server's system clock is significantly out of sync with the Orderly Network servers.\n**Solution:**\n*   Ensure your server uses NTP (Network Time Protocol) to keep the clock accurate.\n*   The timestamp must be in milliseconds (`Date.now()`), not seconds.\n\n### 4. Node.js Crypto Compatibility\n**Cause:** `@noble/ed25519` relies on `globalThis.crypto`, which is missing in older Node.js versions.\n**Solution:**\n*   Always include the `webcrypto` polyfill shown in the example above if you are running in a Node.js environment older than v19.\n\n### 5. Key Encoding Confusion\n**Cause:** Mixing up Base58, Hex, or Uint8Array formats.\n**Solution:**\n*   Orderly typically provides keys in Base58. Use `bs58.decode()` to convert to the `Uint8Array` required by `@noble/ed25519`.\n*   Do not pass the raw Base58 string directly to the `signAsync` function.",
      "keywords": [
        "authentication",
        "api",
        "typescript",
        "ed25519",
        "signing",
        "direct integration",
        "backend"
      ],
      "source": "Generated from example repositories with AI enhancement",
      "generatedAt": "2026-02-04T19:10:12.970Z"
    },
    {
      "id": "enriched-127",
      "title": "Account Registration with EIP-712",
      "category": "API",
      "content": "# Account Registration with EIP-712\n\nThis guide explains how to register a new account on Orderly Network using EIP-712 typed data signing. This process cryptographically links your wallet address to an Orderly Account, enabling secure off-chain trading.\n\n## When to use this\n\nYou must perform this registration process when:\n*   **Onboarding a new user:** A user connects their wallet to your dApp for the first time.\n*   **Switching Brokers:** You are moving an account to a different Broker ID (e.g., migrating from `woofi_pro` to a custom broker).\n*   **Setting up a trading bot:** You are initializing a script that requires programmatic access to the Orderly Network.\n\n## Overview\n\nBefore you can trade on Orderly, you need to establish a secure identity. This involves three distinct steps:\n\n1.  **Register your wallet:** Prove ownership of your wallet address via a cryptographic signature to a Broker.\n2.  **Receive an Orderly Account ID:** The system maps your wallet to a unique, internal Orderly identifier.\n3.  **Create an Orderly Key:** Generate a dedicated API key for signing requests (covered in the next guide).\n\n**Why EIP-712?**\nWe use EIP-712 (typed structured data) rather than simple hash signing. This allows wallets like MetaMask to display the data you are signing in a human-readable format, significantly improving security and user experience by preventing users from signing malicious hex strings.\n\n## Prerequisites\n\n*   A Node.js environment.\n*   An Ethereum wallet (e.g., MetaMask) with a private key or provider.\n*   A registered Broker ID (e.g., `woofi_pro`).\n\n## Configuration\n\n### EIP-712 Domain Configuration\n\nThe domain separator ensures that signatures generated for Orderly Network cannot be replayed on other contracts or applications.\n\n```typescript\nconst OFF_CHAIN_DOMAIN = {\n  name: 'Orderly',                                      // DApp name to display in wallet\n  version: '1',                                         // Versioning for future upgrades\n  chainId: 421614,                                      // Arbitrum Sepolia testnet\n  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC' // Contract verifying the signature\n};\n```\n\n**Mainnet vs Testnet:**\n*   **Testnet chainId:** `421614` (Arbitrum Sepolia)\n*   **Mainnet chainId:** `42161` (Arbitrum One)\n\n> **⚠️ Critical:** Ensure the `chainId` in your code matches the network your wallet is currently connected to. A mismatch will cause the signature verification to fail.\n\n### Registration Message Type\n\nThis schema defines exactly what data is being signed.\n\n```typescript\nconst MESSAGE_TYPES = {\n  EIP712Domain: [\n    { name: 'name', type: 'string' },\n    { name: 'version', type: 'string' },\n    { name: 'chainId', type: 'uint256' },\n    { name: 'verifyingContract', type: 'address' }\n  ],\n  Registration: [\n    { name: 'brokerId', type: 'string' },         // Identifies the broker facilitating the account\n    { name: 'chainId', type: 'uint256' },         // Ensures the signature is valid for this specific chain\n    { name: 'timestamp', type: 'uint64' },        // Prevents replay attacks after time passes\n    { name: 'registrationNonce', type: 'uint256' }// Ensures the specific request is one-time use\n  ]\n};\n```\n\n## Complete Registration Example\n\nHere is the complete implementation. This script fetches a nonce, constructs the typed data, signs it with your wallet, and submits it to the Orderly API.\n\n```typescript\nimport { config } from 'dotenv';\nimport { ethers } from 'ethers';\n\n// Load environment variables (ensure PRIVATE_KEY is set in your .env file)\nconfig();\n\n// --- Configuration Constants ---\nconst MESSAGE_TYPES = {\n  EIP712Domain: [\n    { name: 'name', type: 'string' },\n    { name: 'version', type: 'string' },\n    { name: 'chainId', type: 'uint256' },\n    { name: 'verifyingContract', type: 'address' }\n  ],\n  Registration: [\n    { name: 'brokerId', type: 'string' },\n    { name: 'chainId', type: 'uint256' },\n    { name: 'timestamp', type: 'uint64' },\n    { name: 'registrationNonce', type: 'uint256' }\n  ]\n};\n\nconst OFF_CHAIN_DOMAIN = {\n  name: 'Orderly',\n  version: '1',\n  chainId: 421614, // Ensure this matches your network\n  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC'\n};\n\nconst BASE_URL = 'https://testnet-api-evm.orderly.org';\nconst BROKER_ID = 'woofi_pro';\nconst CHAIN_ID = 421614;\n\n// --- Main Registration Function ---\nasync function registerAccount(): Promise<void> {\n  // Initialize wallet from private key\n  const wallet = new ethers.Wallet(process.env.PRIVATE_KEY!);\n\n  // 1. Fetch a fresh nonce from the server\n  // Why: This prevents replay attacks. The server tracks which nonces have been used.\n  const nonceRes = await fetch(`${BASE_URL}/v1/registration_nonce`);\n  const nonceJson = await nonceRes.json();\n  const registrationNonce = nonceJson.data.registration_nonce as string;\n\n  // 2. Construct the message payload\n  // Why: We must include the nonce, timestamp, and broker ID to bind this signature to this specific request.\n  const registerMessage = {\n    brokerId: BROKER_ID,\n    chainId: CHAIN_ID,\n    timestamp: Date.now(), // Current time in milliseconds\n    registrationNonce\n  };\n\n  // 3. Sign the typed data\n  // Why: EIP-712 creates a cryptographically secure signature that the user can verify in their wallet UI.\n  const signature = await wallet.signTypedData(\n    OFF_CHAIN_DOMAIN,\n    {\n      Registration: MESSAGE_TYPES.Registration\n    },\n    registerMessage\n  );\n\n  // 4. Submit the registration payload to the API\n  const registerRes = await fetch(`${BASE_URL}/v1/register_account`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      message: registerMessage, // The original data\n      signature,                // The cryptographic proof\n      userAddress: await wallet.getAddress() // The address claiming ownership\n    })\n  });\n\n  const registerJson = await registerRes.json();\n\n  // Handle API errors\n  if (!registerJson.success) {\n    throw new Error(`Registration failed: ${registerJson.message}`);\n  }\n\n  // 5. Success: Retrieve the Orderly Account ID\n  const orderlyAccountId = registerJson.data.account_id;\n  console.log('Successfully registered. Orderly Account ID:', orderlyAccountId);\n}\n\n// Execute the function\nregisterAccount().catch(console.error);\n```\n\n## Step-by-Step Breakdown\n\n### 1. Get Registration Nonce\n\n```typescript\nconst nonceRes = await fetch(`${BASE_URL}/v1/registration_nonce`);\nconst nonceJson = await nonceRes.json();\nconst registrationNonce = nonceJson.data.registration_nonce;\n```\n\n**Why this is needed:**\nA nonce (number used once) ensures that even if a malicious actor intercepts your signature, they cannot reuse it to register a different account or perform a replay attack.\n\n**Common Pitfall:**\n*   **Stale Nonces:** Nonces expire quickly (usually within 2 minutes). Do not fetch a nonce, wait for user input, and then sign. Fetch the nonce immediately before triggering the signing process.\n\n### 2. Create Registration Message\n\n```typescript\nconst registerMessage = {\n  brokerId: 'woofi_pro',     // Your broker ID\n  chainId: 421614,           // Chain ID\n  timestamp: Date.now(),     // Current timestamp\n  registrationNonce         // From step 1\n};\n```\n\n**Why this is needed:**\nThis object creates a deterministic snapshot of the request. Changing any single character in this object will result in a completely different signature, ensuring data integrity.\n\n### 3. Sign with Wallet\n\n```typescript\nconst signature = await wallet.signTypedData(\n  OFF_CHAIN_DOMAIN,\n  { Registration: MESSAGE_TYPES.Registration },\n  registerMessage\n);\n```\n\n**Why this is needed:**\nThis generates the cryptographic proof. By using `signTypedData`, the wallet (e.g., MetaMask) will show a popup similar to:\n> *Sign this message to register with Orderly?*\n> *Broker: woofi_pro*\n> *Chain: 421614*\n\nThis transparency prevents phishing attacks where users are tricked into signing arbitrary transactions.\n\n### 4. Submit Registration\n\n```typescript\nconst registerRes = await fetch(`${BASE_URL}/v1/register_account`, {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    message: registerMessage,\n    signature,\n    userAddress: await wallet.getAddress()\n  })\n});\n```\n\n**Why this is needed:**\nThe server receives the message and the signature. It independently recreates the hash of the message using the public address provided. If the recovered address matches the signer, the account is created.\n\n### 5. Receive Account ID\n\n```typescript\nconst registerJson = await registerRes.json();\nconst orderlyAccountId = registerJson.data.account_id;\n// Example: `0x1234...abcd`\n```\n\n**Why this is needed:**\nThe `orderlyAccountId` is your permanent identifier within the Orderly ecosystem. You will need this ID (and your wallet address) to generate API keys for private endpoints in the next steps.\n\n## Common Pitfalls & Troubleshooting\n\n| Error / Issue | Cause | Solution |\n| :--- | :--- | :--- |\n| **\"Signature verification failed\"** | The `chainId` in the code does not match the network the wallet is connected to. | Ensure your wallet is on Arbitrum Sepolia (421614) if using testnet config. |\n| **\"Invalid nonce\"** | The nonce was fetched too long ago (expired) or was already used. | Fetch a new nonce immediately before calling `wallet.signTypedData`. |\n| **\"Invalid Broker ID\"** | The `brokerId` string does not match a registered broker on the network. | Verify your Broker ID with the Orderly team or documentation. |\n| **\"Timestamp expired\"** | The system time on your machine is significantly off, or the request took too long. | Sync your system clock and ensure the signing happens immediately after message creation. |\n\n## Next Steps\n\nNow that you have successfully registered and obtained your **Orderly Account ID**, you need to create an Orderly Key.\n\n*   **See:** [Creating Orderly Keys](#) (Link to relevant guide) to set up API authentication for trading.",
      "keywords": ["registration", "eip-712", "authentication", "account", "wallet", "signing"],
      "source": "Generated from example repositories with AI enhancement",
      "generatedAt": "2026-02-04T19:11:05.897Z"
    },
    {
      "id": "enriched-128",
      "title": "Creating Orderly Keys",
      "category": "API",
      "content": "# Orderly Network Authentication: Creating and Managing API Keys\n\nOrderly keys are Ed25519 keypairs used to authenticate API requests for trading, account management, and other interactions. This guide explains how to generate, register, and securely store these keys.\n\n## When to use this\n\nYou should create an Orderly Key when:\n*   **Building a Trading Bot:** You need automated access to place orders without manual intervention.\n*   **Developing a Custom Frontend:** You want users to trade without signing every individual transaction via their wallet (MetaMask, etc.).\n*   **Backend Integration:** Your server needs to monitor accounts or execute trades on behalf of users.\n\n**Why use a separate key?**\nUsing an Orderly Key separates *trading permissions* from *asset custody*. Your main wallet (EOA) holds funds and approves the creation of the Orderly Key, but the Orderly Key handles the day-to-day API requests. This limits exposure; if an Orderly Key is compromised, an attacker cannot withdraw funds directly from the wallet (depending on the scope granted).\n\n## What are Orderly Keys?\n\n- **Purpose**: Authenticate API requests (trading, account info, etc.) without requiring a wallet signature for every call.\n- **Format**: Ed25519 keypair (Public key for registration, Private key for signing requests).\n- **Storage**: You are responsible for managing the private key. Orderly does not store the private key.\n- **Expiration**: Keys can have specific expiration dates to enforce automatic rotation.\n\n## Prerequisites\n\nYou will need `ethers` for wallet interactions and `@noble/ed25519` for generating the keypair.\n\n```bash\nnpm install @noble/ed25519 ethers dotenv\n```\n\n## Complete Example\n\nThe following script generates a new Ed25519 keypair, creates the necessary EIP-712 payload, signs it with your main wallet to authorize the key, and registers it with the Orderly Network.\n\n```typescript\nimport { getPublicKeyAsync, utils } from '@noble/ed25519';\nimport { config } from 'dotenv';\nimport { encodeBase58, ethers } from 'ethers';\nimport { webcrypto } from 'node:crypto';\n\n// Polyfill for Web Crypto API in Node.js environments (required for noble libraries)\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nif (!globalThis.crypto) globalThis.crypto = webcrypto;\n\n// EIP-712 Type definitions ensure the data structure is signed correctly and prevents phishing\nconst MESSAGE_TYPES = {\n  EIP712Domain: [\n    { name: 'name', type: 'string' },\n    { name: 'version', type: 'string' },\n    { name: 'chainId', type: 'uint256' },\n    { name: 'verifyingContract', type: 'address' }\n  ],\n  AddOrderlyKey: [\n    { name: 'brokerId', type: 'string' },\n    { name: 'chainId', type: 'uint256' },\n    { name: 'orderlyKey', type: 'string' },\n    { name: 'scope', type: 'string' },\n    { name: 'timestamp', type: 'uint64' },\n    { name: 'expiration', type: 'uint64' }\n  ]\n};\n\n// The domain separator defines the context of the signature (Orderly Network on Arbitrum Sepolia)\nconst OFF_CHAIN_DOMAIN = {\n  name: 'Orderly',\n  version: '1',\n  chainId: 421614, // Arbitrum Sepolia Testnet\n  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC'\n};\n\nconst BASE_URL = 'https://testnet-api-evm.orderly.org';\nconst BROKER_ID = 'woofi_pro';\nconst CHAIN_ID = 421614;\n\n// Load environment variables (ensure your .env file contains PRIVATE_KEY)\nconfig();\n\nasync function createOrderlyKey(): Promise<void> {\n  // 1. Initialize your main wallet (the custodian of funds)\n  // This wallet authorizes the new Orderly Key.\n  const wallet = new ethers.Wallet(process.env.PRIVATE_KEY!);\n\n  // 2. Generate the Ed25519 Orderly Key pair\n  // This key will be used for signing API requests later.\n  const privateKey = utils.randomPrivateKey();\n  \n  // Format the public key with the 'ed25519:' prefix as required by Orderly\n  const orderlyKey = `ed25519:${encodeBase58(await getPublicKeyAsync(privateKey))}`;\n  \n  // Set timestamps for key validity\n  const timestamp = Date.now();\n  \n  // Construct the message payload\n  // This defines what permissions the key has and how long it lasts.\n  const addKeyMessage = {\n    brokerId: BROKER_ID,\n    chainId: CHAIN_ID,\n    orderlyKey,\n    scope: 'read,trading', // Grants permission to read data and place trades\n    timestamp,\n    expiration: timestamp + 1_000 * 60 * 60 * 24 * 365 // Valid for 1 year\n  };\n\n  // 3. Sign the message with your main Wallet\n  // This proves to Orderly that the owner of the wallet approves this new key.\n  const signature = await wallet.signTypedData(\n    OFF_CHAIN_DOMAIN,\n    {\n      AddOrderlyKey: MESSAGE_TYPES.AddOrderlyKey\n    },\n    addKeyMessage\n  );\n\n  // 4. Register the key with Orderly Network\n  const keyRes = await fetch(`${BASE_URL}/v1/orderly_key`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      message: addKeyMessage,\n      signature,\n      userAddress: await wallet.getAddress()\n    })\n  });\n  \n  const keyJson = await keyRes.json();\n  console.log('Registration Response:', keyJson);\n  \n  // IMPORTANT: Save the `privateKey` (Base58 encoded) securely here.\n  // You will need it to sign requests. If you lose it, you must create a new one.\n  console.log('Orderly Private Key (Base58):', encodeBase58(privateKey));\n}\n\ncreateOrderlyKey();\n```\n\n---\n\n## Step-by-Step Breakdown\n\n### 1. Generate Ed25519 Keypair\n\n**Why?** Orderly uses Ed25519 for off-chain request signing because it is computationally efficient and offers high security. This key is distinct from your Ethereum wallet key.\n\n```typescript\nimport { getPublicKeyAsync, utils } from '@noble/ed25519';\nimport { encodeBase58 } from 'ethers';\n\n// Generate a cryptographically secure random private key\nconst privateKey = utils.randomPrivateKey();\n\n// Derive the public key from the private key\nconst publicKeyBytes = await getPublicKeyAsync(privateKey);\n\n// Orderly requires the public key to be Base58 encoded and prefixed with 'ed25519:'\nconst orderlyKey = `ed25519:${encodeBase58(publicKeyBytes)}`;\n\n// Encode the private key for storage (Base58 is standard for Orderly)\nconst orderlySecret = encodeBase58(privateKey);\n```\n\n### 2. Create AddOrderlyKey Message\n\n**Why?** This message acts as a \"smart contract\" for off-chain data. It defines the rules of the key (permissions, expiration) in a structured format (EIP-712) that the user signs.\n\n```typescript\nconst addKeyMessage = {\n  brokerId: 'woofi_pro',      // Identifies the broker (e.g., Woofi Pro)\n  chainId: 421614,            // The network ID (must match wallet network)\n  orderlyKey,                 // The public key generated in Step 1\n  scope: 'read,trading',      // Permissions granted to this key\n  timestamp: Date.now(),      // Current time in milliseconds\n  expiration: timestamp + (365 * 24 * 60 * 60 * 1000) // 1 year from now\n};\n```\n\n**Understanding Scopes:**\nIt is best practice to request the minimum scope necessary.\n- `read`: Read account data, balances, and order history.\n- `read,trading`: Read data + place/cancel orders (most common for bots).\n- `read,asset`: Read data + manage deposits/withdrawals.\n- `read,trading,asset`: Full access to account features.\n\n### 3. Sign with Wallet\n\n**Why?** The Orderly Network needs to verify that the new Ed25519 key is actually authorized by the owner of the on-chain account. By signing this specific payload with your Wallet (Private Key), you create a cryptographic link between your on-chain identity and the off-chain Orderly Key.\n\n```typescript\n// signTypedData ensures the user signs exactly what is expected, preventing phishing\nconst signature = await wallet.signTypedData(\n  OFF_CHAIN_DOMAIN,           // Defines the network (Orderly on Arbitrum)\n  { AddOrderlyKey: MESSAGE_TYPES.AddOrderlyKey }, // The schema of the data\n  addKeyMessage               // The actual data payload\n);\n```\n\n### 4. Register Key with Orderly\n\n**Why?** This step sends the signed payload to the Orderly servers. Orderly verifies the signature against the blockchain state and, if valid, associates the new public key with your account.\n\n```typescript\nconst keyRes = await fetch(`${BASE_URL}/v1/orderly_key`, {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    message: addKeyMessage,   // The data defining the key\n    signature,                // The wallet signature proving ownership\n    userAddress: await wallet.getAddress() // The on-chain address\n  })\n});\n```\n\n### 5. Store Private Key Securely\n\n**Why?** Orderly **never** returns the private key once generated. If you lose the private key generated in Step 1, you cannot use this API key anymore (though you can always create a new one). Conversely, if someone steals it, they can trade with your permissions.\n\n**⚠️ IMPORTANT: Never expose the private key in client-side code or commit it to git.**\n\n**Storage Options:**\n- **Backend**: Environment variables or secret managers (AWS Secrets Manager, HashiCorp Vault).\n- **Frontend**: `localStorage` is convenient but vulnerable to XSS attacks. For production apps, consider encrypting the key with a user password or using a secure enclave.\n- **Mobile**: Use the device Keychain (iOS) or Keystore (Android).\n\n```typescript\n// Example: Saving to localStorage (Development only)\nlocalStorage.setItem('orderly_secret', encodeBase58(privateKey));\n\n// Retrieving for later use\nconst secret = localStorage.getItem('orderly_secret');\nif (secret) {\n  const privateKey = decodeBase58(secret);\n  // Use this key to sign requests\n}\n```\n\n---\n\n## Common Pitfalls & How to Avoid Them\n\n| Pitfall | Why it happens | Solution |\n| :--- | :--- | :--- |\n| **Invalid Chain ID** | Using Mainnet ID on Testnet or vice versa. | Ensure `CHAIN_ID` in the code matches the network your wallet is connected to. |\n| **Clock Skew** | Your server's time is out of sync. | Use NTP to sync your server clock. Orderly validates `timestamp` strictly. |\n| **Missing Prefix** | Sending the public key without `ed25519:`. | Always format the key as `ed25519:${base58Key}`. |\n| **Scope Mismatch** | Trying to withdraw with a `read,trading` key. | Check the `scope` in the registration message. Use `read,asset` or full scope for withdrawals. |\n| **Lost Private Key** | Generating a key but failing to save the output. | Print the key to console (in dev) or write directly to your secure storage immediately upon generation. |\n\n---\n\n## Using the Key\n\nOnce registered, you will use the **Orderly Private Key** (not the wallet private key) to sign HTTP requests to the Orderly API.\n\n```typescript\n// Pseudo-code for usage\n// See \"Direct API Authentication\" guide for the implementation of signAndSendRequest\n\nconst response = await signAndSendRequest(\n  orderlyAccountId,      // Your Orderly Account ID\n  orderlyPrivateKey,     // The Ed25519 private key generated in Step 1\n  'https://testnet-api-evm.orderly.org/v1/order',\n  {\n    method: 'POST',\n    body: JSON.stringify({ \n      symbol: \"PERP_BTC_USDC\",\n      side: \"BUY\",\n      // ... order parameters\n    })\n  }\n);\n```\n\n## Related Concepts\n\n- **EIP-712**: The standard used for typed structured data signing. [Read more](https://eips.ethereum.org/EIPS/eip-712).\n- **Direct API Authentication**: How to use the generated key to sign requests. (See next guide).\n- **WebAuthn**: An alternative authentication method supported by Orderly for hardware-backed security.\n\n## Security Best Practices\n\n1.  **Principle of Least Privilege:** Create separate keys for different tasks. Use a `read`-only key for monitoring bots and a `trading` key for execution bots.\n2.  **Environment Variables:** Never hardcode keys. Use `.env` files locally and secret managers in production.\n3.  **Key Rotation:** Set explicit `expiration` dates (e.g., 30 days) and automate the rotation process.\n4.  **Audit Logs:** Regularly check the Orderly dashboard or API for key usage to detect unauthorized access early.",
      "keywords": [
        "orderly key",
        "ed25519",
        "authentication",
        "api key",
        "key management",
        "security"
      ],
      "source": "Generated from example repositories with AI enhancement",
      "generatedAt": "2026-02-04T19:12:14.874Z"
    },
    {
      "id": "enriched-129",
      "title": "EIP-712 Message Types Reference",
      "category": "API",
      "content": "# EIP-712 Message Types Reference\n\nComplete reference of all EIP-712 typed data structures used for off-chain authentication and action execution within the Orderly Network.\n\n## When to use this\n\nYou should use these EIP-712 message types when building applications that require users to sign high-value or sensitive actions using their Web3 wallet (e.g., MetaMask, WalletConnect). Unlike standard API requests signed with an Orderly Key, EIP-712 signatures provide cryptographically secure, on-chain verifiable proof of user intent.\n\nCommon use cases include:\n*   **Onboarding:** Registering a new trading account.\n*   **Security Management:** Registering new API keys or changing permissions.\n*   **Fund Management:** Withdrawing assets to an external wallet or settling PnL.\n*   **Smart Contract Wallets:** Executing actions via a delegate signer (e.g., Gnosis Safe).\n\n---\n\n## Domain Configuration\n\nAll Orderly EIP-712 signatures share a common domain separator. This ensures that a signature generated for Orderly cannot be replayed on a different dApp or smart contract.\n\n```typescript\nconst OFF_CHAIN_DOMAIN = {\n  name: 'Orderly',              // DApp identifier to prevent cross-application replay attacks\n  version: '1',                 // Schema version for future upgrades\n  chainId: 421614,              // Arbitrum Sepolia (Testnet). Use 42161 for Arbitrum Mainnet.\n  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC' // The Settlement Layer contract address\n};\n```\n\n> **Why is this needed?**\n> The domain binds the signature to a specific blockchain network and smart contract. Without this, a signature intended for the Testnet could potentially be replayed on the Mainnet.\n\n---\n\n## Message Types\n\nThe following sections define the specific data structures for various actions.\n\n### Account Registration\n\n**Registration**\nRegister a new trading account with Orderly. This is the mandatory first step for any user interacting with the network.\n\n```typescript\nRegistration: [\n  { name: 'brokerId', type: 'string' },           // Identifies the frontend (e.g., 'woofi_pro')\n  { name: 'chainId', type: 'uint256' },           // Ensures the account is bound to a specific chain\n  { name: 'timestamp', type: 'uint64' },          // Server-side validation to prevent stale requests\n  { name: 'registrationNonce', type: 'uint256' }  // Unique ID to prevent double-registration\n]\n```\n\n### Key Management\n\n**AddOrderlyKey**\nRegister a new public key for API authentication. This allows you to perform trading activities via REST/WebSocket APIs without signing every transaction with your wallet.\n\n```typescript\nAddOrderlyKey: [\n  { name: 'brokerId', type: 'string' },\n  { name: 'chainId', type: 'uint256' },\n  { name: 'orderlyKey', type: 'string' },         // The public key associated with your API credentials\n  { name: 'scope', type: 'string' },              // Permissions granted (e.g., \"read\", \"trading\", \"withdraw\")\n  { name: 'timestamp', type: 'uint64' },\n  { name: 'expiration', type: 'uint64' }          // Unix timestamp when this key expires\n]\n```\n\n### Fund Operations\n\n**Withdraw**\nWithdraw funds from your Orderly account to an external wallet address.\n\n```typescript\nWithdraw: [\n  { name: 'brokerId', type: 'string' },\n  { name: 'chainId', type: 'uint256' },\n  { name: 'receiver', type: 'address' },          // Destination address for the funds\n  { name: 'token', type: 'string' },              // Symbol of the token (e.g., \"USDC\", \"ETH\")\n  { name: 'amount', type: 'uint256' },            // Amount in smallest unit (wei/satoshi) - mind the decimals!\n  { name: 'withdrawNonce', type: 'uint64' },      // Ensures this specific withdrawal request is unique\n  { name: 'timestamp', type: 'uint64' }\n]\n```\n\n**SettlePnl**\nSettle unrealized Profit and Loss (PnL). This updates your wallet balance to reflect your trading performance.\n\n```typescript\nSettlePnl: [\n  { name: 'brokerId', type: 'string' },\n  { name: 'chainId', type: 'uint256' },\n  { name: 'settleNonce', type: 'uint64' },        // Prevents duplicate settlement requests\n  { name: 'timestamp', type: 'uint64' }\n]\n```\n\n### Internal Transfers\n\n**InternalTransfer**\nTransfer funds directly between two Orderly accounts without touching the underlying blockchain layer (gas-free and instant).\n\n```typescript\nInternalTransfer: [\n  { name: 'receiver', type: 'bytes32' },          // The receiver's Account ID (hashed)\n  { name: 'token', type: 'string' },\n  { name: 'amount', type: 'uint256' },\n  { name: 'transferNonce', type: 'uint64' }       // Unique identifier for this transfer\n]\n```\n\n---\n\n## Delegate Signer Types\n\nThese types are used when the account owner is a Smart Contract Wallet (like a Gnosis Safe) rather than a standard EOA (Externally Owned Account). They include the `delegateContract` field to authorize the contract to act on behalf of the user.\n\n### Delegate Management\n\n**DelegateSigner**\nRegister a smart contract wallet as a delegate signer.\n\n```typescript\nDelegateSigner: [\n  { name: 'delegateContract', type: 'address' },  // Address of the smart contract wallet\n  { name: 'brokerId', type: 'string' },\n  { name: 'chainId', type: 'uint256' },\n  { name: 'timestamp', type: 'uint64' },\n  { name: 'registrationNonce', type: 'uint256' },\n  { name: 'txHash', type: 'bytes32' }             // Transaction hash linking to the on-chain approval\n]\n```\n\n**DelegateAddOrderlyKey**\nAdd an Orderly Key via a delegate signer.\n\n```typescript\nDelegateAddOrderlyKey: [\n  { name: 'delegateContract', type: 'address' },\n  { name: 'brokerId', type: 'string' },\n  { name: 'chainId', type: 'uint256' },\n  { name: 'orderlyKey', type: 'string' },\n  { name: 'scope', type: 'string' },\n  { name: 'timestamp', type: 'uint64' },\n  { name: 'expiration', type: 'uint64' }\n]\n```\n\n### Delegate Operations\n\n**DelegateWithdraw**\nExecute a withdrawal via a delegate signer.\n\n```typescript\nDelegateWithdraw: [\n  { name: 'delegateContract', type: 'address' },\n  { name: 'brokerId', type: 'string' },\n  { name: 'chainId', type: 'uint256' },\n  { name: 'receiver', type: 'address' },\n  { name: 'token', type: 'string' },\n  { name: 'amount', type: 'uint256' },\n  { name: 'withdrawNonce', type: 'uint64' },\n  { name: 'timestamp', type: 'uint64' }\n]\n```\n\n**DelegateSettlePnl**\nSettle PnL via a delegate signer.\n\n```typescript\nDelegateSettlePnl: [\n  { name: 'delegateContract', type: 'address' },\n  { name: 'brokerId', type: 'string' },\n  { name: 'chainId', type: 'uint256' },\n  { name: 'settleNonce', type: 'uint64' },\n  { name: 'timestamp', type: 'uint64' }\n]\n```\n\n**DelegateInternalTransfer**\nExecute an internal transfer via a delegate signer.\n\n```typescript\nDelegateInternalTransfer: [\n  { name: 'delegateContract', type: 'address' },\n  { name: 'receiver', type: 'string' },           // Note: Receiver type differs from standard InternalTransfer\n  { name: 'token', type: 'string' },\n  { name: 'amount', type: 'uint256' },\n  { name: 'transferNonce', type: 'uint64' },\n  { name: 'chainId', type: 'uint256' },\n  { name: 'chainType', type: 'string' }           // Specifies the chain type (e.g., \"EVM\")\n]\n```\n\n---\n\n## Usage Example\n\nThe following example demonstrates how to construct and sign a `Withdraw` message using a standard Ethereum library (like `ethers` or `viem`).\n\n```typescript\n// 1. Define the message payload matching the Withdraw schema\nconst withdrawMessage = {\n  brokerId: 'woofi_pro',\n  chainId: 421614, // Ensure this matches the domain chainId\n  receiver: '0x1234567890123456789012345678901234567890',\n  token: 'USDC',\n  amount: 1000000, // IMPORTANT: 1 USDC = 1,000,000 base units (6 decimals)\n  withdrawNonce: 123, // Retrieve this from the Orderly API to ensure uniqueness\n  timestamp: Date.now() // Current time in milliseconds\n};\n\n// 2. Sign the data using the user's wallet\n// The 'Withdraw' key here must match the property name in MESSAGE_TYPES\nconst signature = await wallet.signTypedData(\n  OFF_CHAIN_DOMAIN,\n  { Withdraw: MESSAGE_TYPES.Withdraw },\n  withdrawMessage\n);\n\nconsole.log(\"Generated Signature:\", signature);\n```\n\n---\n\n## Common Pitfalls\n\n### 1. Incorrect Decimal Handling\n**Pitfall:** Sending `amount: 1` thinking it represents 1 USDC.\n**Reality:** Most tokens use specific decimals (USDC uses 6, ETH uses 18).\n**Fix:** Always multiply the human-readable amount by $10^{decimals}$.\n*Example: 1 USDC $\\rightarrow$ `1 * 10^6 = 1000000`.*\n\n### 2. Chain ID Mismatch\n**Pitfall:** Using `chainId: 42161` (Mainnet) while connected to Arbitrum Sepolia (Testnet).\n**Fix:** Dynamically set the `chainId` based on the network the user's wallet is currently connected to.\n\n### 3. Stale Timestamps\n**Pitfall:** Using a hardcoded timestamp or a timestamp generated too long ago.\n**Fix:** Always generate the timestamp immediately before signing. Orderly servers typically reject signatures older than 30-60 seconds.\n\n### 4. Nonce Reuse\n**Pitfall:** Reusing a `withdrawNonce` or `registrationNonce`.\n**Fix:** Always fetch the latest nonce from the Orderly API (`GET /v1/client/nounce`) before constructing a new message. Reusing a nonce will cause the transaction to fail.\n\n---\n\n## See Also\n\n*   [Account Registration Guide](#) - Step-by-step walkthrough of onboarding users.\n*   [Creating Orderly Keys](#) - How to generate and secure API keys.\n*   [Withdrawal Workflow](#) - Detailed process for moving funds off-chain.\n*   [Smart Contract Wallet Integration](#) - Implementing Delegate Signers for Safe/Gnosis wallets.",
      "keywords": ["eip-712", "message types", "signing", "reference", "typed data"],
      "source": "Generated from example repositories with AI enhancement",
      "generatedAt": "2026-02-04T19:13:14.796Z"
    },
    {
      "id": "enriched-130",
      "title": "Common Implementation Patterns",
      "category": "Overview",
      "content": "# Common Implementation Patterns for Orderly Network\n\nThis guide outlines practical patterns for integrating with the Orderly Network, covering the essential flows from user onboarding to asset management.\n\n---\n\n## 1. Account Registration Flow\n\nThis flow establishes the link between a user's Web3 wallet and their unique Orderly account identity. It is the mandatory first step for any new user.\n\n### Why this is needed\nOrderly Network does not automatically create an account upon wallet connection. You must explicitly register to generate a unique `account_id`. This ensures that the mapping between the off-chain trading identity and the on-chain wallet address is cryptographically secure and authorized by the user.\n\n### Implementation Steps\n\n1.  **Get registration nonce from `/v1/registration_nonce`**\n    *   *Why:* A nonce (number used once) ensures that the registration signature is unique and cannot be replayed by a malicious actor.\n2.  **Create EIP-712 Registration message**\n    *   *Why:* EIP-712 provides a standardized, human-readable way to sign data. It allows the wallet to show the user exactly what they are signing (Registering an account with Orderly), preventing phishing.\n3.  **Sign with wallet (`signTypedData`)**\n    *   *Why:* Cryptographically proves ownership of the wallet address authorizing the registration.\n4.  **POST to `/v1/register_account`**\n    *   *Why:* Submits the signature and the message to Orderly's servers to verify and create the account record.\n5.  **Receive `account_id` in response**\n    *   *Why:* You need this ID to identify the user in all subsequent API calls (trading, querying balances, etc.).\n\n### Code Example\n\n```typescript\n// Reference: registerExample.ts, helpers/index.ts:registerAccount\n\nimport { ethers } from 'ethers';\n\nasync function registerAccount(walletAddress: string, signer: ethers.Signer) {\n  // 1. Fetch a nonce to ensure this request is unique\n  const { data: nonceData } = await axios.get('/v1/registration_nonce', {\n    params: { address: walletAddress }\n  });\n\n  // 2. Construct the EIP-712 typed data\n  // This defines the structure Orderly expects to see signed\n  const domain = {\n    name: 'Orderly',\n    version: '1',\n    chainId: await signer.getChainId(),\n  };\n\n  const types = {\n    Registration: [\n      { name: 'brokerId', type: 'string' },\n      { name: 'timestamp', type: 'uint64' },\n      { name: 'nonce', type: 'string' },\n    ],\n  };\n\n  const value = {\n    brokerId: 'YOUR_BROKER_ID', // Your specific broker ID\n    timestamp: Date.now(),\n    nonce: nonceData.data.nonce,\n  };\n\n  // 3. Request signature from the user's wallet\n  // The user will see a popup asking to confirm registration\n  const signature = await signer.signTypedData(domain, types, value);\n\n  // 4. Send the signed payload to Orderly\n  const response = await axios.post('/v1/register_account', {\n    address: walletAddress,\n    message: value,\n    signature: signature,\n    brokerId: 'YOUR_BROKER_ID'\n  });\n\n  // 5. Store the returned Account ID\n  console.log('Registration successful. Account ID:', response.data.data.account_id);\n  return response.data.data.account_id;\n}\n```\n\n### Common Pitfalls\n*   **Expired Nonces:** If the user takes too long to sign the wallet popup, the nonce may expire. Always handle signature errors by fetching a fresh nonce and retrying.\n*   **Chain ID Mismatch:** Ensure the `chainId` in the EIP-712 domain matches the network the wallet is currently connected to.\n\n---\n\n## 2. Orderly Key Creation Flow\n\nThis flow generates a dedicated trading keypair. This separates the high-security wallet (used for deposits/withdrawals) from the high-frequency key used for placing orders.\n\n### Why this is needed\nSigning every order or API request with a wallet (like MetaMask) results in a poor user experience (constant popups) and is too slow for high-frequency trading. An Ed25519 keypair allows your backend or frontend to sign requests programmatically and instantly.\n\n### Implementation Steps\n\n1.  **Generate Ed25519 keypair using `@noble/ed25519`**\n    *   *Why:* Ed25519 offers high security and performance, ideal for API request signing.\n2.  **Get public key from private key**\n    *   *Why:* The public key is registered on Orderly to verify signatures generated by the private key.\n3.  **Create EIP-712 AddOrderlyKey message**\n    *   *Why:* You must link this new key to your main wallet address. This requires a wallet signature to authorize the new key.\n4.  **Sign with wallet**\n    *   *Why:* Ensures that only the owner of the wallet can authorize a new trading key.\n5.  **POST to `/v1/orderly_key`**\n    *   *Why:* Registers the public key and the expiration scope with Orderly.\n6.  **Store private key securely**\n    *   *Why:* You need the private key to sign future requests. If lost, you cannot trade via API; if leaked, others can trade on your behalf.\n\n### Code Example\n\n```typescript\n// Reference: orderlyKeyExample.ts, helpers/index.ts:addOrderlyKey\n\nimport { ed25519 } from '@noble/ed25519';\n\nasync function addOrderlyKey(walletAddress: string, signer: ethers.Signer) {\n  // 1. Generate a new Ed25519 keypair for API interactions\n  const privateKey = ed25519.utils.randomPrivateKey();\n  const publicKeyBytes = await ed25519.getPublicKey(privateKey);\n  \n  // Convert public key to hex string for registration\n  const publicKeyHex = Buffer.from(publicKeyBytes).toString('hex');\n\n  // 2. Define the scope and expiration of the key\n  // Scopes limit what this key can do (e.g., \"read\", \"trade\")\n  const scopes = [\"read\", \"trade\", \"withdraw\"]; \n  const expiration = Math.floor(Date.now() / 1000) + (60 * 60 * 24 * 365); // 1 year\n\n  // 3. Construct EIP-712 message for adding the key\n  const domain = { name: 'Orderly', version: '1', chainId: await signer.getChainId() };\n  const types = {\n    AddOrderlyKey: [\n      { name: 'brokerId', type: 'string' },\n      { name: 'chainId', type: 'uint256' },\n      { name: 'orderlyKey', type: 'string' },\n      { name: 'nonce', type: 'uint256' },\n      { name: 'timestamp', type: 'uint256' },\n      { name: 'expiration', type: 'uint256' },\n      { name: 'scopes', type: 'string[]' },\n    ],\n  };\n\n  const value = {\n    brokerId: 'YOUR_BROKER_ID',\n    chainId: await signer.getChainId(),\n    orderlyKey: publicKeyHex,\n    nonce: Date.now(), // Simple nonce based on time\n    timestamp: Date.now(),\n    expiration: expiration,\n    scopes: scopes,\n  };\n\n  // 4. Authorize the new key by signing with the Wallet\n  const signature = await signer.signTypedData(domain, types, value);\n\n  // 5. Send the public key and authorization signature to Orderly\n  await axios.post('/v1/orderly_key', {\n    address: walletAddress,\n    message: value,\n    signature: signature,\n  });\n\n  // 6. IMPORTANT: Store the private key securely\n  // In a frontend app, use localStorage with caution or secure storage.\n  // In a backend, use environment variables or a secret manager.\n  console.log('Orderly Key registered. Private Key (keep secret):', Buffer.from(privateKey).toString('hex'));\n  \n  return { privateKey, publicKeyHex };\n}\n```\n\n### Common Pitfalls\n*   **Insecure Storage:** Never commit the Orderly Key private key to GitHub. In client-side apps, be aware that local storage is vulnerable to XSS attacks.\n*   **Scope Creep:** Only request the scopes you need. If the key is only for reading data, do not request \"trade\" or \"withdraw\" permissions.\n\n---\n\n## 3. API Request Signing\n\nOnce you have an Orderly Key, you must sign every private API request (placing orders, changing leverage) to authenticate it.\n\n### Why this is needed\nOrderly needs to verify that the request originated from the legitimate holder of the Orderly Key associated with the account. This prevents man-in-the-middle attacks and unauthorized actions.\n\n### Implementation Steps\n\n1.  **Create message string: `timestamp + method + path + body`**\n    *   *Why:* This \"canonical\" string ensures that the signature is specific to the exact time, HTTP method, URL, and data payload. Changing any character invalidates the signature.\n2.  **Sign with Ed25519 private key**\n    *   *Why:* Generates the cryptographic proof.\n3.  **Encode signature as base64url**\n    *   *Why:* Signatures are binary data. Base64url makes them safe to transmit in HTTP headers.\n4.  **Add headers: `orderly-key`, `orderly-signature`, `orderly-timestamp`, `orderly-account-id`**\n    *   *Why:* These headers provide the server with the context (Account ID), the verifier (Public Key), the proof (Signature), and the anti-replay factor (Timestamp).\n5.  **Send request**\n    *   *Why:* Transmit the authenticated payload.\n\n### Code Example\n\n```typescript\n// Reference: signer.ts, helpers/index.ts:signAndSendRequest\n\nimport { ed25519 } from '@noble/ed25519';\n\nasync function signAndSendRequest(\n  method: string, \n  path: string, \n  body: any, \n  privateKey: Uint8Array, \n  accountId: string, \n  publicKey: string\n) {\n  const timestamp = Date.now().toString();\n  \n  // 1. Construct the message payload\n  // Note: Body must be stringified. Ensure keys are sorted if strict JSON ordering is required.\n  const messageString = `${timestamp}${method}${path}${JSON.stringify(body)}`;\n\n  // 2. Sign the message using the Ed25519 private key\n  const messageBytes = new TextEncoder().encode(messageString);\n  const signatureBytes = await ed25519.sign(messageBytes, privateKey);\n\n  // 3. Convert signature to Base64URL format\n  // Standard Base64 contains '+' and '/' which are unsafe in URLs. \n  // We replace them with '-' and '_'.\n  const signatureBase64 = Buffer.from(signatureBytes).toString('base64')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=+$/, '');\n\n  // 4. Prepare headers with authentication data\n  const headers = {\n    'orderly-key': publicKey,\n    'orderly-signature': signatureBase64,\n    'orderly-timestamp': timestamp,\n    'orderly-account-id': accountId,\n    'Content-Type': 'application/json'\n  };\n\n  // 5. Send the authenticated request\n  try {\n    const response = await axios.post(`https://api.orderly.network${path}`, body, { headers });\n    return response.data;\n  } catch (error) {\n    console.error('API Request failed', error);\n    throw error;\n  }\n}\n```\n\n### Common Pitfalls\n*   **Timestamp Drift:** If your server's clock is out of sync with Orderly's servers (more than ~30 seconds), the request will be rejected. Keep your system clock synchronized via NTP.\n*   **Body Mismatch:** The signature must match the *exact* stringified body sent in the request. If you modify the body after signing (e.g., auto-formatting), the signature will fail.\n\n---\n\n## 4. Deposit Flow\n\nThis flow moves assets (like USDC) from the user's wallet into the Orderly Vault contract, making them available for trading margin.\n\n### Why this is needed\nOrderly is a clearinghouse. To trade on the platform, assets must be held by the Vault smart contract, not just in the user's personal wallet.\n\n### Implementation Steps\n\n1.  **Connect to Vault contract**\n    *   *Why:* You need an interface to interact with the smart contract logic.\n2.  **Calculate deposit fee**\n    *   *Why:* Depositing usually requires a small amount of gas (native token) and potentially a protocol fee.\n3.  **Call `deposit()` with USDC amount and broker hash**\n    *   *Why:* This function triggers the ERC20 `transferFrom` and credits the user's account on Orderly. The broker hash ensures Orderly knows which broker (your app) to credit the referral/trading fees to.\n4.  **Pay fee in native token (ETH/MATIC/etc)**\n    *   *Why:* Executing the transaction on the blockchain requires gas.\n\n### Code Example\n\n```typescript\n// Reference: helpers/index.ts:deposit\n\nimport { ethers } from 'ethers';\n\nasync function deposit(\n  walletAddress: string, \n  amount: string, \n  signer: ethers.Signer,\n  vaultAddress: string,\n  tokenAddress: string\n) {\n  // 1. Setup interfaces for the Token and Vault contracts\n  const tokenContract = new ethers.Contract(tokenAddress, [\n    \"function approve(address spender, uint256 amount) returns (bool)\",\n    \"function allowance(address owner, address spender) view returns (uint256)\"\n  ], signer);\n\n  const vaultContract = new ethers.Contract(vaultAddress, [\n    \"function deposit(address token, uint256 amount, bytes calldata brokerId) returns (bool)\"\n  ], signer);\n\n  const amountWei = ethers.parseUnits(amount, 6); // Assuming USDC (6 decimals)\n  const brokerIdBytes = ethers.toUtf8Bytes('YOUR_BROKER_ID');\n\n  // 2. Check allowance first (Optional but recommended UX)\n  const allowance = await tokenContract.allowance(walletAddress, vaultAddress);\n  if (allowance < amountWei) {\n    console.log('Approving Vault to spend USDC...');\n    // User must sign an approval transaction first\n    const approveTx = await tokenContract.approve(vaultAddress, amountWei);\n    await approveTx.wait();\n  }\n\n  // 3. Execute the deposit\n  // Note: This requires the user to have enough native token (ETH/MATIC) for gas\n  console.log('Depositing to Orderly Vault...');\n  const depositTx = await vaultContract.deposit(\n    tokenAddress, \n    amountWei, \n    brokerIdBytes\n  );\n\n  // 4. Wait for on-chain confirmation\n  await depositTx.wait();\n  console.log('Deposit successful!');\n}\n```\n\n### Common Pitfalls\n*   **Missing Allowance:** Users often fail to deposit because they haven't approved the Vault contract to spend their tokens. Always check allowance or attempt a deposit and catch the revert reason to prompt approval.\n*   **Insufficient Gas:** Users often have enough USDC to deposit but not enough ETH/MATIC to pay for the gas transaction. Check native balance before depositing.\n\n---\n\n## 5. Withdrawal Flow\n\nThis flow moves assets from the Orderly Vault back to the user's wallet.\n\n### Why this is needed\nTo realize profits or move assets to another platform, the user must initiate a withdrawal. This requires both an off-chain API request (to notify Orderly) and an on-chain transaction (to release funds).\n\n### Implementation Steps\n\n1.  **Get withdrawal nonce via authenticated request**\n    *   *Why:* Prevents replay attacks. You cannot request the same withdrawal twice.\n2.  **Create EIP-712 Withdraw message**\n    *   *Why:* Standardized format for the user to sign the withdrawal authorization.\n3.  **Sign with wallet**\n    *   *Why:* High-security action. Moving funds off-chain requires the main wallet signature.\n4.  **POST to `/v1/withdraw_request` with signature**\n    *   *Why:* Notifies Orderly's backend to process the withdrawal and prepare the on-chain transaction.\n5.  **Wait for on-chain confirmation**\n    *   *Why:* The funds are not in your wallet until the blockchain transaction is finalized.\n\n### Code Example\n\n```typescript\n// Reference: helpers/index.ts:withdraw\n\nasync function withdraw(\n  walletAddress: string,\n  amount: string,\n  tokenAddress: string,\n  signer: ethers.Signer,\n  accountId: string,\n  orderlyKeySecret: Uint8Array\n) {\n  // 1. Fetch withdrawal nonce (requires Orderly Key authentication)\n  // Reusing the signAndSendRequest logic defined in Section 3\n  const nonceResponse = await signAndSendRequest(\n    'GET', \n    '/v1/withdraw_nonce', \n    {}, \n    orderlyKeySecret, \n    accountId,\n    'PUBLIC_KEY_HEX'\n  );\n  \n  const nonce = nonceResponse.data.nonce;\n  const timestamp = Date.now();\n\n  // 2. Construct EIP-712 Withdraw message\n  const domain = { name: 'Orderly', version: '1', chainId: await signer.getChainId() };\n  const types = {\n    Withdraw: [\n      { name: 'brokerId', type: 'string' },\n      { name: 'chainId', type: 'uint256' },\n      { name: 'receiver', type: 'address' },\n      { name: 'token', type: 'address' },\n      { name: 'amount', type: 'uint256' },\n      { name: 'nonce', type: 'uint256' },\n      { name: 'timestamp', type: 'uint256' },\n    ],\n  };\n\n  const value = {\n    brokerId: 'YOUR_BROKER_ID',\n    chainId: await signer.getChainId(),\n    receiver: walletAddress,\n    token: tokenAddress,\n    amount: ethers.parseUnits(amount, 6), // USDC decimals\n    nonce: nonce,\n    timestamp: timestamp,\n  };\n\n  // 3. Sign with wallet\n  const signature = await signer.signTypedData(domain, types, value);\n\n  // 4. Request withdrawal from Orderly\n  const withdrawPayload = {\n    ...value,\n    signature: signature,\n  };\n\n  const withdrawResponse = await signAndSendRequest(\n    'POST',\n    '/v1/withdraw_request',\n    withdrawPayload,\n    orderlyKeySecret,\n    accountId,\n    'PUBLIC_KEY_HEX'\n  );\n\n  console.log('Withdrawal submitted. Transaction Hash:', withdrawResponse.data.tx_hash);\n  \n  // 5. Monitor the blockchain for the transaction hash to confirm completion\n  // ...\n}\n```\n\n### Common Pitfalls\n*   **Withdrawal to Contract Address:** Withdrawing to a smart contract address (instead of an EOA) can fail if the contract does not implement logic to receive USDC. Always validate the destination address.\n*   **Pending Withdrawals:** If a withdrawal is stuck, it is often due to network congestion on the L2 chain. Provide the user with the transaction hash so they can track it on a block explorer.\n\n---\n\n## 6. Choosing the Right Pattern\n\nSelect the implementation pattern that matches your application's architecture and use case.\n\n| Pattern | When to use this | Description |\n| :--- | :--- | :--- |\n| **New User Onboarding** | **Frontend DApps / Wallets** | **Flow:** Account Registration → Orderly Key Creation → Deposit<br><br>Use this for standard trading applications where the user connects via a Web3 wallet (MetaMask, WalletConnect) and interacts with your frontend. |\n| **Trading Bot** | **Backend / Algorithmic Trading** | **Flow:** Orderly Key Creation (backend) → Direct API Authentication<br><br>Use this if you are building a server-side bot. You generate the Orderly Key programmatically, register it once, and then use it exclusively for API calls without wallet popups. |\n| **Multisig / Safe** | **Institutional / DAO Treasuries** | **Flow:** Delegate Signer Setup → Delegate Operations<br><br>Use this for accounts requiring high security. You can configure a \"Delegate Signer\" (Orderly Key) that is allowed to trade, while the main Multisig is required for Deposits/Withdrawals. |\n| **Portfolio Management** | **Aggregators / Dashboards** | **Flow:** Account Registration → Deposit → Trading → Withdrawal<br><br>Use this for full-cycle applications that manage the entire lifecycle of user assets, including moving funds in and out of the Orderly ecosystem. |",
      "keywords": ["patterns", "implementation", "workflow", "architecture", "integration"],
      "source": "Generated from example repositories with AI enhancement",
      "generatedAt": "2026-02-04T19:14:55.635Z"
    },
    {
      "id": "enriched-131",
      "title": "Direct API Authentication (Python)",
      "category": "API",
      "content": "# Orderly Network Python API Authentication Guide\n\nThis guide provides comprehensive examples and explanations for authenticating with the Orderly Network API using Python. It covers the dual-key architecture used by Orderly, distinguishing between on-chain identity management and off-chain trading operations.\n\n## When to use this\n\nUse this guide when:\n*   Building a high-frequency trading bot that requires efficient API authentication.\n*   Integrating Orderly Network into a backend system for automated account management.\n*   Implementing withdrawal or deposit flows that involve on-chain transactions.\n*   Creating custom scripts to settle PnL or manage account holdings.\n\n## Prerequisites\n\nBefore you begin, ensure you have the necessary Python libraries installed:\n\n```bash\npip install orderly-evm-connector-python\n```\n\nYou will also need:\n*   An Ethereum wallet (for on-chain identity).\n*   Environment variables set for your `PRIVATE_KEY` and `ORDERLY_SECRET`.\n\n---\n\n## Core Concepts: The Dual-Key Architecture\n\nOrderly Network uses a **dual-key system** to balance security and performance. Understanding this distinction is crucial for implementation:\n\n1.  **Ethereum Wallet (ECDSA/EIP-712):** Used for **administrative actions**. This includes registering your account, withdrawing funds, and creating API keys. These actions change the state of your account or move assets.\n2.  **Orderly Key (Ed25519):** Used for **trading actions**. This is a lightweight key pair used to sign everyday API requests like placing orders, checking balances, and fetching market data.\n\n---\n\n## Part 1: Configuration and Setup\n\nFirst, we define the network configuration. This centralizes settings like the Broker ID and Chain ID, ensuring consistency across all API calls.\n\n### `config.py`\n\n```python\nclass Config(object):\n    def __init__(\n        self,\n        base_url=\"https://testnet-api-evm.orderly.org\",\n        broker_id=\"woofi_pro\",\n        chain_id=421614,\n    ) -> None:\n        self.base_url = base_url\n        self.broker_id = broker_id\n        self.chain_id = chain_id\n```\n\n**Why this is needed:**\n*   **`base_url`**: Determines if you are connecting to Testnet or Mainnet.\n*   **`broker_id`**: Identifies which brokerage route your trades go through.\n*   **`chain_id`**: Ensures signatures are valid for the specific blockchain network (e.g., Arbitrum Sepolia).\n\n---\n\n## Part 2: Account Registration (On-Chain Identity)\n\nBefore trading, you must register your Ethereum wallet address with Orderly Network. This process uses **EIP-712** typed data signing, which allows users to sign structured data in a verifiable way without executing a blockchain transaction (gas-free).\n\n### `register.py`\n\nThis class handles the registration logic and the creation of new access keys.\n\n```python\nfrom datetime import datetime\nimport json\nimport math\nimport requests\n\nfrom cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey\nfrom eth_account import Account, messages\nfrom config import Config\n\nfrom eip712 import MESSAGE_TYPES, get_off_chain_domain\nfrom util import encode_key\n\n\nclass Register(object):\n    def __init__(\n        self,\n        config: Config,\n        account: Account,\n    ) -> None:\n        self._config = config\n        self._account = account\n\n    def register_account(self) -> str:\n        # 1. Fetch a nonce from the server to prevent replay attacks\n        res = requests.get(\"%s/v1/registration_nonce\" % self._config.base_url)\n        response = json.loads(res.text)\n        registration_nonce = response[\"data\"][\"registration_nonce\"]\n\n        # 2. Generate a timestamp in milliseconds\n        d = datetime.utcnow()\n        epoch = datetime(1970, 1, 1)\n        timestamp = math.trunc((d - epoch).total_seconds() * 1_000)\n\n        # 3. Construct the message payload according to EIP-712 standards\n        register_message = {\n            \"brokerId\": self._config.broker_id,\n            \"chainId\": self._config.chain_id,\n            \"timestamp\": timestamp,\n            \"registrationNonce\": registration_nonce,\n        }\n\n        # 4. Encode the data for signing\n        encoded_data = messages.encode_typed_data(\n            domain_data=get_off_chain_domain(self._config.chain_id),\n            message_types={\"Registration\": MESSAGE_TYPES[\"Registration\"]},\n            message_data=register_message,\n        )\n        \n        # 5. Sign with your Ethereum Private Key\n        signed_message = self._account.sign_message(encoded_data)\n\n        # 6. Send the signature and payload to the API\n        res = requests.post(\n            \"%s/v1/register_account\" % self._config.base_url,\n            headers={\"Content-Type\": \"application/json\"},\n            json={\n                \"message\": register_message,\n                \"signature\": signed_message.signature.hex(),\n                \"userAddress\": self._account.address,\n            },\n        )\n        response = json.loads(res.text)\n        print(\"register_account:\", response)\n\n        return response[\"data\"][\"account_id\"]\n\n    def add_access_key(self) -> Ed25519PrivateKey:\n        # 1. Generate a new Ed25519 key pair for API usage\n        orderly_key = Ed25519PrivateKey.generate()\n\n        d = datetime.utcnow()\n        epoch = datetime(1970, 1, 1)\n        timestamp = math.trunc((d - epoch).total_seconds() * 1_000)\n\n        # 2. Define the scope and expiration of this key\n        add_key_message = {\n            \"brokerId\": self._config.broker_id,\n            \"chainId\": self._config.chain_id,\n            \"orderlyKey\": encode_key(orderly_key.public_key().public_bytes_raw()),\n            \"scope\": \"read,trading\",  # Permissions for this key\n            \"timestamp\": timestamp,\n            \"expiration\": timestamp + 1_000 * 60 * 60 * 24 * 365,  # 1 year validity\n        }\n\n        # 3. Sign the \"AddOrderlyKey\" message with your Ethereum Wallet\n        # This links the new Ed25519 key to your wallet securely\n        encoded_data = messages.encode_typed_data(\n            domain_data=get_off_chain_domain(self._config.chain_id),\n            message_types={\"AddOrderlyKey\": MESSAGE_TYPES[\"AddOrderlyKey\"]},\n            message_data=add_key_message,\n        )\n        signed_message = self._account.sign_message(encoded_data)\n\n        res = requests.post(\n            \"%s/v1/orderly_key\" % self._config.base_url,\n            headers={\"Content-Type\": \"application/json\"},\n            json={\n                \"message\": add_key_message,\n                \"signature\": signed_message.signature.hex(),\n                \"userAddress\": self._account.address,\n            },\n        )\n        response = json.loads(res.text)\n        print(\"add_access_key:\", response)\n\n        return orderly_key\n```\n\n**Why this is needed:**\n*   **Registration:** Maps your blockchain address to an internal Orderly Account ID.\n*   **Access Keys:** Allows you to perform high-frequency trading without exposing your main Ethereum Private Key or paying gas for every signature.\n\n---\n\n## Part 3: Request Signing (Off-Chain Authentication)\n\nOnce you have an Orderly Key (Ed25519), you must sign every HTTP request. This proves the request comes from the holder of the private key.\n\n### `signer.py`\n\nThis utility intercepts HTTP requests, calculates the signature, and attaches the necessary headers.\n\n```python\nfrom base64 import urlsafe_b64encode\nfrom datetime import datetime\nimport json\nimport math\nfrom cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey\nfrom requests import PreparedRequest, Request\nimport urllib\n\nfrom util import encode_key\n\n\nclass Signer(object):\n    def __init__(\n        self,\n        account_id: str = None,\n        key_pair: Ed25519PrivateKey = None,\n    ) -> None:\n        self._account_id = account_id\n        self._key_pair = key_pair\n\n    def sign_request(self, req: Request) -> PreparedRequest:\n        # 1. Capture the current time in milliseconds\n        d = datetime.utcnow()\n        epoch = datetime(1970, 1, 1)\n        timestamp = math.trunc((d - epoch).total_seconds() * 1_000)\n\n        # 2. Serialize the JSON body if it exists\n        json_str = \"\"\n        if req.json is not None:\n            json_str = json.dumps(req.json)\n\n        # 3. Construct the \"message\" string to sign\n        # Format: Timestamp + HTTP Method + URL Path + JSON Body + Query String\n        url = urllib.parse.urlparse(req.url)\n        message = str(timestamp) + req.method + url.path + json_str\n        if len(url.query) > 0:\n            message += \"?\" + url.query\n\n        # 4. Sign the message using the Ed25519 private key\n        orderly_signature = urlsafe_b64encode(\n            self._key_pair.sign(message.encode())\n        ).decode(\"utf-8\")\n\n        # 5. Attach required headers to the request\n        req.headers = {\n            \"orderly-timestamp\": str(timestamp),\n            \"orderly-account-id\": self._account_id,\n            \"orderly-key\": encode_key(self._key_pair.public_key().public_bytes_raw()),\n            \"orderly-signature\": orderly_signature,\n        }\n        \n        # 6. Set appropriate Content-Type based on the HTTP method\n        if req.method == \"GET\":\n            req.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"\n        elif req.method == \"POST\":\n            req.headers[\"Content-Type\"] = \"application/json\"\n\n        return req.prepare()\n```\n\n**Why this is needed:**\n*   **Security:** Ensures that the request body has not been tampered with in transit.\n*   **Integrity:** The timestamp prevents replay attacks (an attacker cannot intercept a valid request and resend it later).\n\n---\n\n## Part 4: Executing Trading Operations\n\nNow we combine the configuration, signer, and account logic to perform trading actions.\n\n### `order.py`\n\nHandles the creation and retrieval of orders.\n\n```python\nfrom enum import StrEnum\nfrom eth_account import Account\nimport json\nfrom requests import Request, Session\n\nfrom config import Config\nfrom signer import Signer\n\n\nclass Side(StrEnum):\n    BUY = \"BUY\"\n    SELL = \"SELL\"\n\n\nclass OrderType(StrEnum):\n    MARKET = \"MARKET\"\n    LIMIT = \"LIMIT\"\n\n\nclass Order(object):\n    def __init__(\n        self,\n        config: Config,\n        session: Session,\n        signer: Signer,\n        account: Account,\n    ) -> None:\n        self._config = config\n        self._session = session\n        self._signer = signer\n        self._account = account\n\n    def get_orders(self):\n        # Sign a GET request to fetch order history\n        req = self._signer.sign_request(\n            Request(\"GET\", \"%s/v1/orders\" % self._config.base_url)\n        )\n        res = self._session.send(req)\n        response = json.loads(res.text)\n        return response\n\n    def create_order(\n        self,\n        symbol: str,\n        order_type: OrderType,\n        order_quantity: float,\n        side: Side,\n    ):\n        # Sign a POST request to place a new order\n        req = self._signer.sign_request(\n            Request(\n                \"POST\",\n                \"%s/v1/order\" % self._config.base_url,\n                json={\n                    \"symbol\": symbol,\n                    \"order_type\": str(order_type),\n                    \"order_quantity\": order_quantity,\n                    \"side\": str(side),\n                },\n            )\n        )\n        res = self._session.send(req)\n        response = json.loads(res.text)\n        return response\n```\n\n### `account.py`\n\nHandles withdrawals and checking holdings. Note that withdrawals require an **EIP-712** signature (using your Ethereum wallet) because they move funds on-chain.\n\n```python\nfrom datetime import datetime\nimport math\nfrom eth_account import Account as EthAccount, messages\nimport json\nfrom requests import Request, Session\n\nfrom config import Config\nfrom eip712 import MESSAGE_TYPES, get_on_chain_domain\nfrom signer import Signer\n\n\nclass Account(object):\n    def __init__(\n        self,\n        config: Config,\n        session: Session,\n        signer: Signer,\n        account: EthAccount,\n    ) -> None:\n        self._config = config\n        self._session = session\n        self._signer = signer\n        self._account = account\n\n    def get_client_holding(self):\n        # Uses Ed25519 signer for quick data lookup\n        req = self._signer.sign_request(\n            Request(\"GET\", \"%s/v1/client/holding\" % self._config.base_url)\n        )\n        res = self._session.send(req)\n        response = json.loads(res.text)\n        print(\"get_client_holding:\", response)\n\n        return response[\"data\"][\"holding\"]\n\n    def get_withdraw_nonce(self):\n        req = self._signer.sign_request(\n            Request(\"GET\", \"%s/v1/withdraw_nonce\" % self._config.base_url)\n        )\n        res = self._session.send(req)\n        response = json.loads(res.text)\n        return response[\"data\"][\"withdraw_nonce\"]\n\n    def withdraw(self, token: str, amount: str):\n        # 1. Fetch nonce to prevent duplicate withdrawals\n        nonce = self.get_withdraw_nonce()\n\n        # 2. Generate timestamp\n        d = datetime.utcnow()\n        epoch = datetime(1970, 1, 1)\n        timestamp = math.trunc((d - epoch).total_seconds() * 1_000)\n\n        # 3. Construct the Withdraw message (EIP-712)\n        withdraw_message = {\n            \"brokerId\": self._config.broker_id,\n            \"chainId\": self._config.chain_id,\n            \"receiver\": self._account.address,\n            \"token\": token,\n            \"amount\": amount,\n            \"timestamp\": timestamp,\n            \"withdrawNonce\": nonce,\n        }\n\n        # 4. Sign with Ethereum Wallet (ECDSA)\n        encoded_data = messages.encode_typed_data(\n            domain_data=get_on_chain_domain(self._config.chain_id),\n            message_types={\"Withdraw\": MESSAGE_TYPES[\"Withdraw\"]},\n            message_data=withdraw_message,\n        )\n        signed_message = self._account.sign_message(encoded_data)\n\n        # 5. Send the request signed by the API Key (Ed25519), \n        # containing the payload signed by the Wallet (ECDSA)\n        req = self._signer.sign_request(\n            Request(\n                \"POST\",\n                \"%s/v1/withdraw_request\" % self._config.base_url,\n                json={\n                    \"message\": withdraw_message,\n                    \"signature\": signed_message.signature.hex(),\n                    \"userAddress\": self._account.address,\n                    \"verifyingContract\": get_on_chain_domain(self._config.chain_id)[\n                        \"verifyingContract\"\n                    ],\n                },\n            )\n        )\n        res = self._session.send(req)\n        response = json.loads(res.text)\n        return response\n```\n\n**Why this is needed:**\n*   **Dual Signing:** The `withdraw` function demonstrates a critical security pattern. The HTTP request itself is signed by your `Signer` (Ed25519) to authenticate the API session, but the *payload* contains a signature from your `Account` (Ethereum) to authorize the fund movement.\n\n---\n\n## Part 5: On-Chain Operations (Deposits)\n\nDepositing funds requires interacting directly with the Ethereum blockchain via Web3.py, not just the Orderly API.\n\n### `deposit_example.py`\n\n```python\nimport json\nimport os\n\nfrom eth_account import Account\nfrom web3 import Web3\nfrom web3.middleware import construct_sign_and_send_raw_middleware\n\n\nbroker_id = \"woofi_pro\"\ntoken_id = \"USDC\"\norderly_account_id = \"0x...\"\n\n# Contract addresses on Arbitrum Sepolia\nusdc_address = Web3.to_checksum_address(\"0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d\")\nvault_address = Web3.to_checksum_address(\"0x0EaC556c0C2321BA25b9DC01e4e3c95aD5CDCd2f\")\n\n# Load wallet from environment variable\naccount: Account = Account.from_key(os.environ.get(\"PRIVATE_KEY\"))\n\n# Connect to RPC\nw3 = Web3(Web3.HTTPProvider(\"https://arbitrum-sepolia.publicnode.com\"))\nw3.middleware_onion.add(construct_sign_and_send_raw_middleware(account))\n\n# Load ERC20 ABI\nwith open(\"./src/abi/NativeUSDC.json\") as f:\n    abi = json.load(f)\nusdc = w3.eth.contract(\n    address=usdc_address,\n    abi=abi,\n)\n\ndeposit_amount = 100000\n\n# 1. Approve the Vault contract to spend your USDC\n# This is a standard ERC-20 requirement\nusdc.functions.approve(vault_address, deposit_amount).transact(\n    {\"from\": account.address}\n)\n\n# Load Vault ABI\nwith open(\"./src/abi/Vault.json\") as f:\n    abi = json.load(f)\nvault = w3.eth.contract(\n    address=vault_address,\n    abi=abi,\n)\n\n# 2. Hash the broker ID and token ID for the calldata\nbroker_hash = w3.keccak(text=broker_id)\ntoken_hash = w3.keccak(text=token_id)\n\n# 3. Construct the deposit input tuple\ndeposit_input = (\n    bytes.fromhex(orderly_account_id[2:]),\n    bytes.fromhex(broker_hash.hex()[2:]),\n    bytes.fromhex(token_hash.hex()[2:]),\n    deposit_amount,\n)\n\n# 4. Calculate the deposit fee (required by the Vault contract)\ndeposit_fee = vault.functions.getDepositFee(\n    Web3.to_checksum_address(account.address),\n    deposit_input,\n).call()\n\n# 5. Execute the deposit transaction\n# We must send ETH equal to the deposit_fee to cover gas costs\nvault.functions.deposit(deposit_input).transact(\n    {\"from\": account.address, \"value\": deposit_fee}\n)\n```\n\n**Why this is needed:**\n*   **Asset Custody:** Deposits move tokens from your wallet to the Orderly Vault contract.\n*   **Approvals:** The Vault cannot pull your tokens without an ERC-20 `approve` transaction.\n*   **Fees:** The Vault contract requires a small amount of native tokens (ETH) to process the deposit.\n\n---\n\n## Common Pitfalls & How to Avoid Them\n\n### 1. Timestamp Synchronization\n**Pitfall:** If your server's clock is out of sync with the Orderly API servers, the timestamp in the signature will be rejected.\n**Solution:** Ensure your machine uses NTP (Network Time Protocol). Do not manually set timestamps.\n\n### 2. Nonce Reuse\n**Pitfall:** Using the same `registrationNonce` or `withdrawNonce` twice will result in a failure.\n**Solution:** Always fetch a fresh nonce immediately before constructing the message. Nonces are single-use.\n\n### 3. Signature Encoding Mismatches\n**Pitfall:** The API expects specific encodings (e.g., `hex` for EIP-712, `base64url` for Ed25519). Sending raw bytes or standard base64 will cause 401/403 errors.\n**Solution:** Double-check the encoding logic in `signer.py` and `util.py`.\n\n### 4. Scope Limitations\n**Pitfall:** Trying to withdraw funds using an Orderly Key that only has `read,trading` scope.\n**Solution:** Withdrawals require the main Ethereum Wallet signature (EIP-712), not the Orderly Key. Ensure you are using the correct signer for the action.\n\n### 5. Chain ID Mismatches\n**Pitfall:** Using Mainnet configurations (`chain_id: 42161`) on a Testnet URL or vice versa.\n**Solution:** Keep your `Config` class strictly separated for Testnet and Mainnet environments.\n\n---\n\n## Appendix: Helper Files\n\n### `util.py`\nUtility for encoding public keys in the Orderly format.\n\n```python\nfrom base58 import b58encode\n\n\ndef encode_key(key: bytes):\n    # Orderly expects keys in Base58 encoding with a prefix\n    return \"ed25519:%s\" % b58encode(key).decode(\"utf-8\")\n```\n\n### `eip712.py`\nDefines the schema for EIP-712 typed data. This ensures the client and server interpret the data structure identically.\n\n```python\nMESSAGE_TYPES = {\n    \"EIP712Domain\": [\n        {\"name\": \"name\", \"type\": \"string\"},\n        {\"name\": \"version\", \"type\": \"string\"},\n        {\"name\": \"chainId\", \"type\": \"uint256\"},\n        {\"name\": \"verifyingContract\", \"type\": \"address\"},\n    ],\n    \"Registration\": [\n        {\"name\": \"brokerId\", \"type\": \"string\"},\n        {\"name\": \"chainId\", \"type\": \"uint256\"},\n        {\"name\": \"timestamp\", \"type\": \"uint64\"},\n        {\"name\": \"registrationNonce\", \"type\": \"uint256\"},\n    ],\n    \"AddOrderlyKey\": [\n        {\"name\": \"brokerId\", \"type\": \"string\"},\n        {\"name\": \"chainId\", \"type\": \"uint256\"},\n        {\"name\": \"orderlyKey\", \"type\": \"string\"},\n        {\"name\": \"scope\", \"type\": \"string\"},\n        {\"name\": \"timestamp\", \"type\": \"uint64\"},\n        {\"name\": \"expiration\", \"type\": \"uint64\"},\n    ],\n    \"Withdraw\": [\n        {\"name\": \"brokerId\", \"type\": \"string\"},\n        {\"name\": \"chainId\", \"type\": \"uint256\"},\n        {\"name\": \"receiver\", \"type\": \"address\"},\n        {\"name\": \"token\", \"type\": \"string\"},\n        {\"name\": \"amount\", \"type\": \"uint256\"},\n        {\"name\": \"withdrawNonce\", \"type\": \"uint64\"},\n        {\"name\": \"timestamp\", \"type\": \"uint64\"},\n    ],\n    \"SettlePnl\": [\n        {\"name\": \"brokerId\", \"type\": \"string\"},\n        {\"name\": \"chainId\", \"type\": \"uint256\"},\n        {\"name\": \"settleNonce\", \"type\": \"uint64\"},\n        {\"name\": \"timestamp\", \"type\": \"uint64\"},\n    ],\n]\n\n\ndef get_off_chain_domain(chain_id: str):\n    # Used for Registration and Key Management\n    return {\n        \"name\": \"Orderly\",\n        \"version\": \"1\",\n        \"chainId\": chain_id,\n        \"verifyingContract\": \"0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC\",\n    }\n\n\ndef get_on_chain_domain(chain_id: str):\n    # Used for Withdrawals and PnL Settlement\n    return {\n        \"name\": \"Orderly\",\n        \"version\": \"1\",\n        \"chainId\": chain_id,\n        \"verifyingContract\": \"0x1826B75e2ef249173FC735149AE4B8e9ea10abff\",\n    }\n```",
      "keywords": ["python", "authentication", "api", "backend", "trading bot"],
      "source": "Generated from example repositories with AI enhancement",
      "generatedAt": "2026-02-04T19:16:37.368Z"
    },
    {
      "id": "enriched-132",
      "title": "Direct API Authentication (Java)",
      "category": "API",
      "content": "# Direct API Authentication (Java)\n\nThis guide provides detailed examples and explanations for authenticating with the Orderly Network API using Java. It covers how to securely sign requests using EdDSA (Ed25519) keys, manage configuration, and execute API calls like querying balances and placing orders.\n\n## When to use this\n\nYou should use this direct authentication approach when:\n*   **Building Custom Applications:** You are developing a trading bot, a backend service, or a custom UI that needs to interact directly with the Orderly Network smart contracts and off-chain API.\n*   **Fine-Grained Control:** You need specific control over request signing, timeout handling, or error management that higher-level SDKs might abstract away.\n*   **Server-Side Integration:** You are implementing backend logic to manage user accounts or execute trades on behalf of users (with their consent).\n\n## Prerequisites\n\nBefore implementing these examples, ensure your development environment is set up:\n\n1.  **Java Development Kit (JDK):** Ensure you have JDK 8 or higher installed.\n2.  **Dependencies:** Add the following libraries to your project (e.g., via Maven or Gradle):\n    *   `Web3j`: For Ethereum utility functions and credential management.\n    *   `OkHttp3`: For efficient HTTP requests.\n    *   `org.json`: For JSON parsing and construction.\n    *   `net.i2p.crypto.eddsa`: For Ed25519 signature generation.\n    *   `io.github.cdimascio:dotenv`: For managing environment variables securely.\n\n## Core Concepts\n\n*   **EdDSA (Ed25519):** Orderly Network uses the Ed25519 signature scheme for API authentication. This is distinct from the ECDSA (secp256k1) often used for blockchain transactions.\n*   **Request Signing:** Every private API request must include headers containing a signature, timestamp, and API key to prove the request originates from the legitimate holder of the private key without exposing the key itself.\n*   **Environment Variables:** Sensitive data (like your Private Key) should never be hardcoded. We use a `.env` file to load these securely.\n\n---\n\n## Configuration Management\n\nThe `Config` class centralizes network settings. This prevents hardcoding URLs and IDs throughout your application, making it easier to switch between Testnet and Mainnet.\n\n### src/main/java/org/web3j/Config.java\n\n```java\npackage org.web3j;\n\npublic class Config {\n   // The base URL for the Orderly Network API (varies by network)\n   public final String baseUrl;\n   \n   // The identifier for the broker facilitating the connection\n   public final String brokerId;\n   \n   // The Chain ID ensures transactions are executed on the correct blockchain\n   public final int chainId;\n\n   Config(String baseUrl, String brokerId, int chainId) {\n      this.baseUrl = baseUrl;\n      this.brokerId = brokerId;\n      this.chainId = chainId;\n   }\n\n   // Factory method to quickly retrieve Testnet configuration\n   public static Config testnet() {\n      return new Config(\"https://testnet-api-evm.orderly.org\", \"woofi_pro\", 421614);\n   }\n}\n```\n\n**Why this is needed:** Separating configuration logic allows you to maintain a single source of truth for network endpoints. If the API endpoint changes, you only update it here.\n\n---\n\n## Authentication and Signing\n\nThis example demonstrates the full flow of loading credentials, initializing the cryptographic signer, and placing a signed order.\n\n### src/main/java/org/web3j/AuthenticationExample.java\n\n```java\npackage org.web3j;\n\nimport io.github.cdimascio.dotenv.Dotenv;\nimport net.i2p.crypto.eddsa.EdDSAPrivateKey;\nimport net.i2p.crypto.eddsa.spec.EdDSANamedCurveTable;\nimport net.i2p.crypto.eddsa.spec.EdDSAParameterSpec;\nimport net.i2p.crypto.eddsa.spec.EdDSAPrivateKeySpec;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport org.bitcoinj.base.Base58;\nimport org.json.JSONObject;\n\npublic class AuthenticationExample {\n   public static void main(String[] args) throws Exception {\n      // 1. Define the API environment (Testnet in this case)\n      String baseUrl = \"https://testnet-api-evm.orderly.org\";\n      \n      // The unique account identifier assigned by Orderly Network\n      String orderlyAccountId = \"<orderly-account-id>\";\n\n      // 2. Load environment variables from .env file for security\n      Dotenv dotenv = Dotenv.load();\n      \n      // Initialize the HTTP client used to send requests\n      OkHttpClient client = new OkHttpClient();\n\n      // 3. Retrieve and decode the Private Key\n      // The key is stored in Base58 format in the .env file\n      String key = dotenv.get(\"ORDERLY_SECRET\");\n      \n      // Define the curve specification for Ed25519\n      EdDSAParameterSpec spec = EdDSANamedCurveTable.getByName(EdDSANamedCurveTable.ED_25519);\n      \n      // Decode the Base58 string into raw bytes to create the Private Key object\n      EdDSAPrivateKeySpec encoded = new EdDSAPrivateKeySpec(Base58.decode(key), spec);\n      EdDSAPrivateKey orderlyKey = new EdDSAPrivateKey(encoded);\n\n      // 4. Initialize the Signer with the config and keys\n      // The Signer class handles the logic of adding necessary headers (Signature, Timestamp)\n      Signer signer = new Signer(baseUrl, orderlyAccountId, orderlyKey);\n\n      // 5. Construct the Order Payload\n      JSONObject json = new JSONObject();\n      json.put(\"symbol\", \"PERP_ETH_USDC\");   // Trading pair\n      json.put(\"order_type\", \"MARKET\");      // Order execution type\n      json.put(\"order_quantity\", 0.01);      // Amount to trade\n      json.put(\"side\", \"BUY\");               // Direction of trade\n\n      // 6. Create the signed request\n      // The Signer automatically calculates the hash of the body and signs it with the private key\n      Request req = signer.createSignedRequest(\"/v1/order\", \"POST\", json);\n      \n      // 7. Execute the request and handle the response\n      String res;\n      try (Response response = client.newCall(req).execute()) {\n         res = response.body().string();\n      }\n      \n      // Parse the server response\n      JSONObject obj = new JSONObject(res);\n   }\n}\n```\n\n### Common Pitfalls & How to Avoid Them\n\n*   **Hardcoding Keys:** Never commit your private key to version control.\n    *   *Solution:* Always use a `.env` file (included in `.gitignore`) and load it using the `dotenv` library.\n*   **Incorrect Key Encoding:** Orderly keys are often Base58 encoded. Passing the raw string directly to the key generator will fail.\n    *   *Solution:* Always decode the key using `Base58.decode()` before passing it to `EdDSAPrivateKeySpec`.\n*   **Timestamp Mismatch:** API servers reject requests if the client's clock is too far out of sync (usually > 30s).\n    *   *Solution:* Ensure your server machine synchronizes time via NTP (Network Time Protocol).\n\n---\n\n## Account Management\n\nOnce authenticated, you typically need to query account state or manage funds. The `Account` class wraps these specific API interactions.\n\n### src/main/java/org/web3j/Account.java\n\n```java\npackage org.web3j;\n\nimport java.io.IOException;\nimport java.time.Instant;\nimport java.security.*;\n\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport org.web3j.crypto.Credentials;\nimport org.web3j.crypto.Sign;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\npublic class Account {\n\n   public final Config config;\n\n   private OkHttpClient client;\n   private Signer signer;\n   private Credentials credentials;\n\n   // Constructor to inject dependencies (Config, HTTP Client, and Signers)\n   public Account(Config config, OkHttpClient client, Signer signer, Credentials credentials) {\n      this.config = config;\n      this.client = client;\n      this.signer = signer;\n      this.credentials = credentials;\n   }\n\n   /**\n    * Get the current summary of user token holdings.\n    * This requires a signed GET request to the /client/holding endpoint.\n    * \n    * @throws OrderlyClientException\n    * @throws InvalidKeyException\n    * @throws SignatureException\n    * @throws IOException\n    */\n   public JSONArray getClientHolding()\n         throws OrderlyClientException, InvalidKeyException, SignatureException, IOException {\n      \n      // Create a signed GET request. The Signer adds the necessary authentication headers.\n      Request req = signer.createSignedRequest(\"/v1/client/holding\");\n      \n      String res;\n      try (Response response = client.newCall(req).execute()) {\n         res = response.body().string();\n      }\n      \n      System.out.println(\"client holding response: \" + res);\n      JSONObject obj = new JSONObject(res);\n      \n      // Navigate the JSON response to extract the holdings array\n      return obj.getJSONObject(\"data\").getJSONArray(\"holding\");\n   }\n\n   /**\n    * Retrieves the current withdrawal nonce.\n    * The nonce is a counter used to prevent replay attacks on withdrawal transactions.\n    */\n   public int getWithdrawNonce() throws InvalidKeyException, SignatureException, OrderlyClientException, IOException {\n      Request req = signer.createSignedRequest(\"/v1/withdraw_nonce\");\n      String res;\n      try (Response response = client.newCall(req).execute()) {\n         res = response.body().string();\n      }\n      JSONObject obj = new JSONObject(res);\n      return obj.getJSONObject(\"data\").getInt(\"withdraw_nonce\");\n   }\n\n   /**\n    * Initiates a withdrawal request.\n    * Note: This method is truncated in the example but requires a valid nonce.\n    */\n   public JSONObject withdraw(String token, String amount)\n         throws InvalidKeyException, SignatureException, OrderlyClientException, IOException {\n      int withdrawNo\n// ... (truncated)\n```\n\n### Common Pitfalls & How to Avoid Them\n\n*   **Ignoring Nonce:** For state-changing operations like withdrawals, the `withdraw_nonce` is critical. Sending a request with a reused or incorrect nonce will fail.\n    *   *Solution:* Always query the current nonce via `getWithdrawNonce()` immediately before constructing a withdrawal request.\n*   **Resource Leaks:** Failing to close the Response body can leak connections.\n    *   *Solution:* The examples use `try-with-resources` (`try (Response response = ...)`), which ensures the response is closed automatically.\n\n## Related Concepts\n\n*   **API Key Generation:** Learn how to generate the Orderly Key and Secret used in the `AuthenticationExample`.\n*   **Web3 Signatures:** While this guide uses EdDSA for API calls, on-chain transactions (deposits) require ECDSA signatures using `Credentials`.\n*   **Error Codes:** Refer to the API reference for standard error codes returned in the `JSONObject` response (e.g., insufficient balance, invalid signature).",
      "keywords": ["java", "authentication", "api", "backend", "enterprise"],
      "source": "Generated from example repositories with AI enhancement",
      "generatedAt": "2026-02-04T19:17:31.267Z"
    }
  ],
  "metadata": {
    "version": "3.0.0",
    "lastUpdated": "2026-02-04",
    "totalChunks": 133,
    "source": "Generated from 915 Telegram + 2074 Docs Q&A entries",
    "categories": [
      {
        "name": "SDK",
        "count": 842
      },
      {
        "name": "API",
        "count": 848
      },
      {
        "name": "Trading",
        "count": 394
      },
      {
        "name": "Authentication",
        "count": 188
      },
      {
        "name": "Wallet",
        "count": 120
      },
      {
        "name": "Orders",
        "count": 326
      },
      {
        "name": "Positions",
        "count": 50
      },
      {
        "name": "Deposits",
        "count": 30
      },
      {
        "name": "Withdrawals",
        "count": 7
      },
      {
        "name": "Subaccounts",
        "count": 1
      },
      {
        "name": "Errors",
        "count": 6
      },
      {
        "name": "Configuration",
        "count": 57
      },
      {
        "name": "Other",
        "count": 120
      }
    ],
    "enrichedAt": "2026-02-04T19:17:31.267Z",
    "enrichedFrom": "OrderlyNetwork/examples and OrderlyNetwork/broker-registration repos (with AI enhancement)",
    "enrichmentStats": {
      "newChunks": 7,
      "previousTotal": 126,
      "aiEnhanced": true
    }
  }
}
